var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
System.register("Progressable", [], function (exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    function avg(L) {
        var s = 0;
        L.forEach(function (i) { return s += i; });
        s /= L.length;
        return s;
    }
    function setTimeoutProgressable(n) {
        var p = new Promise(function (resolve, reject) {
            setTimeout(function () {
                resolve(n);
            }, n);
        });
        var pr = new Progressable(p);
        var start = +(new Date());
        function tick() {
            var ms = +(new Date());
            var t = (ms - start) / n;
            pr.setProgress(t);
            if (t < 1)
                window.requestAnimationFrame(tick);
        }
        tick();
        return pr;
    }
    var Progressable;
    return {
        setters: [],
        execute: function () {
            Progressable = /** @class */ (function () {
                function Progressable(promise, initialProgress) {
                    if (initialProgress === void 0) { initialProgress = 0; }
                    this.promise = promise;
                    this.onProgress = null;
                    this.progress = initialProgress;
                }
                Progressable.prototype.setProgress = function (n) {
                    this.progress = n;
                    if (this.onProgress !== null)
                        this.onProgress();
                };
                Progressable.prototype.then = function (onfulfilled) {
                    var _this = this;
                    // The rough idea is that any then-able is implicitly at the same progress as this one.
                    var pr = new Progressable(this.promise.then(onfulfilled), this.progress);
                    this.onProgress = function () {
                        pr.setProgress(_this.progress);
                    };
                    return pr;
                };
                Progressable.all = function (progressables) {
                    var p = Promise.all(progressables.map(function (p) { return p.promise; }));
                    function calcProgress() {
                        var progresses = progressables.map(function (p) { return p.progress; });
                        pr.progress = avg(progresses);
                        if (pr.onProgress !== null)
                            pr.onProgress();
                    }
                    progressables.forEach(function (p) {
                        p.onProgress = calcProgress;
                    });
                    var pr = new Progressable(p);
                    return pr;
                };
                return Progressable;
            }());
            exports_1("default", Progressable);
        }
    };
});
System.register("util", ["ArrayBufferSlice", "Progressable"], function (exports_2, context_2) {
    "use strict";
    var __moduleName = context_2 && context_2.id;
    function fetch(path) {
        var request = new XMLHttpRequest();
        request.open("GET", path, true);
        request.responseType = "arraybuffer";
        request.send();
        var p = new Promise(function (resolve, reject) {
            request.onload = function () {
                pr.setProgress(1);
                var buffer = request.response;
                var slice = new ArrayBufferSlice_1.default(buffer);
                resolve(slice);
            };
            request.onerror = function () {
                reject();
            };
            request.onprogress = function (e) {
                if (e.lengthComputable)
                    pr.setProgress(e.loaded / e.total);
            };
        });
        var pr = new Progressable_1.default(p);
        return pr;
    }
    exports_2("fetch", fetch);
    function assert(b) {
        if (!b) {
            console.error(new Error().stack);
            throw new Error("Assert fail");
        }
    }
    exports_2("assert", assert);
    function assertExists(v) {
        if (v)
            return v;
        else
            throw new Error("Missing object");
    }
    exports_2("assertExists", assertExists);
    function readString(buffer, offs, length, nulTerminated) {
        if (length === void 0) { length = -1; }
        if (nulTerminated === void 0) { nulTerminated = true; }
        var buf = buffer.createTypedArray(Uint8Array, offs);
        var S = '';
        var i = 0;
        while (true) {
            if (length > 0 && i >= length)
                break;
            if (nulTerminated && buf[i] === 0)
                break;
            S += String.fromCharCode(buf[i]);
            i++;
        }
        return S;
    }
    exports_2("readString", readString);
    function align(n, multiple) {
        var mask = (multiple - 1);
        return (n + mask) & ~mask;
    }
    exports_2("align", align);
    function generateFormID() {
        return "FormGeneratedID_" + counter++;
    }
    exports_2("generateFormID", generateFormID);
    function nArray(n, c) {
        var d = new Array(n);
        while (n--)
            d[n] = c();
        return d;
    }
    exports_2("nArray", nArray);
    // Eat your heart out, npm.
    function leftPad(S, spaces) {
        while (S.length < spaces)
            S = "0" + S;
        return S;
    }
    exports_2("leftPad", leftPad);
    function hexzero(n, spaces) {
        var S = n.toString(16);
        return leftPad(S, spaces);
    }
    exports_2("hexzero", hexzero);
    function hexdump(buffer, offs, length) {
        if (offs === void 0) { offs = 0; }
        if (length === void 0) { length = 0x100; }
        var groupSize = 16;
        var S = '';
        var arr = buffer.createTypedArray(Uint8Array, offs, length);
        for (var i = offs; i < length; i += groupSize) {
            S += hexzero(i, 8) + "    ";
            for (var j = 0; j < groupSize; j++) {
                var b = arr[i + j];
                S += " " + hexzero(b, 2);
            }
            S += '  ';
            for (var j = 0; j < groupSize; j++) {
                var b = arr[i + j];
                var c = (b >= 0x20 && b < 0x7F) ? String.fromCharCode(b) : '.';
                S += "" + c;
            }
            S += '\n';
        }
        console.log(S);
    }
    exports_2("hexdump", hexdump);
    var ArrayBufferSlice_1, Progressable_1, counter;
    return {
        setters: [
            function (ArrayBufferSlice_1_1) {
                ArrayBufferSlice_1 = ArrayBufferSlice_1_1;
            },
            function (Progressable_1_1) {
                Progressable_1 = Progressable_1_1;
            }
        ],
        execute: function () {
            counter = 0;
            window.hexdump = hexdump;
        }
    };
});
System.register("endian", [], function (exports_3, context_3) {
    "use strict";
    var __moduleName = context_3 && context_3.id;
    function getSystemEndianness() {
        return systemEndianness;
    }
    exports_3("getSystemEndianness", getSystemEndianness);
    var test, testView, systemEndianness;
    return {
        setters: [],
        execute: function () {
            test = new Uint16Array([0xFEFF]);
            testView = new DataView(test.buffer);
            systemEndianness = (testView.getUint8(0) == 0xFF) ? 0 /* LITTLE_ENDIAN */ : 1 /* BIG_ENDIAN */;
        }
    };
});
System.register("ArrayBufferSlice", ["util", "endian"], function (exports_4, context_4) {
    "use strict";
    var __moduleName = context_4 && context_4.id;
    function isAligned(n, m) {
        return (n & (m - 1)) === 0;
    }
    var util_1, endian_1, ArrayBuffer_slice, ArrayBufferSlice;
    return {
        setters: [
            function (util_1_1) {
                util_1 = util_1_1;
            },
            function (endian_1_1) {
                endian_1 = endian_1_1;
            }
        ],
        execute: function () {
            // This implements a "saner" ArrayBuffer, since the JS one is absurd.
            //
            // The biggest issue is that ArrayBuffer.prototype.slice does not make a read-only view, but instead
            // a copy, and most browsers do not implement it as a COW buffer but instead a separate buffer backed
            // by a separate memcpy. There is no way to create a read-only or ArrayBufferView, since that goal is
            // mostly relegated to the typed arrays or DataViews, which have unmatching and different APIs.
            //
            // ArrayBufferSlice's are designed to be read-only, however, JavaScript has no way of enforcing this
            // currently...
            // Install our dummy ArrayBuffer.prototype.slice to catch any rogue offenders.
            ArrayBuffer_slice = ArrayBuffer.prototype.slice;
            ArrayBuffer.prototype.slice = function (begin, end) {
                throw new Error("Do not use ArrayBuffer.prototype.slice");
            };
            ArrayBufferSlice = /** @class */ (function () {
                function ArrayBufferSlice(
                // The name arrayBuffer is chosen so that someone can't easily mistake an ArrayBufferSlice
                // for an ArrayBuffer or ArrayBufferView, which is important for native APIs like OpenGL that
                // will silently choke on something like this. TypeScript has no way to explicitly mark our
                // class as incompatible with the ArrayBuffer interface.
                arrayBuffer, byteOffset, byteLength) {
                    if (byteOffset === void 0) { byteOffset = 0; }
                    if (byteLength === void 0) { byteLength = arrayBuffer.byteLength; }
                    this.arrayBuffer = arrayBuffer;
                    this.byteOffset = byteOffset;
                    this.byteLength = byteLength;
                    util_1.assert(byteOffset >= 0 && byteLength >= 0 && (byteOffset + byteLength) <= this.arrayBuffer.byteLength);
                }
                ArrayBufferSlice.prototype.slice = function (begin, end) {
                    var absBegin = this.byteOffset + begin;
                    var absEnd = this.byteOffset + (end !== undefined ? end : this.byteLength);
                    return new ArrayBufferSlice(this.arrayBuffer, absBegin, absEnd - absBegin);
                };
                ArrayBufferSlice.prototype.subarray = function (begin, byteLength) {
                    var absBegin = this.byteOffset + begin;
                    if (byteLength === undefined)
                        byteLength = this.byteLength - begin;
                    util_1.assert(byteLength >= 0 && byteLength <= this.byteLength);
                    return new ArrayBufferSlice(this.arrayBuffer, absBegin, byteLength);
                };
                ArrayBufferSlice.prototype.copyToBuffer = function (offs, length) {
                    if (offs === void 0) { offs = 0; }
                    var start = this.byteOffset + offs;
                    var end = length !== undefined ? start + length : this.byteOffset + this.byteLength;
                    return ArrayBuffer_slice.call(this.arrayBuffer, start, end);
                };
                ArrayBufferSlice.prototype.copyToSlice = function (offs, length) {
                    if (offs === void 0) { offs = 0; }
                    return new ArrayBufferSlice(this.copyToBuffer(offs, length));
                };
                ArrayBufferSlice.prototype.castToBuffer = function () {
                    if (this.byteOffset === 0 && this.byteLength === this.arrayBuffer.byteLength) {
                        return this.arrayBuffer;
                    }
                    else {
                        return this.copyToBuffer();
                    }
                };
                ArrayBufferSlice.prototype.createDataView = function (offs, length) {
                    if (offs === void 0) { offs = 0; }
                    if (offs === 0 && length === undefined) {
                        return new DataView(this.arrayBuffer, this.byteOffset, this.byteLength);
                    }
                    else {
                        return this.subarray(offs, length).createDataView();
                    }
                };
                ArrayBufferSlice.prototype.bswap16 = function () {
                    util_1.assert(this.byteLength % 2 === 0);
                    var a = this.createTypedArray(Uint8Array);
                    var o = new Uint8Array(this.byteLength);
                    for (var i = 0; i < a.byteLength; i += 2) {
                        o[i + 0] = a[i + 1];
                        o[i + 1] = a[i + 0];
                    }
                    return new ArrayBufferSlice(o.buffer);
                };
                ArrayBufferSlice.prototype.bswap32 = function () {
                    util_1.assert(this.byteLength % 4 === 0);
                    var a = this.createTypedArray(Uint8Array);
                    var o = new Uint8Array(a.byteLength);
                    for (var i = 0; i < a.byteLength; i += 4) {
                        o[i + 0] = a[i + 3];
                        o[i + 1] = a[i + 2];
                        o[i + 2] = a[i + 1];
                        o[i + 3] = a[i + 0];
                    }
                    return new ArrayBufferSlice(o.buffer);
                };
                ArrayBufferSlice.prototype.bswap = function (componentSize) {
                    if (componentSize === 2) {
                        return this.bswap16();
                    }
                    else if (componentSize === 4) {
                        return this.bswap32();
                    }
                    else {
                        return componentSize;
                    }
                };
                ArrayBufferSlice.prototype.convertFromEndianness = function (endianness, componentSize) {
                    if (componentSize !== 1 && endianness !== endian_1.getSystemEndianness())
                        return this.bswap(componentSize);
                    else
                        return this;
                };
                ArrayBufferSlice.prototype.createTypedArray = function (clazz, offs, count, endianness) {
                    if (offs === void 0) { offs = 0; }
                    if (endianness === void 0) { endianness = 0 /* LITTLE_ENDIAN */; }
                    var begin = this.byteOffset + offs;
                    var byteLength;
                    if (count !== undefined) {
                        byteLength = clazz.BYTES_PER_ELEMENT * count;
                    }
                    else {
                        byteLength = this.byteLength - offs;
                        util_1.assert(isAligned(begin, clazz.BYTES_PER_ELEMENT));
                        count = byteLength / clazz.BYTES_PER_ELEMENT;
                        util_1.assert((count | 0) === count);
                    }
                    var componentSize = clazz.BYTES_PER_ELEMENT;
                    var needsEndianSwap = (componentSize > 1) && (endianness !== endian_1.getSystemEndianness());
                    // Typed arrays require alignment.
                    if (needsEndianSwap) {
                        var componentSize_ = componentSize;
                        var copy = this.subarray(offs, byteLength).bswap(componentSize_);
                        return copy.createTypedArray(clazz);
                    }
                    else if (isAligned(begin, componentSize)) {
                        return new clazz(this.arrayBuffer, begin, count);
                    }
                    else {
                        return new clazz(this.copyToBuffer(offs, byteLength), 0);
                    }
                };
                return ArrayBufferSlice;
            }());
            exports_4("default", ArrayBufferSlice);
        }
    };
});
// Helper utility to combine buffers together for performance reasons.
System.register("BufferCoalescer", ["util"], function (exports_5, context_5) {
    "use strict";
    var __moduleName = context_5 && context_5.id;
    function coalesceBuffer(gl, target, datas) {
        var dataLength = 0;
        try {
            for (var datas_1 = __values(datas), datas_1_1 = datas_1.next(); !datas_1_1.done; datas_1_1 = datas_1.next()) {
                var data = datas_1_1.value;
                dataLength += data.byteLength;
                dataLength = util_2.align(dataLength, 4);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (datas_1_1 && !datas_1_1.done && (_a = datas_1.return)) _a.call(datas_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var buffer = gl.createBuffer();
        gl.bindBuffer(target, buffer);
        gl.bufferData(target, dataLength, gl.STATIC_DRAW);
        var coalescedBuffers = [];
        var offset = 0;
        try {
            for (var datas_2 = __values(datas), datas_2_1 = datas_2.next(); !datas_2_1.done; datas_2_1 = datas_2.next()) {
                var data = datas_2_1.value;
                var size = data.byteLength;
                coalescedBuffers.push({ buffer: buffer, offset: offset });
                gl.bufferSubData(target, offset, data.createTypedArray(Uint8Array));
                offset += size;
                offset = util_2.align(offset, 4);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (datas_2_1 && !datas_2_1.done && (_b = datas_2.return)) _b.call(datas_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return coalescedBuffers;
        var e_1, _a, e_2, _b;
    }
    exports_5("coalesceBuffer", coalesceBuffer);
    var util_2, FakeBufferCoalescer, BufferCoalescer;
    return {
        setters: [
            function (util_2_1) {
                util_2 = util_2_1;
            }
        ],
        execute: function () {
            // For debugging. Should be identical to just using the original buffers.
            FakeBufferCoalescer = /** @class */ (function () {
                function FakeBufferCoalescer(gl, vertexDatas, indexDatas) {
                    this.vertexBuffers = [];
                    this.indexBuffers = [];
                    util_2.assert(vertexDatas.length === indexDatas.length);
                    var coalescedBuffers = [];
                    for (var i = 0; i < vertexDatas.length; i++) {
                        var vertexCoalescedBuffers = coalesceBuffer(gl, gl.ARRAY_BUFFER, [vertexDatas[i]]);
                        var indexCoalescedBuffers = coalesceBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, [indexDatas[i]]);
                        var vertexBuffer = vertexCoalescedBuffers[0];
                        var indexBuffer = indexCoalescedBuffers[0];
                        this.vertexBuffers.push(vertexBuffer.buffer);
                        this.indexBuffers.push(indexBuffer.buffer);
                        coalescedBuffers.push({ vertexBuffer: vertexBuffer, indexBuffer: indexBuffer });
                    }
                    this.coalescedBuffers = coalescedBuffers;
                }
                FakeBufferCoalescer.prototype.destroy = function (gl) {
                    try {
                        for (var _a = __values(this.vertexBuffers), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var vertexBuffer = _b.value;
                            gl.deleteBuffer(vertexBuffer);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    try {
                        for (var _d = __values(this.indexBuffers), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var indexBuffer = _e.value;
                            gl.deleteBuffer(indexBuffer);
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                    var e_3, _c, e_4, _f;
                };
                return FakeBufferCoalescer;
            }());
            exports_5("FakeBufferCoalescer", FakeBufferCoalescer);
            BufferCoalescer = /** @class */ (function () {
                function BufferCoalescer(gl, vertexDatas, indexDatas) {
                    this.vertexBuffer = null;
                    this.indexBuffer = null;
                    util_2.assert(vertexDatas.length === indexDatas.length);
                    // Don't do anything if we have no data to care about.
                    if (vertexDatas.length === 0)
                        return;
                    var vertexCoalescedBuffers = coalesceBuffer(gl, gl.ARRAY_BUFFER, vertexDatas);
                    var indexCoalescedBuffers = coalesceBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, indexDatas);
                    var coalescedBuffers = [];
                    for (var i = 0; i < vertexCoalescedBuffers.length; i++) {
                        var vertexBuffer = vertexCoalescedBuffers[i];
                        var indexBuffer = indexCoalescedBuffers[i];
                        coalescedBuffers.push({ vertexBuffer: vertexBuffer, indexBuffer: indexBuffer });
                    }
                    this.coalescedBuffers = coalescedBuffers;
                    this.vertexBuffer = this.coalescedBuffers[0].vertexBuffer.buffer;
                    this.indexBuffer = this.coalescedBuffers[0].indexBuffer.buffer;
                }
                BufferCoalescer.prototype.destroy = function (gl) {
                    if (this.vertexBuffer !== null)
                        gl.deleteBuffer(this.vertexBuffer);
                    if (this.indexBuffer !== null)
                        gl.deleteBuffer(this.indexBuffer);
                };
                return BufferCoalescer;
            }());
            exports_5("default", BufferCoalescer);
        }
    };
});
System.register("InputManager", [], function (exports_6, context_6) {
    "use strict";
    var __moduleName = context_6 && context_6.id;
    var InputManager;
    return {
        setters: [],
        execute: function () {
            InputManager = /** @class */ (function () {
                function InputManager(toplevel) {
                    var _this = this;
                    this.grabbing = false;
                    this._onKeyDown = function (e) {
                        _this.keysDown.set(e.code, true);
                    };
                    this._onKeyUp = function (e) {
                        _this.keysDown.delete(e.code);
                    };
                    this._onWheel = function (e) {
                        e.preventDefault();
                        _this.dz += Math.sign(e.deltaY) * -4;
                    };
                    this._onMouseMove = function (e) {
                        if (!_this.grabbing)
                            return;
                        var dx = e.pageX - _this.lastX;
                        var dy = e.pageY - _this.lastY;
                        _this.lastX = e.pageX;
                        _this.lastY = e.pageY;
                        _this.dx += dx;
                        _this.dy += dy;
                    };
                    this._onMouseUp = function (e) {
                        _this._setGrabbing(false);
                        _this.button = 0;
                    };
                    this._onMouseDown = function (e) {
                        _this.button = e.button;
                        _this.lastX = e.pageX;
                        _this.lastY = e.pageY;
                        _this._setGrabbing(true);
                        // Needed to make the cursor update in Chrome. See:
                        // https://bugs.chromium.org/p/chromium/issues/detail?id=676644
                        _this.toplevel.focus();
                        e.preventDefault();
                    };
                    this.toplevel = toplevel;
                    this.keysDown = new Map();
                    window.addEventListener('keydown', this._onKeyDown);
                    window.addEventListener('keyup', this._onKeyUp);
                    this.toplevel.addEventListener('wheel', this._onWheel, { passive: false });
                    this.toplevel.addEventListener('mousedown', this._onMouseDown);
                    this.resetMouse();
                }
                InputManager.prototype.isKeyDown = function (key) {
                    return this.keysDown.get(key);
                };
                InputManager.prototype.isDragging = function () {
                    return this.grabbing;
                };
                InputManager.prototype.resetMouse = function () {
                    this.dx = 0;
                    this.dy = 0;
                    this.dz = 0;
                };
                InputManager.prototype._setGrabbing = function (v) {
                    if (this.grabbing === v)
                        return;
                    this.grabbing = v;
                    this.toplevel.style.cursor = v ? '-webkit-grabbing' : '-webkit-grab';
                    this.toplevel.style.cursor = v ? 'grabbing' : 'grab';
                    this.toplevel.style.setProperty('pointer-events', v ? 'auto' : '', 'important');
                    if (v) {
                        document.addEventListener('mousemove', this._onMouseMove);
                        document.addEventListener('mouseup', this._onMouseUp);
                    }
                    else {
                        document.removeEventListener('mousemove', this._onMouseMove);
                        document.removeEventListener('mouseup', this._onMouseUp);
                    }
                };
                return InputManager;
            }());
            exports_6("InputManager", InputManager);
        }
    };
});
System.register("Camera", ["gl-matrix", "util"], function (exports_7, context_7) {
    "use strict";
    var __moduleName = context_7 && context_7.id;
    function computeViewMatrix(out, camera) {
        gl_matrix_1.mat4.copy(out, camera.viewMatrix);
    }
    exports_7("computeViewMatrix", computeViewMatrix);
    function computeViewMatrixSkybox(out, camera) {
        gl_matrix_1.mat4.copy(out, camera.viewMatrix);
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
    }
    exports_7("computeViewMatrixSkybox", computeViewMatrixSkybox);
    function computeModelMatrixBillboard(out, camera) {
        gl_matrix_1.mat4.identity(out);
        // Right vector
        out[0] = camera.worldMatrix[0];
        out[4] = camera.worldMatrix[4];
        out[8] = camera.worldMatrix[8];
        // Up vector
        out[1] = camera.worldMatrix[1];
        out[5] = camera.worldMatrix[5];
        out[9] = camera.worldMatrix[9];
        // Forward vector
        out[2] = camera.worldMatrix[2];
        out[6] = camera.worldMatrix[6];
        out[8] = camera.worldMatrix[8];
    }
    exports_7("computeModelMatrixBillboard", computeModelMatrixBillboard);
    function computeModelMatrixYBillboard(out, camera) {
        gl_matrix_1.mat4.identity(out);
        // Right vector
        out[0] = camera.worldMatrix[0];
        out[4] = camera.worldMatrix[4];
        out[8] = camera.worldMatrix[8];
        // Forward vector
        out[2] = camera.worldMatrix[2];
        out[6] = camera.worldMatrix[6];
        out[8] = camera.worldMatrix[8];
    }
    exports_7("computeModelMatrixYBillboard", computeModelMatrixYBillboard);
    function clamp(v, min, max) {
        return Math.max(min, Math.min(v, max));
    }
    function clampRange(v, lim) {
        return clamp(v, -lim, lim);
    }
    // Probably don't belong in here, but are helpful nonetheless.
    function texProjPerspMtx(dst, fov, aspect, scaleS, scaleT, transS, transT) {
        var cot = 1 / Math.tan(fov / 2);
        dst[0] = (cot / aspect) * scaleS;
        dst[4] = 0.0;
        dst[8] = -transS;
        dst[12] = 0.0;
        dst[1] = 0.0;
        dst[5] = cot * scaleT;
        dst[9] = -transT;
        dst[13] = 0.0;
        dst[2] = 0.0;
        dst[6] = 0.0;
        dst[10] = -1.0;
        dst[14] = 0.0;
        // Fill with junk to try and signal when something has gone horribly wrong. This should go unused,
        // since this is supposed to generate a mat4x3 matrix.
        dst[3] = 9999.0;
        dst[7] = 9999.0;
        dst[11] = 9999.0;
        dst[15] = 9999.0;
    }
    exports_7("texProjPerspMtx", texProjPerspMtx);
    function texEnvMtx(dst, scaleS, scaleT, transS, transT) {
        dst[0] = scaleS;
        dst[4] = 0.0;
        dst[8] = 0.0;
        dst[12] = transS;
        dst[1] = 0.0;
        dst[5] = -scaleT;
        dst[9] = 0.0;
        dst[13] = transT;
        dst[2] = 0.0;
        dst[6] = 0.0;
        dst[10] = 0.0;
        dst[14] = 1.0;
        // Fill with junk to try and signal when something has gone horribly wrong. This should go unused,
        // since this is supposed to generate a mat4x3 matrix.
        dst[3] = 9999.0;
        dst[7] = 9999.0;
        dst[11] = 9999.0;
        dst[15] = 9999.0;
    }
    exports_7("texEnvMtx", texEnvMtx);
    var gl_matrix_1, util_3, Plane, scratchVec3a, scratchVec3b, scratchVec3c, scratchVec3d, AABB, FrustumVisualizer, IntersectionState, Frustum, Camera, FPSCameraController, OrbitCameraController;
    return {
        setters: [
            function (gl_matrix_1_1) {
                gl_matrix_1 = gl_matrix_1_1;
            },
            function (util_3_1) {
                util_3 = util_3_1;
            }
        ],
        execute: function () {
            Plane = /** @class */ (function () {
                function Plane() {
                }
                Plane.prototype.test = function (x, y, z) {
                    var dot = x * this.x + y * this.y + z * this.z;
                    return this.d + dot;
                };
                Plane.prototype.set = function (p0, p1, p2) {
                    var scratch = Plane.scratchVec3;
                    gl_matrix_1.vec3.sub(scratch[0], p2, p0);
                    gl_matrix_1.vec3.sub(scratch[1], p1, p0);
                    gl_matrix_1.vec3.cross(scratch[0], scratch[0], scratch[1]);
                    gl_matrix_1.vec3.normalize(scratch[0], scratch[0]);
                    this.x = scratch[0][0];
                    this.y = scratch[0][1];
                    this.z = scratch[0][2];
                    this.d = -gl_matrix_1.vec3.dot(scratch[0], p0);
                };
                Plane.scratchVec3 = util_3.nArray(2, function () { return gl_matrix_1.vec3.create(); });
                return Plane;
            }());
            scratchVec3a = gl_matrix_1.vec3.create();
            scratchVec3b = gl_matrix_1.vec3.create();
            scratchVec3c = gl_matrix_1.vec3.create();
            scratchVec3d = gl_matrix_1.vec3.create();
            AABB = /** @class */ (function () {
                function AABB(minX, minY, minZ, maxX, maxY, maxZ) {
                    if (minX === void 0) { minX = 0; }
                    if (minY === void 0) { minY = 0; }
                    if (minZ === void 0) { minZ = 0; }
                    if (maxX === void 0) { maxX = 0; }
                    if (maxY === void 0) { maxY = 0; }
                    if (maxZ === void 0) { maxZ = 0; }
                    this.minX = minX;
                    this.minY = minY;
                    this.minZ = minZ;
                    this.maxX = maxX;
                    this.maxY = maxY;
                    this.maxZ = maxZ;
                }
                AABB.prototype.transform = function (src, m) {
                    // Transforming Axis-Aligned Bounding Boxes from Graphics Gems.
                    var srcMin = scratchVec3a, srcMax = scratchVec3b;
                    gl_matrix_1.vec3.set(srcMin, src.minX, src.minY, src.minZ);
                    gl_matrix_1.vec3.set(srcMax, src.maxX, src.maxY, src.maxZ);
                    var dstMin = scratchVec3c, dstMax = scratchVec3d;
                    // Translation can be applied directly.
                    gl_matrix_1.vec3.set(dstMin, m[12], m[13], m[14]);
                    gl_matrix_1.vec3.set(dstMax, m[12], m[13], m[14]);
                    for (var i = 0; i < 3; i++) {
                        for (var j = 0; j < 3; j++) {
                            var a = m[j * 4 + i] * srcMin[j];
                            var b = m[j * 4 + i] * srcMax[j];
                            if (a < b) {
                                dstMin[i] += a;
                                dstMax[i] += b;
                            }
                            else {
                                dstMin[i] += b;
                                dstMax[i] += a;
                            }
                        }
                    }
                    this.minX = dstMin[0];
                    this.minY = dstMin[1];
                    this.minZ = dstMin[2];
                    this.maxX = dstMax[0];
                    this.maxY = dstMax[1];
                    this.maxZ = dstMax[2];
                };
                AABB.prototype.set = function (points) {
                    this.minX = this.minY = this.minZ = Infinity;
                    this.maxX = this.maxY = this.maxZ = -Infinity;
                    for (var i = 0; i < points.length; i++) {
                        var p = points[i];
                        this.minX = Math.min(this.minX, p[0]);
                        this.minY = Math.min(this.minY, p[1]);
                        this.minZ = Math.min(this.minZ, p[2]);
                        this.maxX = Math.max(this.maxX, p[0]);
                        this.maxY = Math.max(this.maxY, p[1]);
                        this.maxZ = Math.max(this.maxZ, p[2]);
                    }
                };
                AABB.intersect = function (a, b) {
                    return !(a.minX > b.maxX || b.minX > a.maxX ||
                        a.minY > b.maxY || b.minY > a.maxY ||
                        a.minZ > b.maxZ || b.minZ > a.maxZ);
                };
                return AABB;
            }());
            exports_7("AABB", AABB);
            FrustumVisualizer = /** @class */ (function () {
                function FrustumVisualizer() {
                    this.scale = 1 / 100000;
                    this.canvas = document.createElement('canvas');
                    this.canvas.width = 1080;
                    this.canvas.height = 768;
                    document.body.appendChild(this.canvas);
                    this.canvas.style.position = 'absolute';
                    this.canvas.style.top = '0';
                    this.canvas.style.left = '0';
                    this.canvas.style.opacity = '0.5';
                    this.canvas.style.pointerEvents = 'none';
                    this.ctx = this.canvas.getContext('2d');
                }
                FrustumVisualizer.prototype.newFrame = function () {
                    this.ctx.fillStyle = 'white';
                    this.ctx.save();
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.restore();
                };
                FrustumVisualizer.prototype.dsx = function (n) {
                    return ((n * this.scale) + 0.5) * this.canvas.width;
                };
                FrustumVisualizer.prototype.dsy = function (n) {
                    return ((n * this.scale) + 0.5) * this.canvas.height;
                };
                FrustumVisualizer.prototype.daabb /* on the haters */ = function (aabb) {
                    var x1 = this.dsx(aabb.minX);
                    var y1 = this.dsy(aabb.minZ);
                    var x2 = this.dsx(aabb.maxX);
                    var y2 = this.dsy(aabb.maxZ);
                    this.ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                };
                return FrustumVisualizer;
            }());
            (function (IntersectionState) {
                IntersectionState[IntersectionState["FULLY_INSIDE"] = 0] = "FULLY_INSIDE";
                IntersectionState[IntersectionState["FULLY_OUTSIDE"] = 1] = "FULLY_OUTSIDE";
                IntersectionState[IntersectionState["PARTIAL_INTERSECT"] = 2] = "PARTIAL_INTERSECT";
            })(IntersectionState || (IntersectionState = {}));
            exports_7("IntersectionState", IntersectionState);
            Frustum = /** @class */ (function () {
                function Frustum() {
                    // World-space configuration.
                    this.aabb = new AABB();
                    // Left, Right, Near, Far, Top, Bottom
                    this.planes = util_3.nArray(6, function () { return new Plane(); });
                    this.visualizer = null;
                }
                Frustum.prototype.makeVisualizer = function () {
                    this.visualizer = new FrustumVisualizer();
                };
                Frustum.prototype.setViewFrustum = function (left, right, bottom, top, n, f) {
                    this.left = left;
                    this.right = right;
                    this.bottom = bottom;
                    this.top = top;
                    this.near = -n;
                    this.far = -f;
                };
                Frustum.prototype.updateWorldFrustum = function (worldMatrix) {
                    var scratch = Frustum.scratchPlaneVec3;
                    var fn = this.far / this.near;
                    gl_matrix_1.vec3.set(scratch[0], this.left, this.top, this.near);
                    gl_matrix_1.vec3.set(scratch[1], this.right, this.top, this.near);
                    gl_matrix_1.vec3.set(scratch[2], this.right, this.bottom, this.near);
                    gl_matrix_1.vec3.set(scratch[3], this.left, this.bottom, this.near);
                    gl_matrix_1.vec3.set(scratch[4], fn * this.left, fn * this.top, this.far);
                    gl_matrix_1.vec3.set(scratch[5], fn * this.right, fn * this.top, this.far);
                    gl_matrix_1.vec3.set(scratch[6], fn * this.right, fn * this.bottom, this.far);
                    gl_matrix_1.vec3.set(scratch[7], fn * this.left, fn * this.bottom, this.far);
                    gl_matrix_1.vec3.set(scratch[8], 0, 0, 0);
                    for (var i = 0; i < 9; i++)
                        gl_matrix_1.vec3.transformMat4(scratch[i], scratch[i], worldMatrix);
                    this.aabb.set(scratch);
                    this.planes[0].set(scratch[8], scratch[3], scratch[0]); // left plane
                    this.planes[1].set(scratch[8], scratch[1], scratch[2]); // right plane
                    this.planes[2].set(scratch[0], scratch[1], scratch[2]); // near plane
                    this.planes[3].set(scratch[4], scratch[7], scratch[6]); // far plane
                    this.planes[4].set(scratch[8], scratch[0], scratch[1]); // top plane
                    this.planes[5].set(scratch[8], scratch[2], scratch[3]); // bottom plane
                    if (this.visualizer) {
                        var ctx = this.visualizer.ctx;
                        var scale = this.visualizer.scale;
                        // TODO(jstpierre): why isn't this working?
                        ctx.setTransform(1, 0, 0, 1, -worldMatrix[12] * scale, -worldMatrix[14] * scale);
                        ctx.strokeStyle = 'red';
                        this.visualizer.daabb(this.aabb);
                        gl_matrix_1.vec3.set(scratch[0], this.left, 0, this.near);
                        gl_matrix_1.vec3.set(scratch[1], this.right, 0, this.near);
                        gl_matrix_1.vec3.set(scratch[2], fn * this.right, 0, this.far);
                        gl_matrix_1.vec3.set(scratch[3], fn * this.left, 0, this.far);
                        ctx.strokeStyle = 'green';
                        ctx.beginPath();
                        for (var i = 0; i < 4; i++) {
                            var p = scratch[i];
                            gl_matrix_1.vec3.transformMat4(p, p, worldMatrix);
                            var x = this.visualizer.dsx(p[0]);
                            var y = this.visualizer.dsy(p[2]);
                            ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.stroke();
                    }
                };
                Frustum.prototype._intersect = function (aabb) {
                    if (!AABB.intersect(this.aabb, aabb))
                        return IntersectionState.FULLY_OUTSIDE;
                    var ret = IntersectionState.FULLY_INSIDE;
                    // Test planes.
                    for (var i = 0; i < 6; i++) {
                        var plane = this.planes[i];
                        // Nearest point to the frustum.
                        var px = plane.x >= 0 ? aabb.minX : aabb.maxX;
                        var py = plane.y >= 0 ? aabb.minY : aabb.maxY;
                        var pz = plane.z >= 0 ? aabb.minZ : aabb.maxZ;
                        if (plane.test(px, py, pz) > 0)
                            return IntersectionState.FULLY_OUTSIDE;
                        // Farthest point from the frustum.
                        var fx = plane.x >= 0 ? aabb.maxX : aabb.minX;
                        var fy = plane.y >= 0 ? aabb.maxY : aabb.minY;
                        var fz = plane.z >= 0 ? aabb.maxZ : aabb.minZ;
                        if (plane.test(fx, fy, fz) > 0)
                            ret = IntersectionState.PARTIAL_INTERSECT;
                    }
                    return ret;
                };
                Frustum.prototype.intersect = function (aabb) {
                    var res = this._intersect(aabb);
                    if (this.visualizer) {
                        var ctx = this.visualizer.ctx;
                        ctx.strokeStyle = res === IntersectionState.FULLY_INSIDE ? 'black' : res === IntersectionState.FULLY_OUTSIDE ? 'red' : 'cyan';
                        this.visualizer.daabb(aabb);
                    }
                    return res;
                };
                Frustum.prototype.newFrame = function () {
                    if (this.visualizer)
                        this.visualizer.newFrame();
                };
                Frustum.scratchPlaneVec3 = util_3.nArray(9, function () { return gl_matrix_1.vec3.create(); });
                return Frustum;
            }());
            Camera = /** @class */ (function () {
                function Camera() {
                    this.viewMatrix = gl_matrix_1.mat4.create();
                    this.worldMatrix = gl_matrix_1.mat4.create();
                    this.projectionMatrix = gl_matrix_1.mat4.create();
                    this.frustum = new Frustum();
                }
                Camera.prototype.identity = function () {
                    gl_matrix_1.mat4.identity(this.worldMatrix);
                    gl_matrix_1.mat4.identity(this.viewMatrix);
                };
                Camera.prototype.worldMatrixUpdated = function () {
                    gl_matrix_1.mat4.invert(this.viewMatrix, this.worldMatrix);
                    this.frustum.updateWorldFrustum(this.worldMatrix);
                };
                Camera.prototype.setPerspective = function (fovY, aspect, n, f) {
                    var nearY = Math.tan(fovY * 0.5) * n;
                    var nearX = nearY * aspect;
                    this.setFrustum(-nearX, nearX, -nearY, nearY, n, f);
                };
                Camera.prototype.setFrustum = function (left, right, bottom, top, n, f) {
                    this.frustum.setViewFrustum(left, right, bottom, top, n, f);
                    this.frustum.updateWorldFrustum(this.worldMatrix);
                    gl_matrix_1.mat4.frustum(this.projectionMatrix, left, right, bottom, top, n, f);
                };
                Camera.prototype.newFrame = function () {
                    this.frustum.newFrame();
                };
                // For documentation more than anything.
                Camera.prototype.getWorldRight = function (out) {
                    gl_matrix_1.vec3.set(out, this.worldMatrix[0], this.worldMatrix[4], this.worldMatrix[8]);
                };
                Camera.prototype.getWorldUp = function (out) {
                    gl_matrix_1.vec3.set(out, this.worldMatrix[1], this.worldMatrix[5], this.worldMatrix[9]);
                };
                Camera.prototype.getWorldForward = function (out) {
                    gl_matrix_1.vec3.set(out, this.worldMatrix[2], this.worldMatrix[6], this.worldMatrix[10]);
                };
                return Camera;
            }());
            exports_7("Camera", Camera);
            FPSCameraController = /** @class */ (function () {
                function FPSCameraController() {
                    this.tmp1 = gl_matrix_1.vec3.create();
                    this.tmp2 = gl_matrix_1.vec3.create();
                    this.speed = 10;
                }
                FPSCameraController.prototype.serialize = function () {
                    var camera = this.camera;
                    var tx = camera.worldMatrix[12], ty = camera.worldMatrix[13], tz = camera.worldMatrix[14];
                    var rx = camera.worldMatrix[0], ry = camera.worldMatrix[4], rz = camera.worldMatrix[8];
                    var fx = camera.worldMatrix[2], fy = camera.worldMatrix[6], fz = camera.worldMatrix[10];
                    return tx.toFixed(2) + "," + ty.toFixed(2) + "," + tz.toFixed(2) + "," + fx.toFixed(2) + "," + fy.toFixed(2) + "," + fz.toFixed(2) + "," + rx.toFixed(2) + "," + ry.toFixed(2) + "," + rz.toFixed(2);
                };
                FPSCameraController.prototype.deserialize = function (state) {
                    var _a = __read(state.split(','), 9), tx = _a[0], ty = _a[1], tz = _a[2], fx = _a[3], fy = _a[4], fz = _a[5], rx = _a[6], ry = _a[7], rz = _a[8];
                    // Translation.
                    this.camera.worldMatrix[12] = +tx;
                    this.camera.worldMatrix[13] = +ty;
                    this.camera.worldMatrix[14] = +tz;
                    this.camera.worldMatrix[2] = +fx;
                    this.camera.worldMatrix[6] = +fy;
                    this.camera.worldMatrix[10] = +fz;
                    this.camera.worldMatrix[0] = +rx;
                    this.camera.worldMatrix[4] = +ry;
                    this.camera.worldMatrix[8] = +rz;
                    var u = gl_matrix_1.vec3.create();
                    gl_matrix_1.vec3.cross(u, [this.camera.worldMatrix[2], this.camera.worldMatrix[6], this.camera.worldMatrix[10]], [this.camera.worldMatrix[0], this.camera.worldMatrix[4], this.camera.worldMatrix[8]]);
                    gl_matrix_1.vec3.normalize(u, u);
                    this.camera.worldMatrix[1] = u[0];
                    this.camera.worldMatrix[5] = u[1];
                    this.camera.worldMatrix[9] = u[2];
                    this.camera.worldMatrixUpdated();
                };
                FPSCameraController.prototype.update = function (inputManager, dt) {
                    var camera = this.camera;
                    var updated = false;
                    this.speed += inputManager.dz;
                    this.speed = Math.max(this.speed, 1);
                    var mult = this.speed;
                    if (inputManager.isKeyDown('ShiftLeft') || inputManager.isKeyDown('ShiftRight'))
                        mult *= 5;
                    mult *= (dt / 16.0);
                    var movement = this.tmp1;
                    gl_matrix_1.vec3.set(movement, 0, 0, 0);
                    var tmp = this.tmp2;
                    var amt;
                    amt = 0;
                    if (inputManager.isKeyDown('KeyW')) {
                        amt = -mult;
                    }
                    else if (inputManager.isKeyDown('KeyS')) {
                        amt = mult;
                    }
                    if (amt !== 0) {
                        movement[2] = amt;
                    }
                    amt = 0;
                    if (inputManager.isKeyDown('KeyA')) {
                        amt = -mult;
                    }
                    else if (inputManager.isKeyDown('KeyD')) {
                        amt = mult;
                    }
                    if (amt !== 0) {
                        movement[0] = amt;
                    }
                    amt = 0;
                    if (inputManager.isKeyDown('KeyQ')) {
                        amt = -mult;
                    }
                    else if (inputManager.isKeyDown('KeyE')) {
                        amt = mult;
                    }
                    if (amt !== 0) {
                        // Instead of getting the camera up, instead use world up. Feels more natural.
                        camera.getWorldUp(tmp);
                        gl_matrix_1.vec3.scaleAndAdd(movement, movement, tmp, amt);
                        updated = true;
                    }
                    if (inputManager.isKeyDown('KeyB')) {
                        gl_matrix_1.mat4.identity(camera.worldMatrix);
                        updated = true;
                    }
                    if (inputManager.isKeyDown('KeyC')) {
                        console.log(camera);
                    }
                    // Rotate view.
                    var dx = inputManager.dx;
                    var dy = inputManager.dy;
                    if (dx !== 0 || dy !== 0) {
                        camera.getWorldUp(tmp);
                        gl_matrix_1.vec3.normalize(tmp, tmp);
                        gl_matrix_1.mat4.rotate(camera.worldMatrix, camera.worldMatrix, -dx / 500.0, tmp);
                        gl_matrix_1.mat4.rotate(camera.worldMatrix, camera.worldMatrix, -dy / 500.0, [1, 0, 0]);
                        updated = true;
                    }
                    if (!gl_matrix_1.vec3.exactEquals(movement, [0, 0, 0])) {
                        gl_matrix_1.mat4.translate(camera.worldMatrix, camera.worldMatrix, movement);
                        updated = true;
                    }
                    if (updated) {
                        this.camera.worldMatrixUpdated();
                    }
                    return updated;
                };
                return FPSCameraController;
            }());
            exports_7("FPSCameraController", FPSCameraController);
            OrbitCameraController = /** @class */ (function () {
                function OrbitCameraController() {
                    this.x = 0.15;
                    this.y = 0.35;
                    this.z = -150;
                    this.xVel = 0;
                    this.yVel = 0;
                    this.zVel = 0;
                    this.tx = 0;
                    this.ty = 0;
                    this.txVel = 0;
                    this.tyVel = 0;
                }
                OrbitCameraController.prototype.serialize = function () {
                    return '';
                };
                OrbitCameraController.prototype.deserialize = function (state) {
                };
                OrbitCameraController.prototype.update = function (inputManager, dt) {
                    // Get new velocities from inputs.
                    if (inputManager.button === 1) {
                        this.txVel += inputManager.dx * (-10 - Math.min(this.z, 0.01)) / 5000;
                        this.tyVel += inputManager.dy * (-10 - Math.min(this.z, 0.01)) / -5000;
                    }
                    else {
                        this.xVel += inputManager.dx / 200;
                        this.yVel += inputManager.dy / 200;
                    }
                    this.zVel += inputManager.dz;
                    if (inputManager.isKeyDown('A')) {
                        this.xVel += 0.05;
                    }
                    if (inputManager.isKeyDown('D')) {
                        this.xVel -= 0.05;
                    }
                    if (inputManager.isKeyDown('W')) {
                        this.yVel += 0.05;
                    }
                    if (inputManager.isKeyDown('S')) {
                        this.yVel -= 0.05;
                    }
                    this.xVel = clampRange(this.xVel, 2);
                    this.yVel = clampRange(this.yVel, 2);
                    var updated = this.xVel !== 0 || this.yVel !== 0 || this.zVel !== 0;
                    if (updated) {
                        // Apply velocities.
                        var drag = inputManager.isDragging() ? 0.92 : 0.96;
                        this.x += this.xVel / 10;
                        this.xVel *= drag;
                        this.y += this.yVel / 10;
                        this.yVel *= drag;
                        this.tx += this.txVel;
                        this.txVel *= drag;
                        this.ty += this.tyVel;
                        this.tyVel *= drag;
                        if (this.y < 0.04) {
                            this.y = 0.04;
                            this.yVel = 0;
                        }
                        if (this.y > 1.50) {
                            this.y = 1.50;
                            this.yVel = 0;
                        }
                        this.z += this.zVel;
                        this.zVel *= 0.8;
                        if (this.z > -10) {
                            this.z = -10;
                            this.zVel = 0;
                        }
                        var camera = this.camera;
                        // Calculate new camera from new x/y/z.
                        var sinX = Math.sin(this.x);
                        var cosX = Math.cos(this.x);
                        var sinY = Math.sin(this.y);
                        var cosY = Math.cos(this.y);
                        // TODO(jstpierre): Replace this with position/look direction.
                        gl_matrix_1.mat4.set(camera.worldMatrix, cosX, sinY * sinX, -cosY * sinX, 0, 0, cosY, sinY, 0, sinX, -sinY * cosX, cosY * cosX, 0, this.tx, this.ty, this.z, 1);
                        gl_matrix_1.mat4.invert(camera.worldMatrix, camera.worldMatrix);
                        this.camera.worldMatrixUpdated();
                    }
                    return updated;
                };
                return OrbitCameraController;
            }());
            exports_7("OrbitCameraController", OrbitCameraController);
        }
    };
});
System.register("CodeEditor", [], function (exports_8, context_8) {
    "use strict";
    var __moduleName = context_8 && context_8.id;
    function visibleRAF(elem, func) {
        var window = elem.ownerDocument.defaultView;
        var isRunning = false;
        function setRunning(running) {
            if (isRunning == running)
                return;
            isRunning = running;
            if (isRunning)
                window.requestAnimationFrame(update);
        }
        function update(t) {
            func(t);
            if (isRunning)
                window.requestAnimationFrame(update);
        }
        function callback(entries) {
            var intersectionRatio = entries[entries.length - 1].intersectionRatio;
            var shouldBeRunning = intersectionRatio > 0;
            setRunning(shouldBeRunning);
        }
        var observer = new IntersectionObserver(callback);
        observer.observe(elem);
    }
    // #region Color Utilities
    function colorLerp(ca, cb, t) {
        console.assert(ca[0] === '#' && ca.length === 7);
        var ar = parseInt(ca.slice(1, 3), 16), ag = parseInt(ca.slice(3, 5), 16), ab = parseInt(ca.slice(5, 7), 16);
        console.assert(cb[0] === '#' && cb.length === 7);
        var br = parseInt(cb.slice(1, 3), 16), bg = parseInt(cb.slice(3, 5), 16), bb = parseInt(cb.slice(5, 7), 16);
        var nr = ar + (br - ar) * t, ng = ag + (bg - ag) * t, nb = ab + (bb - ab) * t;
        var r = (nr | 0).toString(16), g = (ng | 0).toString(16), b = (nb | 0).toString(16);
        return "#" + r + g + b;
    }
    function colorGrayscale(c) {
        console.assert(c[0] === '#' && c.length === 7);
        var r = parseInt(c.slice(1, 3), 16), g = parseInt(c.slice(3, 5), 16), b = parseInt(c.slice(5, 7), 16);
        // NTSC primaries.
        var ny = r * 0.299 + g * 0.587 + b * 0.114;
        var y = (ny | 0).toString(16);
        return "#" + y + y + y;
    }
    // #endregion
    // #region NumberDragger
    // Gross number formatting function used to lop unlucky floating points off...
    // e.g. 12345.100000007 => '12345.1'
    function formatDecimal(value, places) {
        if (places === void 0) { places = 2; }
        var valueStr = value.toFixed(places);
        while (valueStr.includes('.') && '.0'.includes(valueStr.slice(-1)))
            valueStr = valueStr.slice(0, -1);
        return valueStr;
    }
    // #endregion
    // XXX: Differing browsers have inconsistent ways of drawing text... specifically,
    // they don't always agree on what 'top' baseline alignment is. This tries to
    // accurately measure the top margin by drawing a character and scanning where the top is...
    function expensiveMeasureTextMargin(document, width, height, font) {
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var ctx = canvas.getContext('2d');
        ctx.font = font;
        ctx.textBaseline = 'top';
        ctx.fillStyle = 'black';
        ctx.fillText('l', 0, 0);
        var image = ctx.getImageData(0, 0, width, height);
        for (var y = 0; y < image.height; y++)
            for (var x = 0; x < image.width; x++)
                if (image.data[4 * (y * image.width + x) + 3])
                    return y;
        throw new Error('wtf');
    }
    var MONOSPACE, CursorOverride, NumberDragger, CodeEditor;
    return {
        setters: [],
        execute: function () {
            // The monospace font we use...
            MONOSPACE = '"Source Code Pro", "Droid Sans Mono", monospace';
            // #endregion
            // #region Cursor
            // Helper class to globally set a cursor.
            CursorOverride = /** @class */ (function () {
                function CursorOverride(_document) {
                    this._document = _document;
                    this._styleElem = this._document.createElement('style');
                    this._document.head.appendChild(this._styleElem);
                    this._style = this._styleElem.sheet;
                    this._owner = null;
                }
                CursorOverride.prototype.setCursor = function (owner, cursor) {
                    // If we have a current owner, don't let modifications by other owners...
                    if (this._owner && owner !== this._owner)
                        return;
                    if (this._style.cssRules.length)
                        this._style.deleteRule(0);
                    if (cursor) {
                        var rule = "* { cursor: " + cursor + " !important; }";
                        this._style.insertRule(rule, 0);
                        this._owner = owner;
                    }
                    else {
                        this._owner = null;
                    }
                };
                return CursorOverride;
            }());
            NumberDragger = /** @class */ (function () {
                function NumberDragger(_document, _cursorOverride) {
                    this._document = _document;
                    this._cursorOverride = _cursorOverride;
                    // User callback.
                    this.onvalue = null;
                    this.onend = null;
                    this._toplevel = this._document.createElement('div');
                    this._toplevel.style.position = 'absolute';
                    this._toplevel.style.transform = 'translate(0, -50%)';
                    this._toplevel.style.fontFamily = MONOSPACE;
                    this._toplevel.style.backgroundColor = '#232323';
                    this._toplevel.style.color = '#c93';
                    this._toplevel.style.border = '2px solid #c93';
                    this._toplevel.style.lineHeight = '2em';
                    this._toplevel.style.marginLeft = '1em';
                    this._toplevel.style.borderRadius = '6px';
                    this._toplevel.style.boxShadow = 'rgba(0, 0, 0, .4) 0px 4px 16px';
                    this._toplevel.style.zIndex = '9999';
                    this._segments = [];
                    for (var exp = 2; exp >= -2; exp--) {
                        var incr = Math.pow(10, exp);
                        var segment = this._document.createElement('div');
                        segment._incr = incr;
                        segment.style.padding = '.5em 1em';
                        segment.textContent = '' + incr;
                        this._toplevel.appendChild(segment);
                        this._segments.push(segment);
                    }
                    this._anchorMouseX = 0;
                    this._anchorValue = undefined;
                    this._value = undefined;
                    this._onMouseMove = this._onMouseMove.bind(this);
                    this._onMouseUp = this._onMouseUp.bind(this);
                }
                NumberDragger.prototype._onMouseMove = function (e) {
                    e.stopPropagation();
                    var accel = 15;
                    var dx = Math.round((e.clientX - this._anchorMouseX) / accel);
                    var newValue = this._anchorValue + (dx * this._currentIncr);
                    if (this._value !== newValue) {
                        this._value = newValue;
                        this.onvalue(this._value);
                    }
                    var y = e.clientY;
                    try {
                        for (var _a = __values(this._segments), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var segment = _b.value;
                            var bbox = segment.getBoundingClientRect();
                            if (y < bbox.bottom) {
                                if (this._selectSegment(segment)) {
                                    // Set new anchor.
                                    if (this._anchorValue !== this._value) {
                                        this._anchorMouseX = e.clientX;
                                        this._anchorValue = this._value;
                                    }
                                }
                                break;
                            }
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                    var e_5, _c;
                };
                NumberDragger.prototype._onMouseUp = function (e) {
                    this._cursorOverride.setCursor(this, '');
                    this._document.documentElement.removeEventListener('mouseup', this._onMouseUp);
                    this.onend();
                    if (this._showTimeout) {
                        clearTimeout(this._showTimeout);
                        this._showTimeout = 0;
                        return;
                    }
                    this._document.documentElement.removeEventListener('mousemove', this._onMouseMove, { capture: true });
                    this._document.body.removeChild(this._toplevel);
                };
                NumberDragger.prototype._selectSegment = function (segment) {
                    var incr = segment._incr;
                    if (this._currentIncr === incr)
                        return false;
                    this._currentIncr = incr;
                    try {
                        for (var _a = __values(this._segments), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var seg = _b.value;
                            var hilite = seg === segment;
                            seg.style.backgroundColor = hilite ? '#c93' : '';
                            seg.style.color = hilite ? '#222' : '';
                            seg.style.fontWeight = hilite ? 'bold' : '';
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                    return true;
                    var e_6, _c;
                };
                NumberDragger.prototype._show = function () {
                    this._showTimeout = 0;
                    this._document.body.appendChild(this._toplevel);
                    this._document.documentElement.addEventListener('mousemove', this._onMouseMove, { capture: true });
                };
                NumberDragger.prototype.setPosition = function (x, y) {
                    this._toplevel.style.left = x + 'px';
                    this._toplevel.style.top = y + 'px';
                };
                NumberDragger.prototype.show = function (value, e) {
                    this._anchorMouseX = e.clientX;
                    this._anchorValue = value;
                    // reset
                    this._selectSegment(this._segments[2]);
                    this._document.documentElement.addEventListener('mouseup', this._onMouseUp);
                    // Delay the show a tiny bit...
                    this._showTimeout = setTimeout(this._show.bind(this), 100);
                    this._cursorOverride.setCursor(this, 'e-resize');
                };
                return NumberDragger;
            }());
            ;
            ;
            ;
            CodeEditor = /** @class */ (function () {
                function CodeEditor(_document) {
                    this._document = _document;
                    this.onvaluechanged = null;
                    this._prefix = '';
                    this._suffix = '';
                    // Padding, in units of line height.
                    this._paddingTop = .2;
                    this._paddingBottom = 1.5;
                    this._toplevel = this._document.createElement('div');
                    this._toplevel.style.position = 'relative';
                    // We need to append this to the body to measure / get metrics... :(
                    // Setup is particularly wacky... maybe clean it up at some point?
                    this._document.body.appendChild(this._toplevel);
                    this._textarea = this._document.createElement('textarea');
                    this._textarea.style.fontFamily = MONOSPACE;
                    this._textarea.oninput = this._onInput.bind(this);
                    this._textarea.onkeydown = this._onKeyDown.bind(this);
                    this._toplevel.appendChild(this._textarea);
                    this._canvas = this._document.createElement('canvas');
                    this._toplevel.appendChild(this._canvas);
                    this._onMouseDown = this._onMouseDown.bind(this);
                    this._onMouseMove = this._onMouseMove.bind(this);
                    this._onMouseUp = this._onMouseUp.bind(this);
                    this._onMouseLeave = this._onMouseLeave.bind(this);
                    this._canvas.onmousedown = this._onMouseDown;
                    this._canvas.onmouseleave = this._onMouseLeave;
                    this._canvas.onmousemove = this._onMouseMove;
                    this._textarea.style.whiteSpace = 'pre-wrap';
                    this._textarea.style.wordBreak = 'break-all';
                    // Hide the textarea the canvas now that we've sized it...
                    this._textarea.style.position = 'absolute';
                    this._textarea.style.left = '-99999px';
                    this._canvas.style.position = 'absolute';
                    this._needsRecalculate = false;
                    this._valueChanged = false;
                    // Redraw-internal state.
                    this._redraw_cursorPosition = undefined;
                    this._redraw_cursorBlinkStart = undefined;
                    this._cursorOverride = new CursorOverride(this._document);
                    this._numberDragger = new NumberDragger(this._document, this._cursorOverride);
                    this._numberDragger.onvalue = this._onNumberDraggerValue.bind(this);
                    this._numberDragger.onend = this._onNumberDraggerEnd.bind(this);
                    this.elem = this._toplevel;
                    visibleRAF(this._canvas, this._redraw.bind(this));
                }
                CodeEditor.prototype._setNeedsRecalculate = function () {
                    this._needsRecalculate = true;
                };
                CodeEditor.prototype._setValueChanged = function () {
                    this._valueChanged = true;
                };
                // Sets a chunk of text at the beginning and end that the user cannot modify.
                CodeEditor.prototype.setPrefixSuffix = function (prefix, suffix) {
                    this._prefix = prefix;
                    this._suffix = suffix;
                    this._setNeedsRecalculate();
                };
                CodeEditor.prototype.setFontSize = function (size) {
                    this._textarea.style.fontSize = size;
                    this._setNeedsRecalculate();
                };
                CodeEditor.prototype.setLineFlairs = function (lineFlairs) {
                    this._lineFlairs = lineFlairs;
                };
                // Sets the size. The height here is actually a minimum height. Since we don't
                // yet have scrolling, the Editor always expands to fill however many lines it
                // takes up...
                CodeEditor.prototype.setSize = function (w, h) {
                    if (h !== undefined)
                        this._minHeight = h;
                    if (w !== undefined) {
                        this._width = w;
                        this._canvas.style.width = w + "px";
                        this._toplevel.style.width = w + "px";
                        // Calculate cols immediately.
                        this._cols = this._xyToRowCol(w, 0).col;
                        this._textarea.style.width = this._cols + "ch";
                    }
                    if (w !== undefined || h !== undefined)
                        this._setNeedsRecalculate();
                };
                CodeEditor.prototype.getValue = function () {
                    return this._textarea.value;
                };
                CodeEditor.prototype.setValue = function (t) {
                    this._textarea.value = t;
                    this._setValueChanged();
                    this._setNeedsRecalculate();
                };
                CodeEditor.prototype.getFullText = function () {
                    return this._prefix + this._textarea.value + this._suffix;
                };
                CodeEditor.prototype._isLineLocked = function (line) {
                    if (line.lineno < this._prefixLines)
                        return true;
                    if (line.lineno >= this._suffixLines)
                        return true;
                    return false;
                };
                CodeEditor.prototype._recalculate = function () {
                    if (!this._needsRecalculate)
                        return;
                    // If we aren't attached to a parent node, recalculating is futile...
                    if (!this._toplevel.parentNode)
                        return;
                    // Recalculate our line model.
                    var chars = this.getFullText() + '\n';
                    var lineModel = [];
                    var idx = 0, row = 0, lineno = 0;
                    while (true) {
                        var newIdx = chars.indexOf('\n', idx);
                        if (newIdx < 0)
                            break;
                        var start = idx, end = newIdx + 1;
                        var length_1 = end - start - 1;
                        var startRow = row;
                        var rows = Math.max(Math.ceil(length_1 / this._cols), 1);
                        lineModel.push({ start: start, end: end, length: length_1, rows: rows, startRow: startRow, lineno: lineno });
                        row += rows;
                        lineno++;
                        idx = end;
                    }
                    this._lineModel = lineModel;
                    this._prefixLines = this._prefix.split('\n').length - 1;
                    this._suffixLines = this._lineModel.length - (this._suffix.split('\n').length - 1);
                    // Compute syntax highlights.
                    var syntaxRuns = [];
                    var draggableNumbers = [];
                    var match;
                    // Colors taken from the railscasts color scheme.
                    var keywords = (/\b(function|for|while|if|else|break|continue|in|out|attribute|uniform|varying|return|struct|layout|precision|mediump|lowp|highp|discard)\b/g);
                    while ((match = keywords.exec(chars)) !== null)
                        syntaxRuns.push({ start: match.index, end: match.index + match[0].length, color: '#c26230' });
                    var types = (/\b(void|bool|float|[ui]?vec[234]|mat[234]|mat[234]x[234]|[u]?int|sampler[23]D)\b/g);
                    while ((match = types.exec(chars)) !== null)
                        syntaxRuns.push({ start: match.index, end: match.index + match[0].length, color: '#6d9cbe' });
                    var numbers = (/\W-?\d+(\.\d+)?\b/g); // Don't bother supporting scientific notation on numbers...
                    while ((match = numbers.exec(chars)) !== null) {
                        syntaxRuns.push({ start: match.index + 1, end: match.index + match[0].length, color: '#a5c261' });
                        draggableNumbers.push({ start: match.index + 1, end: match.index + match[0].length });
                    }
                    var strings = (/("[^"]*")|('[^']*')/g);
                    while ((match = strings.exec(chars)) !== null)
                        syntaxRuns.push({ start: match.index, end: match.index + match[0].length, color: '#6d9cbe' });
                    var comments = (/\/\/.*$/gm);
                    while ((match = comments.exec(chars)) !== null)
                        syntaxRuns.push({ start: match.index, end: match.index + match[0].length, color: '#bc9458', style: 'italic' });
                    syntaxRuns.sort(function (a, b) { return a.start - b.start; });
                    this._syntaxRuns = syntaxRuns;
                    this._draggableNumbers = draggableNumbers;
                    var textareaStyle = this._document.defaultView.getComputedStyle(this._textarea);
                    this._textareaStyle = textareaStyle;
                    var ctx = this._canvas.getContext('2d');
                    ctx.font = textareaStyle.fontSize + " " + textareaStyle.fontFamily;
                    // We're using a monospace font. It should have identical metrics for all characters,
                    // so just measuring one should be fine...
                    this._charWidth = ctx.measureText(' ').width;
                    var rowHeight = textareaStyle.lineHeight;
                    var rowHeightN;
                    // XXX: This seems to be a Chrome default for the line-height? Not sure how else I can
                    // calculate this guy... grr...
                    if (rowHeight === 'normal')
                        rowHeightN = 1.3 * parseFloat(textareaStyle.fontSize);
                    else
                        rowHeightN = parseFloat(rowHeight);
                    this._rowHeight = Math.ceil(rowHeightN);
                    if (this._charMarginTop === undefined) {
                        var stdMargin = 4;
                        this._charMarginTop = stdMargin - expensiveMeasureTextMargin(this._document, this._charWidth, this._rowHeight, ctx.font);
                    }
                    // Recalculate geometry.
                    var numLines = this._lineModel.length;
                    var gutterChars = ('' + numLines).length;
                    this._gutterMargin = 10;
                    this._gutterWidth = this._charWidth * Math.max(gutterChars, 2) + this._gutterMargin * 2;
                    this._textMargin = 10;
                    var lastRow = this._lineModel[this._lineModel.length - 1];
                    var numRows = lastRow.startRow + lastRow.rows - 1;
                    var newHeight = Math.ceil(Math.max(this._minHeight, this._rowHeight * (numRows + this._paddingTop + this._paddingBottom)));
                    if (newHeight !== this._height) {
                        this._height = newHeight;
                        this._canvas.style.height = this._height + "px";
                        this._toplevel.style.height = this._height + "px";
                        // Resize the textarea so the window doesn't scroll back in when we click on it...
                        this._textarea.style.height = (this._height - this._rowHeight) + 'px';
                    }
                    this._needsRecalculate = false;
                    this._recalculateMouseIdx();
                    if (this._valueChanged && this.onvaluechanged)
                        this.onvaluechanged();
                    this._valueChanged = false;
                };
                CodeEditor.prototype._recalculateMouseIdx = function () {
                    if (this._mouseX === undefined || this._mouseY === undefined) {
                        this._mouseIdx = undefined;
                    }
                    else {
                        var _a = this._xyToRowCol(this._mouseX, this._mouseY), row = _a.row, col = _a.col;
                        var _b = this._rowColToLineIdx(row, col, false), line = _b.line, idx = _b.idx;
                        var isLineLocked = this._isLineLocked(line);
                        this._mouseIdx = isLineLocked ? undefined : idx;
                    }
                };
                CodeEditor.prototype._calculateIndentedLineStart = function (line) {
                    var chars = this.getFullText();
                    var idx = line.start;
                    while (chars.charAt(idx) === ' ' && idx <= line.end)
                        idx++;
                    return idx;
                };
                CodeEditor.prototype._onInput = function () {
                    this._setValueChanged();
                    this._setNeedsRecalculate();
                };
                CodeEditor.prototype._onKeyDown = function (e) {
                    if (e.key === 'Tab' && !e.shiftKey) {
                        // XXX: If we have a selection, then indent the selection.
                        if (!this._hasSelection()) {
                            this._insertAtCursor('    ');
                        }
                        e.preventDefault();
                    }
                    else if (e.key === 'Tab' && e.shiftKey) {
                        // XXX: If we have a selection, then unindent the selection.
                        e.preventDefault();
                    }
                    else if (e.key === 'Home') {
                        // Move to the start of indentation.
                        var cursorIdx = this._getCursorIdx();
                        var _a = this._getCharPos(cursorIdx), line = _a.line, lineIdx = _a.lineIdx;
                        var indentedIdx = this._calculateIndentedLineStart(line);
                        if (cursorIdx !== indentedIdx) {
                            if (e.shiftKey) {
                                var _b = __read(this._getSelection(), 1), selectionPoint = _b[0];
                                this._setSelection(this._idxToTextarea(selectionPoint), this._idxToTextarea(indentedIdx));
                            }
                            else {
                                this._setCursor(this._idxToTextarea(indentedIdx));
                            }
                            e.preventDefault();
                        }
                    }
                };
                CodeEditor.prototype._onMouseDown = function (e) {
                    e.preventDefault();
                    var _a = this._xyToRowCol(e.offsetX, e.offsetY), row = _a.row, col = _a.col;
                    var line = this._rowColToLineIdx(row, 0, true).line;
                    if (this._isLineLocked(line)) {
                        this._textarea.blur();
                    }
                    else if (col === -1) {
                        this._setSelection(this._idxToTextarea(line.start), this._idxToTextarea(line.end));
                        this._textarea.focus();
                    }
                    else {
                        var idx = this._rowColToLineIdx(row, col, true).idx;
                        this._textarea.focus();
                        this._dragStartX = e.clientX;
                        this._dragStartY = e.clientY;
                        var exactIdx = this._rowColToLineIdx(row, col, false).idx;
                        var draggableNumber = this._findDraggableNumber(exactIdx);
                        if (!e.shiftKey && draggableNumber) {
                            var start = this._idxToTextarea(draggableNumber.start);
                            var end = this._idxToTextarea(draggableNumber.end);
                            var value = +this.getValue().slice(start, end);
                            this._draggingNumber = { start: start, end: end, value: value };
                            this._syncNumberDraggerPosition();
                            this._setCursor(this._idxToTextarea(idx));
                            this._numberDragger.show(value, e);
                        }
                        else {
                            if (e.shiftKey) {
                                // If we don't have a selection, start a new one where the cursor is...
                                // If we have an existing selection, just keep the current dragStartIdx,
                                // since it's still valid.
                                if (!this._hasSelection())
                                    this._dragStartIdx = this._textarea.selectionStart;
                                this._setSelection(this._dragStartIdx, this._idxToTextarea(idx));
                            }
                            else {
                                this._dragStartIdx = this._idxToTextarea(idx);
                                this._setCursor(this._dragStartIdx);
                            }
                            this._dragging = 'selection';
                            this._document.documentElement.addEventListener('mousemove', this._onMouseMove, { capture: true });
                            this._document.documentElement.addEventListener('mouseup', this._onMouseUp);
                        }
                    }
                };
                CodeEditor.prototype._onMouseUp = function (e) {
                    this._dragging = undefined;
                    this._document.documentElement.removeEventListener('mousemove', this._onMouseMove, { capture: true });
                    this._document.documentElement.removeEventListener('mouseup', this._onMouseUp);
                };
                CodeEditor.prototype._onMouseMove = function (e) {
                    e.stopPropagation();
                    this._mouseX = e.offsetX;
                    this._mouseY = e.offsetY;
                    this._recalculateMouseIdx();
                    var _a = this._xyToRowCol(this._mouseX, this._mouseY), row = _a.row, col = _a.col;
                    var _b = this._rowColToLineIdx(row, col, true), line = _b.line, idx = _b.idx;
                    if (this._dragging === 'selection') {
                        this._setSelection(this._dragStartIdx, this._idxToTextarea(idx));
                        this._textarea.focus();
                    }
                    var _c = this._rowColToLineIdx(row, col, false), exactLine = _c.line, exactIdx = _c.idx;
                    var isLineLocked = this._isLineLocked(line);
                    // Dragging takes priority.
                    var cursor;
                    if (this._dragging === 'selection') {
                        cursor = 'text';
                    }
                    else if (col === -1 || isLineLocked) {
                        cursor = 'default';
                    }
                    else if (!e.shiftKey && this._findDraggableNumber(exactIdx)) {
                        cursor = 'e-resize';
                    }
                    else {
                        cursor = 'text';
                    }
                    this._canvas.style.cursor = cursor;
                    if (this._dragging)
                        this._cursorOverride.setCursor(this, cursor);
                    else
                        this._cursorOverride.setCursor(this, '');
                };
                CodeEditor.prototype._onMouseLeave = function (e) {
                    this._mouseX = undefined;
                    this._mouseY = undefined;
                    this._mouseIdx = undefined;
                };
                CodeEditor.prototype._onNumberDraggerValue = function (newValue) {
                    this._textarea.blur();
                    var _a = this._draggingNumber, start = _a.start, end = _a.end;
                    var newValueString = formatDecimal(newValue);
                    this.setValue(this._spliceValue(start, end, newValueString));
                    this._draggingNumber.end = this._draggingNumber.start + newValueString.length;
                    this._syncNumberDraggerPosition();
                };
                CodeEditor.prototype._onNumberDraggerEnd = function () {
                    this._draggingNumber = null;
                };
                CodeEditor.prototype._syncNumberDraggerPosition = function () {
                    var _a = this._draggingNumber, start = _a.start, end = _a.end;
                    var endPos = this._getCharPos(this._textareaToIdx(end));
                    var _b = this._rowColToXY(endPos.row, endPos.col), x = _b.x, y = _b.y;
                    var bbox = this._toplevel.getBoundingClientRect();
                    var absX = bbox.left + x;
                    var absY = bbox.top + y + this._rowHeight / 2 + this._document.defaultView.scrollY;
                    this._numberDragger.setPosition(absX, absY);
                };
                CodeEditor.prototype._spliceValue = function (start, end, v) {
                    var chars = this.getValue();
                    return chars.slice(0, start) + v + chars.slice(end);
                };
                CodeEditor.prototype._findDraggableNumber = function (idx) {
                    this._recalculate();
                    return this._draggableNumbers.find(function (_a) {
                        var start = _a.start, end = _a.end;
                        return idx >= start && idx <= end;
                    });
                };
                CodeEditor.prototype._idxToTextarea = function (idx) {
                    return idx - this._prefix.length;
                };
                CodeEditor.prototype._textareaToIdx = function (idx) {
                    return idx + this._prefix.length;
                };
                CodeEditor.prototype._rowColToLineIdx = function (row, col, clampIdx) {
                    this._recalculate();
                    var line;
                    try {
                        for (var _a = __values(this._lineModel), _b = _a.next(); !_b.done; _b = _a.next()) {
                            line = _b.value;
                            if (row >= line.startRow && row < line.startRow + line.rows)
                                break;
                        }
                    }
                    catch (e_7_1) { e_7 = { error: e_7_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_7) throw e_7.error; }
                    }
                    var lineIdx;
                    // Fast path.
                    if (line.rows === 1) {
                        lineIdx = col;
                    }
                    else {
                        lineIdx = (row - line.startRow) * this._cols + col;
                    }
                    var idx;
                    if (clampIdx)
                        idx = line.start + Math.min(Math.max(lineIdx, 0), line.length);
                    else if (lineIdx > line.length)
                        idx = -1;
                    else
                        idx = line.start + lineIdx;
                    return { line: line, idx: idx };
                    var e_7, _c;
                };
                CodeEditor.prototype._xyToRowCol = function (x, y) {
                    this._recalculate();
                    y -= this._paddingTop * this._rowHeight;
                    var row = Math.floor(y / this._rowHeight);
                    var col;
                    if (x < this._gutterWidth)
                        col = -1;
                    x -= this._gutterWidth;
                    if (col === undefined && x < this._textMargin)
                        col = 0;
                    x -= this._textMargin;
                    if (col === undefined)
                        col = Math.round(x / this._charWidth);
                    return { row: row, col: col };
                };
                CodeEditor.prototype._rowColToXY = function (row, col) {
                    var x = this._gutterWidth + this._textMargin + col * this._charWidth;
                    var y = (this._paddingTop + row) * this._rowHeight;
                    return { x: x, y: y };
                };
                CodeEditor.prototype._getRowLength = function (row) {
                    this._recalculate();
                    var line;
                    try {
                        for (var _a = __values(this._lineModel), _b = _a.next(); !_b.done; _b = _a.next()) {
                            line = _b.value;
                            if (row >= line.startRow && row < line.startRow + line.rows)
                                break;
                        }
                    }
                    catch (e_8_1) { e_8 = { error: e_8_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_8) throw e_8.error; }
                    }
                    // Fast path.
                    if (line.rows === 1)
                        return line.length;
                    if (row === line.startRow + line.rows - 1)
                        return line.length % this._cols;
                    else
                        return this._cols;
                    var e_8, _c;
                };
                CodeEditor.prototype._getCharPos = function (idx) {
                    this._recalculate();
                    var line;
                    try {
                        for (var _a = __values(this._lineModel), _b = _a.next(); !_b.done; _b = _a.next()) {
                            line = _b.value;
                            if (idx >= line.start && idx < line.end)
                                break;
                        }
                    }
                    catch (e_9_1) { e_9 = { error: e_9_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_9) throw e_9.error; }
                    }
                    var lineIdx = idx - line.start;
                    // Fast path.
                    if (line.rows === 1)
                        return { line: line, lineIdx: lineIdx, row: line.startRow, col: lineIdx };
                    // Slow path.
                    var col = lineIdx % this._cols;
                    var row = line.startRow + Math.min((lineIdx / this._cols) | 0, line.rows);
                    return { line: line, lineIdx: lineIdx, row: row, col: col };
                    var e_9, _c;
                };
                CodeEditor.prototype._hasSelection = function () {
                    return this._textarea.selectionStart !== this._textarea.selectionEnd;
                };
                CodeEditor.prototype._getSelection = function () {
                    var selStartIdx = this._textareaToIdx(this._textarea.selectionStart);
                    var selEndIdx = this._textareaToIdx(this._textarea.selectionEnd);
                    // [selectionStart, cursor]
                    if (this._textarea.selectionDirection === 'forward')
                        return [selStartIdx, selEndIdx];
                    else
                        return [selEndIdx, selStartIdx];
                };
                CodeEditor.prototype._getCursorIdx = function () {
                    var _a = __read(this._getSelection(), 2), selectionPointIdx = _a[0], cursorIdx = _a[1];
                    return cursorIdx;
                };
                CodeEditor.prototype._setSelection = function (a, b) {
                    // The selection starts at "a" and ends with the cursor position being at "b".
                    var start = Math.min(a, b), end = Math.max(a, b);
                    var direction = a < b ? 'forward' : 'backward';
                    this._textarea.setSelectionRange(start, end, direction);
                };
                CodeEditor.prototype._setCursor = function (a) {
                    this._textarea.setSelectionRange(a, a);
                };
                CodeEditor.prototype._insertAtCursor = function (s) {
                    this._textarea.focus();
                    if (!this._document.execCommand('insertText', false, s)) {
                        // execCommand failed. Fall back to setting value manually. This happens in Firefox:
                        // https://github.com/w3c/editing/issues/160
                        // https://bugzilla.mozilla.org/show_bug.cgi?id=1220696
                        // On modern Firefox versions, it will also wipe the undo buffer unfortunately.
                        // The """web platform"" is a piece of trash and I don't like it.
                        var value = this._textarea.value;
                        var selStart = this._textarea.selectionStart;
                        var selEnd = this._textarea.selectionEnd;
                        this._textarea.value = value.slice(0, selStart) + s + value.slice(selEnd);
                        this._textarea.focus();
                    }
                    this._setValueChanged();
                    this._setNeedsRecalculate();
                };
                CodeEditor.prototype._redraw = function (t) {
                    var _this = this;
                    var hasFocus = this._textarea.matches(':focus');
                    // Skip redrawing if we're up to date to cut down on costs...
                    if (!this._needsRecalculate && !hasFocus)
                        return;
                    this._recalculate();
                    var canvasRect = this._canvas.getBoundingClientRect();
                    var ratio = this._document.defaultView.devicePixelRatio;
                    var canvasWidth = this._width * ratio;
                    var canvasHeight = this._height * ratio;
                    var sizeChanged = false;
                    if (this._canvas.width !== canvasWidth || this._canvas.height !== canvasHeight) {
                        this._canvas.width = canvasWidth;
                        this._canvas.height = canvasHeight;
                        sizeChanged = true;
                    }
                    // Clip to viewport.
                    var scissorX1 = Math.max(0, canvasRect.left);
                    var scissorY1 = Math.max(0, canvasRect.top);
                    var viewportWidth = this._document.defaultView.innerWidth;
                    var viewportHeight = this._document.defaultView.innerHeight;
                    var scissorX2 = Math.min(viewportWidth, canvasRect.right);
                    var scissorY2 = Math.min(viewportHeight, canvasRect.bottom);
                    // Put in canvas space.
                    var clipRectX = scissorX1 - canvasRect.left;
                    var clipRectY = scissorY1 - canvasRect.top;
                    var clipRectW = scissorX2 - scissorX1;
                    var clipRectH = scissorY2 - scissorY1;
                    var ctx = this._canvas.getContext('2d');
                    ctx.save();
                    if (!sizeChanged) {
                        ctx.rect(clipRectX, clipRectY, clipRectW, clipRectH);
                        ctx.clip();
                    }
                    ctx.scale(ratio, ratio);
                    var bgcolor = '#232323';
                    ctx.fillStyle = bgcolor;
                    ctx.fillRect(0, 0, this._width, this._height);
                    if (hasFocus) {
                        // Has a cursor.
                        var cursorPosition = this._idxToTextarea(this._getCursorIdx());
                        if (this._redraw_cursorPosition !== cursorPosition) {
                            this._redraw_cursorPosition = cursorPosition;
                            // Set it blinking again.
                            this._redraw_cursorBlinkStart = t;
                        }
                    }
                    else {
                        this._redraw_cursorPosition = undefined;
                    }
                    var textareaStyleFontSize = this._textareaStyle.fontSize;
                    var textareaStyleFontFamily = this._textareaStyle.fontFamily;
                    ctx.font = textareaStyleFontSize + " " + textareaStyleFontFamily;
                    var drawFlair = function (line, flair) {
                        var y = (_this._paddingTop + line.startRow) * _this._rowHeight;
                        var height = line.rows * _this._rowHeight;
                        ctx.fillStyle = flair.color;
                        ctx.fillRect(0, y, _this._canvas.width, _this._rowHeight);
                    };
                    if (this._redraw_cursorPosition) {
                        var line = this._getCharPos(this._textareaToIdx(this._redraw_cursorPosition)).line;
                        drawFlair(line, { color: '#2f2a34', lineno: -1 });
                    }
                    if (this._lineFlairs) {
                        try {
                            for (var _a = __values(this._lineFlairs), _b = _a.next(); !_b.done; _b = _a.next()) {
                                var flair = _b.value;
                                var line = this._lineModel[flair.lineno];
                                if (!line)
                                    continue;
                                drawFlair(line, flair);
                            }
                        }
                        catch (e_10_1) { e_10 = { error: e_10_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                            }
                            finally { if (e_10) throw e_10.error; }
                        }
                    }
                    // Gutter
                    ctx.save();
                    ctx.fillStyle = '#445';
                    ctx.fillRect(0, 0, this._gutterWidth, this._canvas.height);
                    ctx.restore();
                    // Gutter text.
                    for (var i = 0; i < this._lineModel.length; i++) {
                        var line = this._lineModel[i];
                        var no = line.lineno + 1;
                        var y = (this._paddingTop + line.startRow) * this._rowHeight;
                        ctx.fillStyle = this._isLineLocked(line) ? '#888' : '#ccc';
                        ctx.textBaseline = 'top';
                        ctx.textAlign = 'right';
                        var noString = '' + no;
                        ctx.fillText(noString, this._gutterWidth - this._gutterMargin, this._charMarginTop + y);
                    }
                    // Add a newline at the end to make paint logic simpler.
                    var chars = this.getFullText() + '\n';
                    ctx.save();
                    ctx.translate(this._gutterWidth + this._textMargin, 0);
                    if (this._hasSelection()) {
                        // Draw selection bounds.
                        var inSelection = false;
                        var startPos = this._getCharPos(this._textareaToIdx(this._textarea.selectionStart));
                        var endPos = this._getCharPos(this._textareaToIdx(this._textarea.selectionEnd));
                        for (var row = startPos.row; row <= endPos.row; row++) {
                            var colStart = (row === startPos.row) ? startPos.col : 0;
                            var colEnd = (row === endPos.row) ? endPos.col : this._getRowLength(row);
                            var selectionColor = hasFocus ? '#336' : '#333';
                            var startX = colStart * this._charWidth;
                            var endX = colEnd * this._charWidth;
                            var y = (this._paddingTop + row) * this._rowHeight;
                            ctx.fillStyle = selectionColor;
                            ctx.fillRect(startX, y, endX - startX, this._rowHeight);
                        }
                    }
                    var syntaxRuns = this._syntaxRuns;
                    var currentSyntaxRun = 0;
                    // Anything interesting under the mouse?
                    var draggableNumber;
                    if (this._draggingNumber) {
                        var _d = this._draggingNumber, start = _d.start, end = _d.end;
                        draggableNumber = { start: this._textareaToIdx(start), end: this._textareaToIdx(end) };
                    }
                    else if (!this._dragging && this._mouseIdx > -1) {
                        draggableNumber = this._findDraggableNumber(this._mouseIdx);
                    }
                    // Setting the font on a CanvasRenderingContext2D in Firefox is expensive, so try
                    // to set it as little as possible by only setting it when it changes.
                    var currentFont;
                    // Now for the actual paint.
                    for (var m = 0; m < this._lineModel.length; m++) {
                        var line = this._lineModel[m];
                        var row = line.startRow, col = 0;
                        for (var i = line.start; i < line.end; i++) {
                            if (col === this._cols && (row - line.startRow) < line.rows - 1) {
                                row++;
                                col = 0;
                            }
                            // XXX: Use something else other than charAt for Unicode compliance.
                            var char = chars.charAt(i);
                            var x = col * this._charWidth, y = (this._paddingTop + row) * this._rowHeight;
                            if (i === this._textareaToIdx(this._redraw_cursorPosition)) {
                                // Draw cursor.
                                ctx.save();
                                ctx.fillStyle = '#fff';
                                var blinkAnimationT = (t - this._redraw_cursorBlinkStart) / 1000;
                                var blinkAlpha = (Math.sin(blinkAnimationT * 6) + 1);
                                ctx.globalAlpha = blinkAlpha;
                                ctx.fillRect(Math.floor(x), y, 2, this._rowHeight);
                                ctx.restore();
                            }
                            if (char === '\n')
                                break;
                            if (draggableNumber !== undefined && i >= draggableNumber.start && i < draggableNumber.end) {
                                ctx.save();
                                ctx.beginPath();
                                ctx.moveTo(x | 0, y + this._rowHeight);
                                ctx.lineTo((x + this._charWidth) | 0, y + this._rowHeight);
                                ctx.setLineDash([1, 1]);
                                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                                ctx.restore();
                            }
                            var color = '#e6e1dc';
                            var style = '';
                            while (currentSyntaxRun < syntaxRuns.length && i >= syntaxRuns[currentSyntaxRun].end)
                                currentSyntaxRun++;
                            if (currentSyntaxRun < syntaxRuns.length) {
                                var run = syntaxRuns[currentSyntaxRun];
                                if (i >= run.start && i < run.end) {
                                    if (run.color)
                                        color = run.color;
                                    if (run.style)
                                        style = run.style;
                                }
                            }
                            if (this._isLineLocked(line)) {
                                color = colorLerp(color, colorGrayscale(color), 0.75);
                            }
                            ctx.textBaseline = 'top';
                            ctx.textAlign = 'left';
                            ctx.fillStyle = color;
                            var newFont = style + " " + textareaStyleFontSize + " " + textareaStyleFontFamily;
                            if (currentFont !== newFont) {
                                ctx.font = newFont;
                                currentFont = newFont;
                            }
                            ctx.fillText(char, x, y + this._charMarginTop);
                            col++;
                        }
                    }
                    ctx.restore();
                    ctx.restore();
                    var e_10, _c;
                };
                return CodeEditor;
            }());
            exports_8("default", CodeEditor);
        }
    };
});
// Color utilities
System.register("Color", [], function (exports_9, context_9) {
    "use strict";
    var __moduleName = context_9 && context_9.id;
    function lerp(a, b, t) {
        return a + (b - a) * t;
    }
    function colorLerp(dst, k0, k1, t) {
        dst.r = lerp(k0.r, k1.r, t);
        dst.g = lerp(k0.g, k1.g, t);
        dst.b = lerp(k0.b, k1.b, t);
        dst.a = lerp(k0.a, k1.a, t);
    }
    exports_9("colorLerp", colorLerp);
    function colorCopy(dst, src, a) {
        if (a === void 0) { a = src.a; }
        dst.r = src.r;
        dst.g = src.g;
        dst.b = src.b;
        dst.a = a;
    }
    exports_9("colorCopy", colorCopy);
    function colorFromRGBA8(dst, n) {
        dst.r = ((n >>> 24) & 0xFF) / 0xFF;
        dst.g = ((n >>> 16) & 0xFF) / 0xFF;
        dst.b = ((n >>> 8) & 0xFF) / 0xFF;
        dst.a = ((n >>> 0) & 0xFF) / 0xFF;
    }
    exports_9("colorFromRGBA8", colorFromRGBA8);
    function colorFromARGB8(dst, n) {
        dst.a = ((n >>> 24) & 0xFF) / 0xFF;
        dst.r = ((n >>> 16) & 0xFF) / 0xFF;
        dst.g = ((n >>> 8) & 0xFF) / 0xFF;
        dst.b = ((n >>> 0) & 0xFF) / 0xFF;
    }
    exports_9("colorFromARGB8", colorFromARGB8);
    function colorToRGBA8(src) {
        return ((src.r * 0xFF) << 24 |
            (src.g * 0xFF) << 16 |
            (src.b * 0xFF) << 8 |
            (src.a * 0xFF) << 0);
    }
    exports_9("colorToRGBA8", colorToRGBA8);
    function colorToARGB8(src) {
        return ((src.a * 0xFF) << 24 |
            (src.r * 0xFF) << 16 |
            (src.g * 0xFF) << 8 |
            (src.b * 0xFF) << 0);
    }
    exports_9("colorToARGB8", colorToARGB8);
    function colorToCSS(src) {
        return "rgba(" + src.r * 255 + ", " + src.g * 255 + ", " + src.b * 255 + ", " + src.a + ")";
    }
    exports_9("colorToCSS", colorToCSS);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("MemoizeCache", ["util"], function (exports_10, context_10) {
    "use strict";
    var __moduleName = context_10 && context_10.id;
    var util_4, MemoizeCache;
    return {
        setters: [
            function (util_4_1) {
                util_4 = util_4_1;
            }
        ],
        execute: function () {
            MemoizeCache = /** @class */ (function () {
                function MemoizeCache() {
                    this.cache = new Map();
                }
                MemoizeCache.prototype.get = function (key) {
                    var keyStr = this.makeKey(key);
                    if (this.cache.has(keyStr)) {
                        return util_4.assertExists(this.cache.get(keyStr));
                    }
                    else {
                        var obj = this.make(key);
                        if (obj !== null)
                            this.cache.set(keyStr, obj);
                        return obj;
                    }
                };
                MemoizeCache.prototype.clear = function () {
                    this.cache.clear();
                };
                return MemoizeCache;
            }());
            exports_10("default", MemoizeCache);
        }
    };
});
System.register("Program", ["MemoizeCache", "CodeEditor", "util"], function (exports_11, context_11) {
    "use strict";
    var __moduleName = context_11 && context_11.id;
    function leftPad(n, v, num) {
        var s = '' + n;
        while (s.length < num)
            s = v + s;
        return s;
    }
    function prependLineNo(str, lineStart) {
        if (lineStart === void 0) { lineStart = 1; }
        var lines = str.split('\n');
        return lines.map(function (s, i) { return leftPad(lineStart + i, ' ', 4) + "  " + s; }).join('\n');
    }
    function compileShader(gl, str, type) {
        var shader = util_5.assertExists(gl.createShader(type));
        gl.shaderSource(shader, str);
        gl.compileShader(shader);
        if (DEBUG && !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(prependLineNo(str));
            var debug_shaders = gl.getExtension('WEBGL_debug_shaders');
            if (debug_shaders)
                console.error(debug_shaders.getTranslatedShaderSource(shader));
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    var MemoizeCache_1, CodeEditor_1, util_5, DEBUG, BaseProgram, Program, FullscreenProgram, ProgramCache;
    return {
        setters: [
            function (MemoizeCache_1_1) {
                MemoizeCache_1 = MemoizeCache_1_1;
            },
            function (CodeEditor_1_1) {
                CodeEditor_1 = CodeEditor_1_1;
            },
            function (util_5_1) {
                util_5 = util_5_1;
            }
        ],
        execute: function () {
            DEBUG = true;
            BaseProgram = /** @class */ (function () {
                function BaseProgram() {
                    this.name = '(unnamed)';
                    // Add some extra fields so that the monstrosity of frag/vert doesn't show up in Firefox's debugger.
                    this._pad0 = false;
                    this._pad1 = false;
                    this.vert = '';
                    this.frag = '';
                    this.forceRecompile = false;
                }
                BaseProgram.prototype.compile = function (gl, programCache) {
                    if (!this.glProg || this.forceRecompile) {
                        this.forceRecompile = false;
                        var vert = this.preprocessShader(gl, this.vert, "vert");
                        var frag = this.preprocessShader(gl, this.frag, "frag");
                        var newProg = programCache.compileProgram(vert, frag);
                        if (newProg !== null) {
                            this.glProg = newProg;
                            this.bind(gl, this.glProg);
                        }
                    }
                    if (!this.glProg) {
                        throw new Error();
                    }
                    return this.glProg;
                };
                BaseProgram.prototype.preprocessShader = function (gl, source, type) {
                    // Garbage WebGL2 shader compiler until I get something better down the line...
                    var lines = source.split('\n').map(function (n) {
                        // Remove comments.
                        return n.replace(/[/][/].*$/, '');
                    }).filter(function (n) {
                        // Filter whitespace.
                        var isEmpty = !n || /^\s+$/.test(n);
                        return !isEmpty;
                    });
                    var precision = lines.find(function (line) { return line.startsWith('precision'); }) || 'precision mediump float;';
                    var extensionLines = lines.filter(function (line) { return line.startsWith('#extension'); });
                    var extensions = extensionLines.filter(function (line) {
                        return line.indexOf('GL_EXT_frag_depth') === -1 ||
                            line.indexOf('GL_OES_standard_derivatives') === -1;
                    }).join('\n');
                    var rest = lines.filter(function (line) { return !line.startsWith('precision') && !line.startsWith('#extension'); }).join('\n');
                    var extensionDefines = util_5.assertExists(gl.getSupportedExtensions()).map(function (s) {
                        return "#define HAS_" + s;
                    }).join('\n');
                    return ("\n#version 300 es\n#define attribute in\n#define varying " + (type === 'vert' ? 'out' : 'in') + "\n" + extensionDefines + "\n#define gl_FragColor o_color\n#define texture2D texture\n" + extensions + "\n" + precision + "\nout vec4 o_color;\n" + rest + "\n").trim();
                };
                BaseProgram.prototype.destroy = function (gl) {
                    // TODO(jstpierre): Refcounting in the program cache?
                };
                BaseProgram.prototype._editShader = function (n) {
                    var _this = this;
                    var win = util_5.assertExists(window.open('about:blank', undefined, "location=off, resizable, alwaysRaised, left=20, top=20, width=1200, height=900"));
                    var init = function () {
                        var editor = new CodeEditor_1.default(win.document);
                        var document = win.document;
                        var title = n === 'vert' ? _this.name + " - Vertex Shader" : _this.name + " - Fragment Shader";
                        document.title = title;
                        document.body.style.margin = '0';
                        var shader = _this[n];
                        editor.setValue(shader);
                        editor.setFontSize('16px');
                        var timeout = 0;
                        editor.onvaluechanged = function () {
                            if (timeout > 0)
                                clearTimeout(timeout);
                            timeout = setTimeout(tryCompile, 500);
                        };
                        var onresize = win.onresize = function () {
                            editor.setSize(document.body.offsetWidth, window.innerHeight);
                        };
                        onresize();
                        var tryCompile = function () {
                            timeout = 0;
                            _this[n] = editor.getValue();
                            _this.forceRecompile = true;
                        };
                        win.editor = editor;
                        win.document.body.appendChild(editor.elem);
                    };
                    if (win.document.readyState === 'complete')
                        init();
                    else
                        win.onload = init;
                };
                BaseProgram.prototype.editv = function () {
                    this._editShader('vert');
                };
                BaseProgram.prototype.editf = function () {
                    this._editShader('frag');
                };
                return BaseProgram;
            }());
            exports_11("BaseProgram", BaseProgram);
            // TODO(jstpierre): Remove.
            Program = /** @class */ (function (_super) {
                __extends(Program, _super);
                function Program() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.projectionLocation = null;
                    _this.modelViewLocation = null;
                    return _this;
                }
                Program.prototype.bind = function (gl, prog) {
                    this.modelViewLocation = util_5.assertExists(gl.getUniformLocation(prog, "u_modelView"));
                    this.projectionLocation = util_5.assertExists(gl.getUniformLocation(prog, "u_projection"));
                };
                return Program;
            }(BaseProgram));
            exports_11("default", Program);
            FullscreenProgram = /** @class */ (function (_super) {
                __extends(FullscreenProgram, _super);
                function FullscreenProgram() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.vert = "\nout vec2 v_TexCoord;\n\nvoid main() {\n    v_TexCoord.x = (gl_VertexID == 1) ? 2.0 : 0.0;\n    v_TexCoord.y = (gl_VertexID == 2) ? 2.0 : 0.0;\n    gl_Position.xy = v_TexCoord * vec2(2) - vec2(1);\n    gl_Position.zw = vec2(1);\n}\n";
                    return _this;
                }
                FullscreenProgram.prototype.bind = function (gl, prog) {
                    // Nothing to do.
                };
                return FullscreenProgram;
            }(BaseProgram));
            exports_11("FullscreenProgram", FullscreenProgram);
            ProgramCache = /** @class */ (function (_super) {
                __extends(ProgramCache, _super);
                function ProgramCache(gl) {
                    var _this = _super.call(this) || this;
                    _this.gl = gl;
                    return _this;
                }
                ProgramCache.prototype.make = function (key) {
                    var gl = this.gl;
                    var vertShader = compileShader(gl, key.vert, gl.VERTEX_SHADER);
                    var fragShader = compileShader(gl, key.frag, gl.FRAGMENT_SHADER);
                    if (!vertShader || !fragShader)
                        return null;
                    var prog = gl.createProgram();
                    gl.attachShader(prog, vertShader);
                    gl.attachShader(prog, fragShader);
                    gl.linkProgram(prog);
                    gl.deleteShader(vertShader);
                    gl.deleteShader(fragShader);
                    if (DEBUG && !gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                        console.error(key.vert);
                        console.error(key.frag);
                        console.error(gl.getProgramInfoLog(prog));
                        gl.deleteProgram(prog);
                        return null;
                    }
                    return prog;
                };
                ProgramCache.prototype.destroy = function (obj) {
                    var gl = this.gl;
                    gl.deleteProgram(obj);
                };
                ProgramCache.prototype.makeKey = function (key) {
                    return key.vert + "$" + key.frag;
                };
                ProgramCache.prototype.compileProgram = function (vert, frag) {
                    return this.get({ vert: vert, frag: frag });
                };
                return ProgramCache;
            }(MemoizeCache_1.default));
            exports_11("ProgramCache", ProgramCache);
        }
    };
});
System.register("RenderArena", [], function (exports_12, context_12) {
    "use strict";
    var __moduleName = context_12 && context_12.id;
    function pushAndReturn(a, v) {
        a.push(v);
        return v;
    }
    var RenderArena;
    return {
        setters: [],
        execute: function () {
            // Optional helper providing a lazy attempt at arena-style garbage collection.
            RenderArena = /** @class */ (function () {
                function RenderArena() {
                    this.textures = [];
                    this.samplers = [];
                    this.buffers = [];
                    this.vaos = [];
                    this.programs = [];
                }
                RenderArena.prototype.createTexture = function (gl) {
                    return pushAndReturn(this.textures, gl.createTexture());
                };
                RenderArena.prototype.createSampler = function (gl) {
                    return pushAndReturn(this.samplers, gl.createSampler());
                };
                RenderArena.prototype.createBuffer = function (gl) {
                    return pushAndReturn(this.buffers, gl.createBuffer());
                };
                RenderArena.prototype.createVertexArray = function (gl) {
                    return pushAndReturn(this.vaos, gl.createVertexArray());
                };
                RenderArena.prototype.trackProgram = function (program) {
                    this.programs.push(program);
                };
                RenderArena.prototype.destroy = function (gl) {
                    try {
                        for (var _a = __values(this.textures), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var texture = _b.value;
                            gl.deleteTexture(texture);
                        }
                    }
                    catch (e_11_1) { e_11 = { error: e_11_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_11) throw e_11.error; }
                    }
                    this.textures = [];
                    try {
                        for (var _d = __values(this.samplers), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var sampler = _e.value;
                            gl.deleteSampler(sampler);
                        }
                    }
                    catch (e_12_1) { e_12 = { error: e_12_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                        }
                        finally { if (e_12) throw e_12.error; }
                    }
                    this.samplers = [];
                    try {
                        for (var _g = __values(this.buffers), _h = _g.next(); !_h.done; _h = _g.next()) {
                            var buffer = _h.value;
                            gl.deleteBuffer(buffer);
                        }
                    }
                    catch (e_13_1) { e_13 = { error: e_13_1 }; }
                    finally {
                        try {
                            if (_h && !_h.done && (_j = _g.return)) _j.call(_g);
                        }
                        finally { if (e_13) throw e_13.error; }
                    }
                    this.buffers = [];
                    try {
                        for (var _k = __values(this.vaos), _l = _k.next(); !_l.done; _l = _k.next()) {
                            var vao = _l.value;
                            gl.deleteVertexArray(vao);
                        }
                    }
                    catch (e_14_1) { e_14 = { error: e_14_1 }; }
                    finally {
                        try {
                            if (_l && !_l.done && (_m = _k.return)) _m.call(_k);
                        }
                        finally { if (e_14) throw e_14.error; }
                    }
                    this.vaos = [];
                    try {
                        for (var _o = __values(this.programs), _p = _o.next(); !_p.done; _p = _o.next()) {
                            var program = _p.value;
                            program.destroy(gl);
                        }
                    }
                    catch (e_15_1) { e_15 = { error: e_15_1 }; }
                    finally {
                        try {
                            if (_p && !_p.done && (_q = _o.return)) _q.call(_o);
                        }
                        finally { if (e_15) throw e_15.error; }
                    }
                    this.programs = [];
                    var e_11, _c, e_12, _f, e_13, _j, e_14, _m, e_15, _q;
                };
                return RenderArena;
            }());
            exports_12("default", RenderArena);
        }
    };
});
System.register("render", ["gl-matrix", "util", "Program", "Camera"], function (exports_13, context_13) {
    "use strict";
    var __moduleName = context_13 && context_13.id;
    function flagChanged(stateFlag, newFlag) {
        return newFlag !== undefined && stateFlag !== newFlag;
    }
    function applyFlags(gl, stateFlags, newFlags) {
        if (flagChanged(stateFlags.depthWrite, newFlags.depthWrite)) {
            gl.depthMask(newFlags.depthWrite);
            stateFlags.depthWrite = newFlags.depthWrite;
        }
        if (flagChanged(stateFlags.depthTest, newFlags.depthTest)) {
            if (newFlags.depthTest)
                gl.enable(gl.DEPTH_TEST);
            else
                gl.disable(gl.DEPTH_TEST);
            stateFlags.depthTest = newFlags.depthTest;
        }
        if (flagChanged(stateFlags.depthFunc, newFlags.depthFunc)) {
            gl.depthFunc(newFlags.depthFunc);
            stateFlags.depthFunc = newFlags.depthFunc;
        }
        if (flagChanged(stateFlags.blendMode, newFlags.blendMode)) {
            if (newFlags.blendMode !== BlendMode.NONE) {
                gl.enable(gl.BLEND);
                gl.blendEquation(newFlags.blendMode);
            }
            else {
                gl.disable(gl.BLEND);
            }
            stateFlags.blendMode = newFlags.blendMode;
        }
        if (flagChanged(stateFlags.blendSrc, newFlags.blendSrc) || flagChanged(stateFlags.blendDst, newFlags.blendDst)) {
            gl.blendFunc(newFlags.blendSrc, newFlags.blendDst);
            stateFlags.blendSrc = newFlags.blendSrc;
            stateFlags.blendDst = newFlags.blendDst;
        }
        if (flagChanged(stateFlags.cullMode, newFlags.cullMode)) {
            // Try to be smart about this.
            if (stateFlags.cullMode === CullMode.NONE)
                gl.enable(gl.CULL_FACE);
            else if (newFlags.cullMode === CullMode.NONE)
                gl.disable(gl.CULL_FACE);
            if (newFlags.cullMode === CullMode.BACK)
                gl.cullFace(gl.BACK);
            else if (newFlags.cullMode === CullMode.FRONT)
                gl.cullFace(gl.FRONT);
            else if (newFlags.cullMode === CullMode.FRONT_AND_BACK)
                gl.cullFace(gl.FRONT_AND_BACK);
            stateFlags.cullMode = newFlags.cullMode;
        }
        if (flagChanged(stateFlags.frontFace, newFlags.frontFace)) {
            gl.frontFace(newFlags.frontFace);
            stateFlags.frontFace = newFlags.frontFace;
        }
    }
    var gl_matrix_2, util_6, Program_1, Camera_1, CompareMode, FrontFaceMode, CullMode, BlendFactor, BlendMode, RenderFlags, FullscreenCopyProgram, RENDER_SAMPLES, ColorTarget, DepthTarget, depthClearFlags, RenderState;
    return {
        setters: [
            function (gl_matrix_2_1) {
                gl_matrix_2 = gl_matrix_2_1;
            },
            function (util_6_1) {
                util_6 = util_6_1;
            },
            function (Program_1_1) {
                Program_1 = Program_1_1;
            },
            function (Camera_1_1) {
                Camera_1 = Camera_1_1;
            }
        ],
        execute: function () {
            (function (CompareMode) {
                CompareMode[CompareMode["NEVER"] = WebGLRenderingContext.NEVER] = "NEVER";
                CompareMode[CompareMode["LESS"] = WebGLRenderingContext.LESS] = "LESS";
                CompareMode[CompareMode["EQUAL"] = WebGLRenderingContext.EQUAL] = "EQUAL";
                CompareMode[CompareMode["LEQUAL"] = WebGLRenderingContext.LEQUAL] = "LEQUAL";
                CompareMode[CompareMode["GREATER"] = WebGLRenderingContext.GREATER] = "GREATER";
                CompareMode[CompareMode["NEQUAL"] = WebGLRenderingContext.NOTEQUAL] = "NEQUAL";
                CompareMode[CompareMode["GEQUAL"] = WebGLRenderingContext.GEQUAL] = "GEQUAL";
                CompareMode[CompareMode["ALWAYS"] = WebGLRenderingContext.ALWAYS] = "ALWAYS";
            })(CompareMode || (CompareMode = {}));
            exports_13("CompareMode", CompareMode);
            (function (FrontFaceMode) {
                FrontFaceMode[FrontFaceMode["CCW"] = WebGLRenderingContext.CCW] = "CCW";
                FrontFaceMode[FrontFaceMode["CW"] = WebGLRenderingContext.CW] = "CW";
            })(FrontFaceMode || (FrontFaceMode = {}));
            exports_13("FrontFaceMode", FrontFaceMode);
            (function (CullMode) {
                CullMode[CullMode["NONE"] = 0] = "NONE";
                CullMode[CullMode["FRONT"] = 1] = "FRONT";
                CullMode[CullMode["BACK"] = 2] = "BACK";
                CullMode[CullMode["FRONT_AND_BACK"] = 3] = "FRONT_AND_BACK";
            })(CullMode || (CullMode = {}));
            exports_13("CullMode", CullMode);
            (function (BlendFactor) {
                BlendFactor[BlendFactor["ZERO"] = WebGLRenderingContext.ZERO] = "ZERO";
                BlendFactor[BlendFactor["ONE"] = WebGLRenderingContext.ONE] = "ONE";
                BlendFactor[BlendFactor["SRC_COLOR"] = WebGLRenderingContext.SRC_COLOR] = "SRC_COLOR";
                BlendFactor[BlendFactor["ONE_MINUS_SRC_COLOR"] = WebGLRenderingContext.ONE_MINUS_SRC_COLOR] = "ONE_MINUS_SRC_COLOR";
                BlendFactor[BlendFactor["DST_COLOR"] = WebGLRenderingContext.DST_COLOR] = "DST_COLOR";
                BlendFactor[BlendFactor["ONE_MINUS_DST_COLOR"] = WebGLRenderingContext.ONE_MINUS_DST_COLOR] = "ONE_MINUS_DST_COLOR";
                BlendFactor[BlendFactor["SRC_ALPHA"] = WebGLRenderingContext.SRC_ALPHA] = "SRC_ALPHA";
                BlendFactor[BlendFactor["ONE_MINUS_SRC_ALPHA"] = WebGLRenderingContext.ONE_MINUS_SRC_ALPHA] = "ONE_MINUS_SRC_ALPHA";
                BlendFactor[BlendFactor["DST_ALPHA"] = WebGLRenderingContext.DST_ALPHA] = "DST_ALPHA";
                BlendFactor[BlendFactor["ONE_MINUS_DST_ALPHA"] = WebGLRenderingContext.ONE_MINUS_DST_ALPHA] = "ONE_MINUS_DST_ALPHA";
            })(BlendFactor || (BlendFactor = {}));
            exports_13("BlendFactor", BlendFactor);
            (function (BlendMode) {
                BlendMode[BlendMode["NONE"] = 0] = "NONE";
                BlendMode[BlendMode["ADD"] = WebGLRenderingContext.FUNC_ADD] = "ADD";
                BlendMode[BlendMode["SUBTRACT"] = WebGLRenderingContext.FUNC_SUBTRACT] = "SUBTRACT";
                BlendMode[BlendMode["REVERSE_SUBTRACT"] = WebGLRenderingContext.FUNC_REVERSE_SUBTRACT] = "REVERSE_SUBTRACT";
            })(BlendMode || (BlendMode = {}));
            exports_13("BlendMode", BlendMode);
            RenderFlags = /** @class */ (function () {
                function RenderFlags() {
                    this.depthWrite = undefined;
                    this.depthTest = undefined;
                    this.depthFunc = undefined;
                    this.blendSrc = undefined;
                    this.blendDst = undefined;
                    this.blendMode = undefined;
                    this.cullMode = undefined;
                    this.frontFace = undefined;
                }
                RenderFlags.default = new RenderFlags();
                return RenderFlags;
            }());
            exports_13("RenderFlags", RenderFlags);
            RenderFlags.default.blendMode = BlendMode.NONE;
            RenderFlags.default.blendSrc = BlendFactor.SRC_ALPHA;
            RenderFlags.default.blendDst = BlendFactor.ONE_MINUS_SRC_ALPHA;
            RenderFlags.default.cullMode = CullMode.NONE;
            RenderFlags.default.depthTest = false;
            RenderFlags.default.depthWrite = true;
            RenderFlags.default.depthFunc = CompareMode.LEQUAL;
            RenderFlags.default.frontFace = FrontFaceMode.CCW;
            FullscreenCopyProgram = /** @class */ (function (_super) {
                __extends(FullscreenCopyProgram, _super);
                function FullscreenCopyProgram() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.frag = "\nuniform sampler2D u_Texture;\nin vec2 v_TexCoord;\n\nvoid main() {\n    vec4 color = texture(u_Texture, v_TexCoord);\n    gl_FragColor = vec4(color.rgb, 1.0);\n}\n";
                    return _this;
                }
                return FullscreenCopyProgram;
            }(Program_1.FullscreenProgram));
            RENDER_SAMPLES = 4;
            ColorTarget = /** @class */ (function () {
                function ColorTarget() {
                }
                ColorTarget.prototype.destroy = function (gl) {
                    if (this.msaaColorRenderbuffer)
                        gl.deleteRenderbuffer(this.msaaColorRenderbuffer);
                    if (this.resolvedColorTexture)
                        gl.deleteTexture(this.resolvedColorTexture);
                };
                ColorTarget.prototype.setParameters = function (gl, width, height, samples) {
                    if (samples === void 0) { samples = RENDER_SAMPLES; }
                    if (this.width === width && this.height === height && this.samples === samples)
                        return;
                    this.destroy(gl);
                    this.width = width;
                    this.height = height;
                    this.samples = samples;
                    this.msaaColorRenderbuffer = gl.createRenderbuffer();
                    gl.bindRenderbuffer(gl.RENDERBUFFER, this.msaaColorRenderbuffer);
                    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.RGBA8, this.width, this.height);
                    this.resolvedColorTexture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, this.resolvedColorTexture);
                    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, this.width, this.height);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                };
                ColorTarget.prototype.resolve = function (gl) {
                    var readFramebuffer = gl.createFramebuffer();
                    var resolveFramebuffer = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, readFramebuffer);
                    gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this.msaaColorRenderbuffer);
                    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, resolveFramebuffer);
                    gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.resolvedColorTexture, 0);
                    gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);
                    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
                    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
                    gl.deleteFramebuffer(readFramebuffer);
                    gl.deleteFramebuffer(resolveFramebuffer);
                    return this.resolvedColorTexture;
                };
                return ColorTarget;
            }());
            exports_13("ColorTarget", ColorTarget);
            DepthTarget = /** @class */ (function () {
                function DepthTarget() {
                }
                DepthTarget.prototype.destroy = function (gl) {
                    if (this.msaaDepthRenderbuffer)
                        gl.deleteRenderbuffer(this.msaaDepthRenderbuffer);
                };
                DepthTarget.prototype.setParameters = function (gl, width, height, samples) {
                    if (samples === void 0) { samples = RENDER_SAMPLES; }
                    if (this.width === width && this.height === height && this.samples === samples)
                        return;
                    this.destroy(gl);
                    this.width = width;
                    this.height = height;
                    this.samples = samples;
                    this.msaaDepthRenderbuffer = gl.createRenderbuffer();
                    gl.bindRenderbuffer(gl.RENDERBUFFER, this.msaaDepthRenderbuffer);
                    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, this.width, this.height);
                };
                return DepthTarget;
            }());
            exports_13("DepthTarget", DepthTarget);
            exports_13("depthClearFlags", depthClearFlags = new RenderFlags());
            depthClearFlags.depthWrite = true;
            // XXX(jstpierre): This is becoming a lot more than just some render state.
            // Rename to "SceneRenderer" at some point?
            RenderState = /** @class */ (function () {
                function RenderState(gl) {
                    this.gl = gl;
                    // State.
                    this.currentProgram = null;
                    this.currentFlags = new RenderFlags();
                    this.currentColorTarget = null;
                    this.currentDepthTarget = null;
                    this.drawCallCount = 0;
                    this.frameStartTime = 0;
                    this.programCache = new Program_1.ProgramCache(this.gl);
                    this.time = 0;
                    this.fov = Math.PI / 4;
                    this.camera = new Camera_1.Camera();
                    this.scratchMatrix = gl_matrix_2.mat4.create();
                    this.fullscreenCopyProgram = new FullscreenCopyProgram();
                    this.fullscreenFlags = new RenderFlags();
                    this.fullscreenFlags.depthTest = false;
                    this.fullscreenFlags.blendMode = BlendMode.NONE;
                    this.fullscreenFlags.cullMode = CullMode.NONE;
                    this.msaaFramebuffer = util_6.assertExists(gl.createFramebuffer());
                }
                Object.defineProperty(RenderState.prototype, "view", {
                    // TODO(jstpierre): Remove.
                    get: function () {
                        return this.camera.viewMatrix;
                    },
                    enumerable: true,
                    configurable: true
                });
                RenderState.prototype.destroy = function () {
                    var gl = this.gl;
                    gl.deleteFramebuffer(this.msaaFramebuffer);
                };
                RenderState.prototype.reset = function () {
                    this.drawCallCount = 0;
                    this.frameStartTime = window.performance.now();
                    this.useRenderTarget(this.onscreenColorTarget, this.onscreenDepthTarget);
                    this.useFlags(RenderFlags.default);
                    this.camera.newFrame();
                };
                // XXX(jstpierre): Design a better API than this.
                RenderState.prototype.runFullscreen = function (flags) {
                    if (flags === void 0) { flags = null; }
                    var gl = this.gl;
                    this.useFlags(flags !== null ? flags : this.fullscreenFlags);
                    gl.drawArrays(gl.TRIANGLES, 0, 3);
                };
                RenderState.prototype.blitFullscreenTexture = function (colorTexture, flags) {
                    if (flags === void 0) { flags = null; }
                    var gl = this.gl;
                    this.useProgram(this.fullscreenCopyProgram);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, colorTexture);
                    gl.bindSampler(0, null);
                    this.runFullscreen(flags);
                };
                RenderState.prototype.blitColorTarget = function (colorTarget, flags) {
                    if (flags === void 0) { flags = null; }
                    var gl = this.gl;
                    var resolvedColorTexture = colorTarget.resolve(gl);
                    // Make sure to re-bind our destination RT, since the resolve screws things up...
                    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.msaaFramebuffer);
                    this.blitFullscreenTexture(resolvedColorTexture, flags);
                };
                RenderState.prototype.blitOnscreenToGL = function () {
                    var gl = this.gl;
                    var resolvedColorTexture = this.onscreenColorTarget.resolve(gl);
                    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
                    this.blitFullscreenTexture(resolvedColorTexture);
                };
                RenderState.prototype.setOnscreenRenderTarget = function (colorTarget, depthTarget) {
                    this.onscreenColorTarget = colorTarget;
                    this.onscreenDepthTarget = depthTarget;
                };
                RenderState.prototype.useRenderTarget = function (colorTarget, depthTarget) {
                    if (depthTarget === void 0) { depthTarget = this.onscreenDepthTarget; }
                    var gl = this.gl;
                    if (colorTarget !== null && depthTarget !== null) {
                        // Assert our invariants.
                        util_6.assert(colorTarget.width === depthTarget.width);
                        util_6.assert(colorTarget.height === depthTarget.height);
                        util_6.assert(colorTarget.samples === depthTarget.samples);
                    }
                    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.msaaFramebuffer);
                    this.currentColorTarget = colorTarget;
                    var colorRenderbuffer = this.currentColorTarget ? this.currentColorTarget.msaaColorRenderbuffer : null;
                    gl.framebufferRenderbuffer(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, colorRenderbuffer);
                    this.currentDepthTarget = depthTarget;
                    var depthRenderbuffer = this.currentDepthTarget ? this.currentDepthTarget.msaaDepthRenderbuffer : null;
                    gl.framebufferRenderbuffer(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthRenderbuffer);
                    this.bindViewport();
                };
                RenderState.prototype.getAspect = function () {
                    var width = this.currentColorTarget.width, height = this.currentColorTarget.height;
                    return width / height;
                };
                RenderState.prototype.updateProjection = function () {
                    this.camera.setPerspective(this.fov, this.getAspect(), this.nearClipPlane, this.farClipPlane);
                };
                RenderState.prototype.bindViewport = function () {
                    this.updateProjection();
                    var gl = this.gl;
                    var width = this.currentColorTarget.width, height = this.currentColorTarget.height;
                    gl.viewport(0, 0, width, height);
                };
                RenderState.prototype.setClipPlanes = function (near, far) {
                    this.nearClipPlane = near;
                    this.farClipPlane = far;
                    if (this.currentColorTarget) {
                        this.updateProjection();
                    }
                };
                RenderState.prototype.compileProgram = function (prog) {
                    return prog.compile(this.gl, this.programCache);
                };
                RenderState.prototype.useProgram = function (prog) {
                    var gl = this.gl;
                    this.currentProgram = prog;
                    gl.useProgram(this.compileProgram(prog));
                };
                RenderState.prototype.updateModelView = function (isSkybox, model) {
                    if (isSkybox === void 0) { isSkybox = false; }
                    if (model === void 0) { model = null; }
                    var modelView = this.scratchMatrix;
                    if (isSkybox) {
                        Camera_1.computeViewMatrixSkybox(modelView, this.camera);
                    }
                    else {
                        Camera_1.computeViewMatrix(modelView, this.camera);
                    }
                    if (model) {
                        gl_matrix_2.mat4.mul(modelView, modelView, model);
                    }
                    return modelView;
                };
                RenderState.prototype.bindModelView = function (isSkybox, model) {
                    if (isSkybox === void 0) { isSkybox = false; }
                    if (model === void 0) { model = null; }
                    // XXX(jstpierre): Remove this junk
                    var gl = this.gl;
                    var prog = this.currentProgram;
                    var scratch = this.updateModelView(isSkybox, model);
                    gl.uniformMatrix4fv(prog.projectionLocation, false, this.camera.projectionMatrix);
                    gl.uniformMatrix4fv(prog.modelViewLocation, false, scratch);
                };
                RenderState.prototype.useFlags = function (flags) {
                    var gl = this.gl;
                    applyFlags(gl, this.currentFlags, flags);
                };
                return RenderState;
            }());
            exports_13("RenderState", RenderState);
        }
    };
});
System.register("RenderUtility", ["Program", "gl-matrix"], function (exports_14, context_14) {
    "use strict";
    var __moduleName = context_14 && context_14.id;
    function renderWireframeAABB(state, aabb, modelMatrix, color) {
        if (modelMatrix === void 0) { modelMatrix = null; }
        if (color === void 0) { color = null; }
        var gl = state.gl;
        if (!indexBuffer) {
            vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
        }
        gl.bindVertexArray(vao);
        var prog = new LinesProgram();
        state.useProgram(prog);
        state.bindModelView(false, modelMatrix);
        var vertexData = new Float32Array(3 * 8);
        vertexData[0 * 3 + 0] = aabb.minX;
        vertexData[0 * 3 + 1] = aabb.minY;
        vertexData[0 * 3 + 2] = aabb.minZ;
        vertexData[1 * 3 + 0] = aabb.maxX;
        vertexData[1 * 3 + 1] = aabb.minY;
        vertexData[1 * 3 + 2] = aabb.minZ;
        vertexData[2 * 3 + 0] = aabb.maxX;
        vertexData[2 * 3 + 1] = aabb.minY;
        vertexData[2 * 3 + 2] = aabb.maxZ;
        vertexData[3 * 3 + 0] = aabb.minX;
        vertexData[3 * 3 + 1] = aabb.minY;
        vertexData[3 * 3 + 2] = aabb.maxZ;
        vertexData[4 * 3 + 0] = aabb.minX;
        vertexData[4 * 3 + 1] = aabb.maxY;
        vertexData[4 * 3 + 2] = aabb.minZ;
        vertexData[5 * 3 + 0] = aabb.maxX;
        vertexData[5 * 3 + 1] = aabb.maxY;
        vertexData[5 * 3 + 2] = aabb.minZ;
        vertexData[6 * 3 + 0] = aabb.maxX;
        vertexData[6 * 3 + 1] = aabb.maxY;
        vertexData[6 * 3 + 2] = aabb.maxZ;
        vertexData[7 * 3 + 0] = aabb.minX;
        vertexData[7 * 3 + 1] = aabb.maxY;
        vertexData[7 * 3 + 2] = aabb.maxZ;
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW);
        if (!color)
            color = defaultLineColor;
        gl.uniform4fv(prog.u_LineColor, color);
        gl.vertexAttribPointer(13, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(13);
        gl.drawElements(gl.LINES, 12 * 2, gl.UNSIGNED_BYTE, 0);
        gl.bindVertexArray(null);
    }
    exports_14("renderWireframeAABB", renderWireframeAABB);
    var Program_2, gl_matrix_3, LinesProgram, vertexBuffer, indexBuffer, vao, indexData, defaultLineColor;
    return {
        setters: [
            function (Program_2_1) {
                Program_2 = Program_2_1;
            },
            function (gl_matrix_3_1) {
                gl_matrix_3 = gl_matrix_3_1;
            }
        ],
        execute: function () {
            LinesProgram = /** @class */ (function (_super) {
                __extends(LinesProgram, _super);
                function LinesProgram() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.vert = "\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nlayout(location = 13) attribute vec3 a_Position;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_Position, 1.0);\n}\n";
                    _this.frag = "\nuniform vec4 u_LineColor;\n\nvoid main() {\n    gl_FragColor = u_LineColor;\n    gl_FragDepth = gl_FragCoord.z - 1e-6;\n}\n";
                    return _this;
                }
                LinesProgram.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.u_LineColor = gl.getUniformLocation(prog, 'u_LineColor');
                };
                return LinesProgram;
            }(Program_2.default));
            indexData = new Uint8Array([
                // Top.
                0, 1,
                1, 2,
                2, 3,
                3, 0,
                // Bottom.
                4, 5,
                5, 6,
                6, 7,
                7, 4,
                // Sides.
                0, 4,
                1, 5,
                2, 6,
                3, 7,
            ]);
            defaultLineColor = gl_matrix_3.vec4.fromValues(1, 0, 1, 1);
        }
    };
});
System.register("WasmMemoryManager", [], function (exports_15, context_15) {
    "use strict";
    var __moduleName = context_15 && context_15.id;
    var WasmMemoryManager;
    return {
        setters: [],
        execute: function () {
            WasmMemoryManager = /** @class */ (function () {
                function WasmMemoryManager(mem) {
                    // WebAssembly pages are 64k.
                    this.PAGE_SIZE = 64 * 1024;
                    if (mem !== undefined)
                        this.mem = mem;
                    else
                        this.mem = new WebAssembly.Memory({ initial: 1 });
                    this.currentNumPages = this.mem.buffer.byteLength / this.PAGE_SIZE;
                    // resize must be called before use.
                    this.heap = null;
                }
                WasmMemoryManager.prototype.resize = function (newSize) {
                    var newNumPages = Math.ceil(newSize / this.PAGE_SIZE);
                    if (newNumPages > this.currentNumPages) {
                        this.mem.grow(newNumPages - this.currentNumPages);
                        this.currentNumPages = newNumPages;
                        this.heap = null;
                    }
                    if (this.heap === null)
                        this.heap = new Uint8Array(this.mem.buffer);
                    return this.heap;
                };
                return WasmMemoryManager;
            }());
            exports_15("default", WasmMemoryManager);
        }
    };
});
System.register("byml", ["util"], function (exports_16, context_16) {
    "use strict";
    var __moduleName = context_16 && context_16.id;
    function getUint24(view, offs, littleEndian) {
        if (littleEndian)
            return view.getUint32(offs - 1, true) >>> 8;
        else
            return view.getUint32(offs - 1, false) & 0x00FFFFFF;
    }
    function parseStringTable(context, buffer, offs) {
        var view = buffer.createDataView();
        var header = view.getUint32(offs + 0x00, context.littleEndian);
        var nodeType = header >>> 24;
        var numValues = header & 0x00FFFFFF;
        util_7.assert(nodeType === 194 /* STRING_TABLE */);
        var stringTableIdx = offs + 0x04;
        var strings = [];
        for (var i = 0; i < numValues; i++) {
            var strOffs = offs + view.getUint32(stringTableIdx, context.littleEndian);
            strings.push(util_7.readString(buffer, strOffs, -1, true));
            stringTableIdx += 0x04;
        }
        return strings;
    }
    function parseDict(context, buffer, offs) {
        var view = buffer.createDataView();
        var nodeType = view.getUint8(offs + 0x00);
        var numValues = getUint24(view, offs + 0x01, context.littleEndian);
        util_7.assert(nodeType === 193 /* DICT */);
        var result = {};
        var dictIdx = offs + 0x04;
        for (var i = 0; i < numValues; i++) {
            var entryStrKeyIdx = getUint24(view, dictIdx + 0x00, context.littleEndian);
            var entryKey = context.strKeyTable[entryStrKeyIdx];
            var entryNodeType = view.getUint8(dictIdx + 0x03);
            var entryValue = parseNode(context, buffer, entryNodeType, dictIdx + 0x04);
            result[entryKey] = entryValue;
            dictIdx += 0x08;
        }
        return result;
    }
    function parseArray(context, buffer, offs) {
        var view = buffer.createDataView();
        var nodeType = view.getUint8(offs + 0x00);
        var numValues = getUint24(view, offs + 0x01, context.littleEndian);
        util_7.assert(nodeType === 192 /* ARRAY */);
        var result = [];
        var entryTypeIdx = offs + 0x04;
        var entryOffsIdx = util_7.align(entryTypeIdx + numValues, 4);
        for (var i = 0; i < numValues; i++) {
            var entryNodeType = view.getUint8(entryTypeIdx);
            result.push(parseNode(context, buffer, entryNodeType, entryOffsIdx));
            entryTypeIdx++;
            entryOffsIdx += 0x04;
        }
        return result;
    }
    function parseComplexNode(context, buffer, offs, expectedNodeType) {
        var view = buffer.createDataView();
        var nodeType = view.getUint8(offs + 0x00);
        var numValues = getUint24(view, offs + 0x01, context.littleEndian);
        if (expectedNodeType !== undefined)
            util_7.assert(expectedNodeType === nodeType);
        switch (nodeType) {
            case 193 /* DICT */:
                return parseDict(context, buffer, offs);
            case 192 /* ARRAY */:
                return parseArray(context, buffer, offs);
            case 194 /* STRING_TABLE */:
                return parseStringTable(context, buffer, offs);
            case 203 /* BINARY_DATA */:
                return buffer.subarray(offs + 0x04, numValues);
            case 226 /* FLOAT_ARRAY */:
                return buffer.createTypedArray(Float32Array, offs + 0x04, numValues, 1 /* BIG_ENDIAN */);
            default:
                throw new Error("whoops");
        }
    }
    function validateNodeType(context, nodeType) {
        util_7.assert(fileDescriptions[context.fileType].allowedNodeTypes.includes(nodeType));
    }
    function parseNode(context, buffer, nodeType, offs) {
        var view = buffer.createDataView();
        validateNodeType(context, nodeType);
        switch (nodeType) {
            case 192 /* ARRAY */:
            case 193 /* DICT */:
            case 194 /* STRING_TABLE */:
            case 203 /* BINARY_DATA */:
            case 226 /* FLOAT_ARRAY */: {
                var complexOffs = view.getUint32(offs);
                return parseComplexNode(context, buffer, complexOffs, nodeType);
            }
            case 160 /* STRING */: {
                var idx = view.getUint32(offs);
                return context.strValueTable[idx];
            }
            case 208 /* BOOL */: {
                var value = view.getUint32(offs);
                util_7.assert(value === 0 || value === 1);
                return !!value;
            }
            case 209 /* INT */:
            case 211 /* SHORT */: {
                var value = view.getUint32(offs);
                return value;
            }
            case 210 /* FLOAT */: {
                var value = view.getFloat32(offs);
                return value;
            }
            case 255 /* NULL */: {
                return null;
            }
        }
    }
    function parse(buffer, fileType) {
        if (fileType === void 0) { fileType = 0 /* BYML */; }
        var magic = util_7.readString(buffer, 0x00, 0x04);
        var magics = fileDescriptions[fileType].magics;
        util_7.assert(magics.includes(magic));
        var view = buffer.createDataView();
        var littleEndian = magic.slice(0, 2) == 'YB';
        var endianness = littleEndian ? 0 /* LITTLE_ENDIAN */ : 1 /* BIG_ENDIAN */;
        var context = new ParseContext(fileType, endianness);
        var strKeyTableOffs = view.getUint32(0x04, context.littleEndian);
        var strValueTableOffs = view.getUint32(0x08, context.littleEndian);
        var rootNodeOffs = view.getUint32(0x0C, context.littleEndian);
        if (rootNodeOffs === 0)
            return {};
        context.strKeyTable = strKeyTableOffs !== 0 ? parseStringTable(context, buffer, strKeyTableOffs) : null;
        context.strValueTable = strValueTableOffs !== 0 ? parseStringTable(context, buffer, strValueTableOffs) : null;
        var node = parseComplexNode(context, buffer, rootNodeOffs);
        return node;
    }
    exports_16("parse", parse);
    var util_7, fileDescriptions, ParseContext, _a;
    return {
        setters: [
            function (util_7_1) {
                util_7 = util_7_1;
            }
        ],
        execute: function () {
            fileDescriptions = (_a = {},
                _a[0 /* BYML */] = {
                    magics: ['BY\0\x01', 'BY\0\x02', 'YB\x03\0'],
                    allowedNodeTypes: [160 /* STRING */, 192 /* ARRAY */, 193 /* DICT */, 194 /* STRING_TABLE */, 208 /* BOOL */, 209 /* INT */, 211 /* SHORT */, 210 /* FLOAT */, 255 /* NULL */],
                },
                _a[1 /* CRG1 */] = {
                    magics: ['CRG1'],
                    allowedNodeTypes: [160 /* STRING */, 192 /* ARRAY */, 193 /* DICT */, 194 /* STRING_TABLE */, 208 /* BOOL */, 209 /* INT */, 211 /* SHORT */, 210 /* FLOAT */, 255 /* NULL */, 226 /* FLOAT_ARRAY */, 203 /* BINARY_DATA */],
                },
                _a);
            ParseContext = /** @class */ (function () {
                function ParseContext(fileType, endianness) {
                    this.fileType = fileType;
                    this.endianness = endianness;
                    this.strKeyTable = null;
                    this.strValueTable = null;
                }
                Object.defineProperty(ParseContext.prototype, "littleEndian", {
                    get: function () { return this.endianness === 0 /* LITTLE_ENDIAN */; },
                    enumerable: true,
                    configurable: true
                });
                return ParseContext;
            }());
        }
    };
});
// New UI system
System.register("ui", ["util", "Camera"], function (exports_17, context_17) {
    "use strict";
    var __moduleName = context_17 && context_17.id;
    function createDOMFromString(s) {
        return document.createRange().createContextualFragment(s);
    }
    function setElementHighlighted(elem, highlighted, normalTextColor) {
        if (normalTextColor === void 0) { normalTextColor = ''; }
        elem.classList.toggle('Highlighted', highlighted);
        if (highlighted) {
            elem.style.backgroundColor = HIGHLIGHT_COLOR;
            elem.style.color = 'black';
        }
        else {
            elem.style.backgroundColor = '';
            elem.style.color = normalTextColor;
        }
    }
    function highlightFlair(i) {
        return { index: i, background: HIGHLIGHT_COLOR, color: 'black' };
    }
    function cloneCanvas(dst, src) {
        dst.width = src.width;
        dst.height = src.height;
        dst.title = src.title;
        var ctx = dst.getContext('2d');
        ctx.drawImage(src, 0, 0);
    }
    var util_8, Camera_2, HIGHLIGHT_COLOR, ScrollSelect, SingleSelect, SimpleSingleSelect, MultiSelect, Panel, OPEN_ICON, SceneSelect, CHECKERBOARD_IMAGE, TEXTURES_ICON, TextureViewer, FRUSTUM_ICON, ViewerSettings, ABOUT_ICON, About, LAYER_ICON, LayerPanel, UI;
    return {
        setters: [
            function (util_8_1) {
                util_8 = util_8_1;
            },
            function (Camera_2_1) {
                Camera_2 = Camera_2_1;
            }
        ],
        execute: function () {
            HIGHLIGHT_COLOR = 'rgb(210, 30, 30)';
            ScrollSelect = /** @class */ (function () {
                function ScrollSelect() {
                    this.flairs = [];
                    this.internalFlairs = [];
                    this.toplevel = document.createElement('div');
                    this.scrollContainer = document.createElement('div');
                    this.scrollContainer.style.height = "200px";
                    this.scrollContainer.style.overflow = 'auto';
                    this.scrollContainer.style.userSelect = 'none';
                    this.scrollContainer.style.webkitUserSelect = 'none';
                    this.toplevel.appendChild(this.scrollContainer);
                    this.elem = this.toplevel;
                }
                ScrollSelect.prototype.setStrings = function (strings) {
                    var _this = this;
                    this.scrollContainer.style.display = (strings.length > 0) ? '' : 'none';
                    this.scrollContainer.innerHTML = '';
                    var _loop_1 = function (i) {
                        var selector = document.createElement('div');
                        selector.style.display = 'list-item';
                        selector.style.cursor = 'pointer';
                        var textSpan = document.createElement('span');
                        textSpan.style.fontWeight = 'bold';
                        textSpan.textContent = strings[i];
                        selector.appendChild(textSpan);
                        var index = i;
                        selector.onclick = function () {
                            _this.itemClicked(index);
                        };
                        this_1.scrollContainer.appendChild(selector);
                    };
                    var this_1 = this;
                    for (var i = 0; i < strings.length; i++) {
                        _loop_1(i);
                    }
                };
                ScrollSelect.prototype.getNumItems = function () {
                    return this.scrollContainer.childElementCount;
                };
                ScrollSelect.prototype.setFlairs = function (flairs) {
                    this.flairs = flairs;
                    this.syncFlairs();
                };
                ScrollSelect.prototype.setInternalFlairs = function (flairs) {
                    this.internalFlairs = flairs;
                    this.syncFlairs();
                };
                ScrollSelect.prototype.syncFlairs = function () {
                    var flairs = __spread(this.internalFlairs, this.flairs);
                    var _loop_2 = function (i) {
                        var selector = this_2.scrollContainer.children.item(i);
                        var flair = flairs.find(function (flair) { return flair.index === i; });
                        var background = (flair !== undefined && flair.background !== undefined) ? flair.background : '';
                        selector.style.background = background;
                        var textSpan = util_8.assertExists(selector.querySelector('span'));
                        var color = (flair !== undefined && flair.color !== undefined) ? flair.color : '';
                        textSpan.style.color = color;
                        if (flair !== undefined && flair.bulletColor !== undefined) {
                            selector.style.listStyleType = 'disc';
                            selector.style.listStylePosition = 'inside';
                            selector.style.marginLeft = '4px';
                            selector.style.color = flair.bulletColor;
                        }
                        else {
                            selector.style.listStyleType = '';
                            selector.style.color = '';
                            selector.style.marginLeft = '';
                        }
                    };
                    var this_2 = this;
                    for (var i = 0; i < this.getNumItems(); i++) {
                        _loop_2(i);
                    }
                };
                return ScrollSelect;
            }());
            exports_17("ScrollSelect", ScrollSelect);
            SingleSelect = /** @class */ (function (_super) {
                __extends(SingleSelect, _super);
                function SingleSelect() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                SingleSelect.prototype.itemClicked = function (index) {
                    this.selectItem(index);
                };
                SingleSelect.prototype.selectItem = function (index) {
                    this.onselectionchange(index);
                };
                SingleSelect.prototype.setHighlighted = function (highlightedIndex) {
                    this.setInternalFlairs([highlightFlair(highlightedIndex)]);
                };
                return SingleSelect;
            }(ScrollSelect));
            exports_17("SingleSelect", SingleSelect);
            SimpleSingleSelect = /** @class */ (function (_super) {
                __extends(SimpleSingleSelect, _super);
                function SimpleSingleSelect() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                SimpleSingleSelect.prototype.selectItem = function (index) {
                    _super.prototype.selectItem.call(this, index);
                    this.setHighlighted(index);
                };
                return SimpleSingleSelect;
            }(SingleSelect));
            exports_17("SimpleSingleSelect", SimpleSingleSelect);
            MultiSelect = /** @class */ (function (_super) {
                __extends(MultiSelect, _super);
                function MultiSelect() {
                    var _this = _super.call(this) || this;
                    _this.itemIsOn = [];
                    var allNone = createDOMFromString("\n<div style=\"display: grid; grid-template-columns: 1fr 1fr; grid-gap: 4px;\">\n<style>\n.AllButton, .NoneButton {\n    text-align: center;\n    line-height: 32px;\n    cursor: pointer;\n    background: #666;\n    font-weight: bold;\n}\n</style>\n<div class=\"AllButton\">All</div><div class=\"NoneButton\">None</div>\n</div>\n");
                    _this.toplevel.insertBefore(allNone, _this.toplevel.firstChild);
                    var allButton = _this.toplevel.querySelector('.AllButton');
                    allButton.onclick = function () {
                        for (var i = 0; i < _this.getNumItems(); i++)
                            _this.setItemIsOn(i, true);
                        _this.syncInternalFlairs();
                    };
                    var noneButton = _this.toplevel.querySelector('.NoneButton');
                    noneButton.onclick = function () {
                        for (var i = 0; i < _this.getNumItems(); i++)
                            _this.setItemIsOn(i, false);
                        _this.syncInternalFlairs();
                    };
                    return _this;
                }
                MultiSelect.prototype.setItemIsOn = function (index, v) {
                    this.itemIsOn[index] = v;
                    this.onitemchanged(index, this.itemIsOn[index]);
                };
                MultiSelect.prototype.itemClicked = function (index) {
                    this.setItemIsOn(index, !this.itemIsOn[index]);
                    this.syncInternalFlairs();
                };
                MultiSelect.prototype.syncInternalFlairs = function () {
                    var flairs = __spread(this.flairs);
                    for (var i = 0; i < this.getNumItems(); i++) {
                        var bulletColor = !!this.itemIsOn[i] ? HIGHLIGHT_COLOR : '#aaa';
                        var color = !!this.itemIsOn[i] ? 'white' : '#aaa';
                        flairs.push({ index: i, bulletColor: bulletColor, color: color });
                    }
                    this.setInternalFlairs(flairs);
                };
                MultiSelect.prototype.setItemsSelected = function (isOn) {
                    this.itemIsOn = isOn;
                    this.syncInternalFlairs();
                };
                MultiSelect.prototype.setItemSelected = function (index, v) {
                    this.itemIsOn[index] = v;
                    this.syncInternalFlairs();
                };
                return MultiSelect;
            }(ScrollSelect));
            exports_17("MultiSelect", MultiSelect);
            Panel = /** @class */ (function () {
                function Panel() {
                    var _this = this;
                    this.toplevel = document.createElement('div');
                    this.toplevel.style.color = 'white';
                    this.toplevel.style.font = '16px monospace';
                    this.toplevel.style.overflow = 'hidden';
                    this.toplevel.style.display = 'grid';
                    this.toplevel.style.gridAutoFlow = 'column';
                    this.toplevel.style.gridGap = '20px';
                    this.toplevel.style.transition = '.25s ease-out';
                    this.toplevel.style.alignItems = 'start';
                    this.mainPanel = document.createElement('div');
                    this.mainPanel.style.overflow = 'hidden';
                    this.mainPanel.style.transition = '.25s ease-out';
                    this.mainPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    this.mainPanel.style.pointerEvents = 'auto';
                    this.toplevel.appendChild(this.mainPanel);
                    this.extraRack = document.createElement('div');
                    this.extraRack.style.display = 'grid';
                    this.extraRack.style.gridAutoFlow = 'column';
                    this.extraRack.style.gridGap = '20px';
                    this.extraRack.style.transition = '.15s ease-out .10s';
                    this.extraRack.style.pointerEvents = 'auto';
                    this.toplevel.appendChild(this.extraRack);
                    this.header = document.createElement('h1');
                    this.header.style.lineHeight = '28px';
                    this.header.style.width = '400px';
                    this.header.style.margin = '0';
                    this.header.style.color = HIGHLIGHT_COLOR;
                    this.header.style.fontSize = '100%';
                    this.header.style.textAlign = 'center';
                    this.header.style.cursor = 'pointer';
                    this.header.style.userSelect = 'none';
                    this.header.style.webkitUserSelect = 'none';
                    this.header.style.display = 'grid';
                    this.header.style.gridTemplateColumns = '28px 1fr';
                    this.header.style.alignItems = 'center';
                    this.header.style.justifyItems = 'center';
                    this.header.style.gridAutoFlow = 'column';
                    this.toplevel.onmouseover = this.syncSize.bind(this);
                    this.toplevel.onmouseout = this.syncSize.bind(this);
                    this.header.onclick = function () {
                        _this.toggleExpanded();
                    };
                    this.mainPanel.appendChild(this.header);
                    this.contents = document.createElement('div');
                    this.contents.style.width = '400px';
                    this.mainPanel.appendChild(this.contents);
                    this.elem = this.toplevel;
                }
                Panel.prototype.syncSize = function () {
                    var widthExpanded = this.expanded || this.mainPanel.matches(':hover');
                    this.mainPanel.style.width = widthExpanded ? '400px' : '28px';
                    var heightExpanded = this.expanded;
                    if (heightExpanded) {
                        var height = this.header.offsetHeight + this.contents.offsetHeight;
                        this.toplevel.style.height = height + "px";
                        this.extraRack.style.opacity = '1';
                    }
                    else {
                        this.toplevel.style.transition = '.25s ease-out';
                        this.toplevel.style.height = '28px';
                        this.extraRack.style.opacity = '0';
                    }
                };
                Panel.prototype.setVisible = function (v) {
                    this.toplevel.style.display = v ? 'grid' : 'none';
                };
                Panel.prototype.setTitle = function (icon, title) {
                    var svgIcon = createDOMFromString(icon).querySelector('svg');
                    this.svgIcon = svgIcon;
                    this.svgIcon.style.gridColumn = '1';
                    this.header.textContent = title;
                    this.header.appendChild(this.svgIcon);
                    this.setExpanded(false);
                };
                Panel.prototype.syncHeaderStyle = function () {
                    this.svgIcon.style.fill = this.expanded ? 'black' : '';
                    setElementHighlighted(this.header, this.expanded, HIGHLIGHT_COLOR);
                };
                Panel.prototype.setExpanded = function (expanded) {
                    this.expanded = expanded;
                    this.syncHeaderStyle();
                    this.syncSize();
                };
                Panel.prototype.toggleExpanded = function () {
                    this.setExpanded(!this.expanded);
                };
                return Panel;
            }());
            exports_17("Panel", Panel);
            OPEN_ICON = "<svg viewBox=\"0 0 100 100\" height=\"20\" fill=\"white\"><path d=\"M84.3765045,45.2316481 L77.2336539,75.2316205 L77.2336539,75.2316205 C77.1263996,75.6820886 76.7239081,76 76.2608477,76 L17.8061496,76 C17.2538649,76 16.8061496,75.5522847 16.8061496,75 C16.8061496,74.9118841 16.817796,74.8241548 16.8407862,74.739091 L24.7487983,45.4794461 C24.9845522,44.607157 25.7758952,44.0012839 26.6794815,44.0012642 L83.4036764,44.0000276 L83.4036764,44.0000276 C83.9559612,44.0000156 84.4036862,44.4477211 84.4036982,45.0000058 C84.4036999,45.0780163 84.3945733,45.155759 84.3765045,45.2316481 L84.3765045,45.2316481 Z M15,24 L26.8277004,24 L26.8277004,24 C27.0616369,24 27.2881698,24.0820162 27.4678848,24.2317787 L31.799078,27.8411064 L31.799078,27.8411064 C32.697653,28.5899189 33.8303175,29 35,29 L75,29 C75.5522847,29 76,29.4477153 76,30 L76,38 L76,38 C76,38.5522847 75.5522847,39 75,39 L25.3280454,39 L25.3280454,39 C23.0690391,39 21.0906235,40.5146929 20.5012284,42.6954549 L14.7844016,63.8477139 L14.7844016,63.8477139 C14.7267632,64.0609761 14.5071549,64.1871341 14.2938927,64.1294957 C14.1194254,64.0823423 13.9982484,63.9240598 13.9982563,63.7433327 L13.9999561,25 L14,25 C14.0000242,24.4477324 14.4477324,24.0000439 15,24.0000439 L15,24 Z\"/></svg>";
            SceneSelect = /** @class */ (function (_super) {
                __extends(SceneSelect, _super);
                function SceneSelect(viewer) {
                    var _this = _super.call(this) || this;
                    _this.viewer = viewer;
                    _this.sceneGroups = [];
                    _this.sceneDescs = [];
                    _this.setTitle(OPEN_ICON, 'Scenes');
                    _this.sceneGroupList = new SingleSelect();
                    _this.contents.appendChild(_this.sceneGroupList.elem);
                    _this.sceneDescList = new SingleSelect();
                    _this.sceneDescList.elem.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    _this.sceneDescList.elem.style.width = '400px';
                    _this.extraRack.appendChild(_this.sceneDescList.elem);
                    _this.sceneGroupList.onselectionchange = function (i) {
                        _this.selectSceneGroup(i);
                    };
                    _this.sceneDescList.onselectionchange = function (i) {
                        _this.selectSceneDesc(i);
                    };
                    return _this;
                }
                SceneSelect.prototype.setProgressable = function (p) {
                    var _this = this;
                    this.setLoadProgress(p.progress);
                    p.onProgress = function () {
                        _this.setLoadProgress(p.progress);
                    };
                };
                SceneSelect.prototype.setCurrentDesc = function (sceneGroup, sceneDesc) {
                    this.selectedSceneGroup = sceneGroup;
                    this.currentSceneGroup = sceneGroup;
                    this.currentSceneDesc = sceneDesc;
                    this.syncSceneDescs();
                };
                SceneSelect.prototype.setSceneGroups = function (sceneGroups) {
                    this.sceneGroups = sceneGroups;
                    var strings = this.sceneGroups.filter(function (g) { return g.sceneDescs.length > 0; }).map(function (g) { return g.name; });
                    this.sceneGroupList.setStrings(strings);
                    this.syncSceneDescs();
                };
                SceneSelect.prototype.setLoadProgress = function (pct) {
                    this.loadProgress = pct;
                    this.syncFlairs();
                    this.syncHeaderStyle();
                };
                SceneSelect.prototype.selectSceneDesc = function (i) {
                    this.onscenedescselected(this.selectedSceneGroup, this.sceneDescs[i]);
                };
                SceneSelect.prototype.getLoadingGradient = function () {
                    var pct = Math.round(this.loadProgress * 100) + "%";
                    return "linear-gradient(to right, " + HIGHLIGHT_COLOR + " " + pct + ", transparent " + pct + ")";
                };
                SceneSelect.prototype.syncHeaderStyle = function () {
                    _super.prototype.syncHeaderStyle.call(this);
                    setElementHighlighted(this.header, this.expanded);
                    if (this.expanded)
                        this.header.style.background = HIGHLIGHT_COLOR;
                    else
                        this.header.style.background = this.getLoadingGradient();
                };
                SceneSelect.prototype.syncFlairs = function () {
                    var selectedGroupIndex = this.sceneGroups.indexOf(this.selectedSceneGroup);
                    var flairs = [{ index: selectedGroupIndex, background: HIGHLIGHT_COLOR, color: 'black' }];
                    var currentGroupIndex = this.sceneGroups.indexOf(this.currentSceneGroup);
                    if (currentGroupIndex >= 0)
                        flairs.push({ index: currentGroupIndex, background: '#666' });
                    this.sceneGroupList.setFlairs(flairs);
                    var selectedDescIndex = this.sceneDescs.indexOf(this.currentSceneDesc);
                    if (selectedDescIndex >= 0) {
                        var loadingGradient = this.getLoadingGradient();
                        var textColor = this.loadProgress > 0.5 ? 'black' : undefined;
                        this.sceneDescList.setFlairs([{ index: selectedDescIndex, background: loadingGradient, color: textColor }]);
                    }
                };
                SceneSelect.prototype.selectSceneGroup = function (i) {
                    var sceneGroup = this.sceneGroups[i];
                    this.selectedSceneGroup = sceneGroup;
                    this.syncSceneDescs();
                };
                SceneSelect.prototype.syncSceneDescs = function () {
                    if (this.selectedSceneGroup)
                        this.setSceneDescs(this.selectedSceneGroup.sceneDescs);
                    else if (this.currentSceneGroup)
                        this.setSceneDescs(this.currentSceneGroup.sceneDescs);
                    else
                        this.setSceneDescs([]);
                };
                SceneSelect.prototype.setSceneDescs = function (sceneDescs) {
                    this.sceneDescs = sceneDescs;
                    var strings = sceneDescs.map(function (desc) { return desc.name; });
                    this.sceneDescList.setStrings(strings);
                    this.syncFlairs();
                };
                return SceneSelect;
            }(Panel));
            CHECKERBOARD_IMAGE = 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGElEQVQYlWNgYGCQwoKxgqGgcJA5h3yFAAs8BRWVSwooAAAAAElFTkSuQmCC")';
            TEXTURES_ICON = "<svg viewBox=\"0 0 512 512\" height=\"20\" fill=\"white\"><path d=\"M143.5,143.5v300h300v-300H143.5z M274.8,237.2c10.3,0,18.7,8.4,18.7,18.9c0,10.3-8.4,18.7-18.7,18.7   c-10.3,0-18.7-8.4-18.7-18.7C256,245.6,264.4,237.2,274.8,237.2z M406,406H181v-56.2l56.2-56.1l37.5,37.3l75-74.8l56.2,56.1V406z\"/><polygon points=\"387.2,68.6 68.5,68.6 68.5,368.5 106,368.5 106,106 387.2,106\"/></svg>";
            TextureViewer = /** @class */ (function (_super) {
                __extends(TextureViewer, _super);
                function TextureViewer() {
                    var _this = _super.call(this) || this;
                    _this.textureList = [];
                    _this.setTitle(TEXTURES_ICON, 'Textures');
                    _this.extraRack.style.pointerEvents = 'none';
                    _this.scrollList = new SingleSelect();
                    _this.scrollList.elem.style.height = "200px";
                    _this.scrollList.elem.style.overflow = 'auto';
                    _this.scrollList.onselectionchange = function (i) {
                        _this.selectTexture(i);
                    };
                    _this.contents.appendChild(_this.scrollList.elem);
                    _this.surfaceView = document.createElement('div');
                    _this.surfaceView.style.width = '100%';
                    _this.surfaceView.style.height = '200px';
                    // TODO(jstpierre): Explicit icons.
                    _this.surfaceView.onmouseover = function () {
                        // Checkerboard
                        _this.surfaceView.style.backgroundColor = 'white';
                        _this.surfaceView.style.backgroundImage = CHECKERBOARD_IMAGE;
                    };
                    _this.surfaceView.onmouseout = function () {
                        _this.surfaceView.style.backgroundColor = 'black';
                        _this.surfaceView.style.backgroundImage = '';
                    };
                    _this.surfaceView.onmouseout(null);
                    _this.contents.appendChild(_this.surfaceView);
                    _this.properties = document.createElement('div');
                    _this.contents.appendChild(_this.properties);
                    _this.fullSurfaceView = document.createElement('div');
                    _this.fullSurfaceView.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
                    _this.fullSurfaceView.style.padding = '20px';
                    _this.extraRack.appendChild(_this.fullSurfaceView);
                    return _this;
                }
                TextureViewer.prototype.showInSurfaceView = function (surface) {
                    this.surfaceView.innerHTML = '';
                    surface.style.width = '100%';
                    surface.style.height = '100%';
                    surface.style.objectFit = 'scale-down';
                    this.surfaceView.appendChild(surface);
                };
                TextureViewer.prototype.showInFullSurfaceView = function (surfaces) {
                    this.fullSurfaceView.innerHTML = '';
                    try {
                        for (var surfaces_1 = __values(surfaces), surfaces_1_1 = surfaces_1.next(); !surfaces_1_1.done; surfaces_1_1 = surfaces_1.next()) {
                            var surface = surfaces_1_1.value;
                            var newCanvas = document.createElement('canvas');
                            cloneCanvas(newCanvas, surface);
                            newCanvas.style.display = 'block';
                            newCanvas.style.backgroundColor = 'white';
                            newCanvas.style.backgroundImage = CHECKERBOARD_IMAGE;
                            this.fullSurfaceView.appendChild(newCanvas);
                        }
                    }
                    catch (e_16_1) { e_16 = { error: e_16_1 }; }
                    finally {
                        try {
                            if (surfaces_1_1 && !surfaces_1_1.done && (_a = surfaces_1.return)) _a.call(surfaces_1);
                        }
                        finally { if (e_16) throw e_16.error; }
                    }
                    var e_16, _a;
                };
                TextureViewer.prototype.selectTexture = function (i) {
                    var texture = this.textureList[i];
                    this.scrollList.setHighlighted(i);
                    var properties = new Map();
                    properties.set('Name', texture.name);
                    properties.set('Mipmaps', '' + texture.surfaces.length);
                    properties.set('Width', '' + texture.surfaces[0].width);
                    properties.set('Height', '' + texture.surfaces[0].height);
                    if (texture.extraInfo) {
                        texture.extraInfo.forEach(function (value, key) { return properties.set(key, value); });
                    }
                    this.properties.innerHTML = "<div style=\"display: grid; grid-template-columns: 1fr 1fr\"></div>";
                    var div = this.properties.firstElementChild;
                    properties.forEach(function (value, name) {
                        var nameSpan = document.createElement('span');
                        nameSpan.textContent = name;
                        div.appendChild(nameSpan);
                        var valueSpan = document.createElement('span');
                        valueSpan.style.textAlign = 'right';
                        valueSpan.textContent = value;
                        div.appendChild(valueSpan);
                    });
                    this.showInSurfaceView(texture.surfaces[0]);
                    this.showInFullSurfaceView(texture.surfaces);
                };
                TextureViewer.prototype.setTextureList = function (textures) {
                    this.setVisible(textures.length > 0);
                    if (textures.length === 0)
                        return;
                    var strings = textures.map(function (texture) { return texture.name; });
                    this.scrollList.setStrings(strings);
                    this.textureList = textures;
                };
                return TextureViewer;
            }(Panel));
            exports_17("TextureViewer", TextureViewer);
            FRUSTUM_ICON = "<svg viewBox=\"0 0 100 100\" height=\"20\" fill=\"white\"><polygon points=\"48.2573,19.8589 33.8981,15.0724 5,67.8384 48.2573,90.3684\" /><polygon points=\"51.5652,19.8738 51.5652,90.3734 95,67.8392 65.9366,15.2701\" /><polygon points=\"61.3189,13.2756 49.9911,9.6265 38.5411,13.1331 49.9213,16.9268\" /></svg>";
            ViewerSettings = /** @class */ (function (_super) {
                __extends(ViewerSettings, _super);
                function ViewerSettings(viewer) {
                    var _this = _super.call(this) || this;
                    _this.viewer = viewer;
                    _this.setTitle(FRUSTUM_ICON, 'Viewer Settings');
                    // TODO(jstpierre): make css not leak
                    _this.contents.innerHTML = "\n<style>\n.Slider {\n    -webkit-appearance: none;\n    width: 100%;\n    height: 24px;\n    margin: 0;\n}\n.Slider::-moz-range-thumb {\n    width: 16px;\n    height: 24px;\n    cursor: pointer;\n    background: " + HIGHLIGHT_COLOR + ";\n    border-radius: 0;\n    border: none;\n}\n.Slider::-webkit-slider-thumb {\n    width: 16px;\n    height: 24px;\n    cursor: pointer;\n    background: " + HIGHLIGHT_COLOR + ";\n    border-radius: 0;\n    border: none;\n}\n.Slider::-moz-range-track {\n    height: 24px;\n    cursor: pointer;\n    background: #444;\n}\n.Slider::-webkit-slider-runnable-track {\n    height: 24px;\n    cursor: pointer;\n    background: #444;\n}\n.Slider::-moz-range-progress {\n    height: 24px;\n    cursor: pointer;\n    background: #aaa;\n}\n.SettingsHeader, .CameraControllerWASD, .CameraControllerOrbit {\n    text-align: center;\n    font-weight: bold;\n    line-height: 24px;\n}\n.CameraControllerWASD, .CameraControllerOrbit {\n    background: #444;\n    line-height: 32px;\n    cursor: pointer;\n}\n</style>\n<div class=\"SettingsHeader\">Field of View</div>\n<div><input class=\"Slider FoVSlider\" type=\"range\" min=\"1\" max=\"100\"></div>\n<div class=\"SettingsHeader\">Camera Controller</div>\n<div style=\"display: grid; grid-template-columns: 1fr 1fr;\">\n<div class=\"CameraControllerWASD\">WASD</div><div class=\"CameraControllerOrbit\">Orbit</div>\n</div>\n";
                    _this.fovSlider = _this.contents.querySelector('.FoVSlider');
                    _this.fovSlider.oninput = _this.onFovSliderChange.bind(_this);
                    _this.cameraControllerWASD = _this.contents.querySelector('.CameraControllerWASD');
                    _this.cameraControllerWASD.onclick = function () {
                        _this.setCameraControllerClass(Camera_2.FPSCameraController);
                    };
                    _this.cameraControllerOrbit = _this.contents.querySelector('.CameraControllerOrbit');
                    _this.cameraControllerOrbit.onclick = function () {
                        _this.setCameraControllerClass(Camera_2.OrbitCameraController);
                    };
                    return _this;
                }
                ViewerSettings.prototype._getSliderT = function (slider) {
                    return (+slider.value - +slider.min) / (+slider.max - +slider.min);
                };
                ViewerSettings.prototype.onFovSliderChange = function (e) {
                    var slider = e.target;
                    var value = this._getSliderT(slider);
                    this.viewer.renderState.fov = value * (Math.PI * 0.995);
                };
                ViewerSettings.prototype.setCameraControllerClass = function (cameraControllerClass) {
                    this.viewer.setCameraController(new cameraControllerClass());
                    this.cameraControllerSelected(cameraControllerClass);
                };
                ViewerSettings.prototype.cameraControllerSelected = function (cameraControllerClass) {
                    setElementHighlighted(this.cameraControllerWASD, cameraControllerClass === Camera_2.FPSCameraController);
                    setElementHighlighted(this.cameraControllerOrbit, cameraControllerClass === Camera_2.OrbitCameraController);
                };
                return ViewerSettings;
            }(Panel));
            ABOUT_ICON = "\n<svg viewBox=\"0 0 100 100\" height=\"16\" fill=\"white\"><path d=\"M50,1.1C23,1.1,1.1,23,1.1,50S23,98.9,50,98.9C77,98.9,98.9,77,98.9,50S77,1.1,50,1.1z M55.3,77.7c0,1.7-1.4,3.1-3.1,3.1  h-7.9c-1.7,0-3.1-1.4-3.1-3.1v-5.1c0-1.7,1.4-3.1,3.1-3.1h7.9c1.7,0,3.1,1.4,3.1,3.1V77.7z M67.8,47.3c-2.1,2.9-4.7,5.2-7.9,6.9  c-1.8,1.2-3,2.4-3.6,3.8c-0.4,0.9-0.7,2.1-0.9,3.5c-0.1,1.1-1.1,1.9-2.2,1.9h-9.7c-1.3,0-2.3-1.1-2.2-2.3c0.2-2.7,0.9-4.8,2-6.4  c1.4-1.9,3.9-4.2,7.5-6.7c1.9-1.2,3.3-2.6,4.4-4.3c1.1-1.7,1.6-3.7,1.6-6c0-2.3-0.6-4.2-1.9-5.6c-1.3-1.4-3-2.1-5.3-2.1  c-1.9,0-3.4,0.6-4.7,1.7c-0.8,0.7-1.3,1.6-1.6,2.8c-0.4,1.4-1.7,2.3-3.2,2.3l-9-0.2c-1.1,0-2-1-1.9-2.1c0.3-4.8,2.2-8.4,5.5-11  c3.8-2.9,8.7-4.4,14.9-4.4c6.6,0,11.8,1.7,15.6,5c3.8,3.3,5.7,7.8,5.7,13.5C70.9,41.2,69.8,44.4,67.8,47.3z\"/></svg>";
            About = /** @class */ (function (_super) {
                __extends(About, _super);
                function About() {
                    var _this = _super.call(this) || this;
                    _this.setTitle(ABOUT_ICON, 'About');
                    _this.contents.innerHTML = "\n<div id=\"About\">\n<style>\n#About {\n    padding: 12px;\n    line-height: 1.2;\n}\n#About a {\n    color: white;\n}\n#About li span {\n    color: #aaa;\n}\n#About h2 {\n    vertical-align: middle;\n    font-size: 2em;\n    text-align: center;\n    margin: 0px;\n}\n</style>\n\n<h2><img style=\"vertical-align: middle;\" src=\"logo.png\">MODEL VIEWER</h2>\n\n<p> <strong>CLICK AND DRAG</strong> to look around and use <strong>WASD</strong> to move the camera </p>\n<p> Hold <strong>SHIFT</strong> to go faster, and use <strong>MOUSE WHEEL</strong> to go faster than that.\n<strong>B</strong> resets the camera, and <strong>Z</strong> toggles the UI. </p>\n\n<p><strong>CODE PRIMARILY WRITTEN</strong> by <a href=\"https://github.com/magcius\">Jasper</a></p>\n\n<p><strong>MODELS</strong> \u00A9 Nintendo, SEGA, Retro Studios, FROM Software, Konami</p>\n\n<p><strong>CODE HELP AND FRIENDSHIP</strong> from\n<a href=\"https://twitter.com/beholdnec\">N.E.C.</a>,\n<a href=\"https://twitter.com/LordNed\">LordNed</a>,\n<a href=\"https://twitter.com/SageOfMirrors\">SageOfMirrors</a>,\n<a href=\"https://github.com/blank63\">blank63</a>,\n<a href=\"https://twitter.com/StapleButter\">StapleButter</a>,\n<a href=\"https://twitter.com/xdanieldzd\">xdanieldzd</a>,\n<a href=\"https://github.com/vlad001\">vlad001</a>,\n<a href=\"https://twitter.com/Jewelots_\">Jewel</a>,\n<a href=\"https://twitter.com/instant_grat\">Instant Grat</a>,\nand <a href=\"https://twitter.com/__Aruki\">Aruki</a></p>\n\n<p><strong>ICONS</strong> from <a href=\"https://thenounproject.com/\">The Noun Project</a>, used under Creative Commons CC-BY:</p>\n<ul>\n<li> Truncated Pyramid <span>by</span> Bohdan Burmich\n<li> Images <span>by</span> Creative Stall\n<li> Help <span>by</span> Gregor Cresnar\n<li> Open <span>by</span> Landan Lloyd\n<li> Nightshift <span>by</span> mikicon\n<li> Layer <span>by</span> Chameleon Design\n<li> Sand Clock <span>by</span> James\n</ul>\n</div>\n";
                    return _this;
                }
                return About;
            }(Panel));
            LAYER_ICON = "<svg viewBox=\"0 0 16 16\" height=\"20\" fill=\"white\"><g transform=\"translate(0,-1036.3622)\"><path d=\"m 8,1039.2486 -0.21875,0.125 -4.90625,2.4375 5.125,2.5625 5.125,-2.5625 L 8,1039.2486 z m -3,4.5625 -2.125,0.9688 5.125,2.5625 5.125,-2.5625 -2.09375,-0.9688 -3.03125,1.5 -1,-0.5 -0.90625,-0.4375 L 5,1043.8111 z m 0,3 -2.125,0.9688 5.125,2.5625 5.125,-2.5625 -2.09375,-0.9688 -3.03125,1.5 -1,-0.5 -0.90625,-0.4375 L 5,1046.8111 z\"/></g></svg>";
            LayerPanel = /** @class */ (function (_super) {
                __extends(LayerPanel, _super);
                function LayerPanel() {
                    var _this = _super.call(this) || this;
                    _this.setTitle(LAYER_ICON, 'Layers');
                    _this.multiSelect = new MultiSelect();
                    _this.multiSelect.onitemchanged = _this._onItemChanged.bind(_this);
                    _this.contents.appendChild(_this.multiSelect.elem);
                    return _this;
                }
                LayerPanel.prototype._onItemChanged = function (index, visible) {
                    this.layers[index].setVisible(visible);
                };
                LayerPanel.prototype.syncLayerVisibility = function () {
                    var isOn = this.layers.map(function (layer) { return layer.visible; });
                    this.multiSelect.setItemsSelected(isOn);
                };
                LayerPanel.prototype.setLayers = function (layers) {
                    this.layers = layers;
                    var strings = layers.map(function (layer) { return layer.name; });
                    this.multiSelect.setStrings(strings);
                    this.syncLayerVisibility();
                };
                return LayerPanel;
            }(Panel));
            exports_17("LayerPanel", LayerPanel);
            UI = /** @class */ (function () {
                function UI(viewer) {
                    this.viewer = viewer;
                    this.toplevel = document.createElement('div');
                    this.toplevel.style.display = 'grid';
                    this.toplevel.style.gridTemplateColumns = '1fr';
                    this.toplevel.style.gridGap = '20px';
                    this.toplevel.style.pointerEvents = 'none';
                    this.sceneSelect = new SceneSelect(viewer);
                    this.textureViewer = new TextureViewer();
                    this.viewerSettings = new ViewerSettings(viewer);
                    this.about = new About();
                    this.setScenePanels([]);
                    this.elem = this.toplevel;
                }
                UI.prototype.sceneChanged = function () {
                    var scene = this.viewer.scene;
                    var cameraControllerClass = this.viewer.cameraController.constructor;
                    // Set up UI.
                    this.viewerSettings.cameraControllerSelected(cameraControllerClass);
                    this.textureViewer.setTextureList(scene !== null ? scene.textures : []);
                };
                UI.prototype.setPanels = function (panels) {
                    this.toplevel.innerHTML = '';
                    try {
                        for (var panels_1 = __values(panels), panels_1_1 = panels_1.next(); !panels_1_1.done; panels_1_1 = panels_1.next()) {
                            var panel = panels_1_1.value;
                            this.toplevel.appendChild(panel.elem);
                        }
                    }
                    catch (e_17_1) { e_17 = { error: e_17_1 }; }
                    finally {
                        try {
                            if (panels_1_1 && !panels_1_1.done && (_a = panels_1.return)) _a.call(panels_1);
                        }
                        finally { if (e_17) throw e_17.error; }
                    }
                    var e_17, _a;
                };
                UI.prototype.setScenePanels = function (panels) {
                    this.setPanels(__spread([this.sceneSelect], panels, [this.textureViewer, this.viewerSettings, this.about]));
                };
                return UI;
            }());
            exports_17("UI", UI);
        }
    };
});
// tslint:disable:no-console
System.register("viewer", ["render", "InputManager"], function (exports_18, context_18) {
    "use strict";
    var __moduleName = context_18 && context_18.id;
    var render_1, InputManager_1, Viewer;
    return {
        setters: [
            function (render_1_1) {
                render_1 = render_1_1;
            },
            function (InputManager_1_1) {
                InputManager_1 = InputManager_1_1;
            }
        ],
        execute: function () {
            Viewer = /** @class */ (function () {
                function Viewer(canvas) {
                    this.canvas = canvas;
                    this.onscreenColorTarget = new render_1.ColorTarget();
                    this.onscreenDepthTarget = new render_1.DepthTarget();
                    this.oncamerachanged = (function () { });
                    var gl = canvas.getContext("webgl2", { alpha: false, antialias: false });
                    this.renderState = new render_1.RenderState(gl);
                    this.inputManager = new InputManager_1.InputManager(this.canvas);
                    this.cameraController = null;
                }
                Viewer.prototype.reset = function () {
                    var gl = this.renderState.gl;
                    gl.activeTexture(gl.TEXTURE0);
                    gl.clearColor(0.88, 0.88, 0.88, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                };
                Viewer.prototype.render = function () {
                    var gl = this.renderState.gl;
                    if (!this.scene)
                        return;
                    this.onscreenColorTarget.setParameters(gl, this.canvas.width, this.canvas.height);
                    this.onscreenDepthTarget.setParameters(gl, this.canvas.width, this.canvas.height);
                    this.renderState.setOnscreenRenderTarget(this.onscreenColorTarget, this.onscreenDepthTarget);
                    this.renderState.reset();
                    this.renderState.setClipPlanes(10, 50000);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    // Main scene. This renders to the onscreen target.
                    this.scene.render(this.renderState);
                    // Blit to the screen.
                    this.renderState.blitOnscreenToGL();
                    var frameEndTime = window.performance.now();
                    var diff = frameEndTime - this.renderState.frameStartTime;
                    // console.log(`Time: ${diff} Draw calls: ${state.drawCallCount}`);
                };
                Viewer.prototype.setCameraController = function (cameraController) {
                    this.cameraController = cameraController;
                    this.cameraController.camera = this.renderState.camera;
                };
                Viewer.prototype.setScene = function (scene) {
                    var gl = this.renderState.gl;
                    this.reset();
                    if (this.scene) {
                        this.scene.destroy(gl);
                    }
                    if (scene) {
                        this.scene = scene;
                        this.oncamerachanged();
                    }
                    else {
                        this.scene = null;
                    }
                };
                Viewer.prototype.start = function () {
                    var _this = this;
                    var canvas = this.canvas;
                    var t = 0;
                    var update = function (nt) {
                        var dt = nt - t;
                        t = nt;
                        if (_this.cameraController) {
                            var updated = _this.cameraController.update(_this.inputManager, dt);
                            if (updated)
                                _this.oncamerachanged();
                        }
                        _this.inputManager.resetMouse();
                        _this.renderState.time += dt;
                        _this.render();
                        window.requestAnimationFrame(update);
                    };
                    update(0);
                };
                return Viewer;
            }());
            exports_18("Viewer", Viewer);
        }
    };
});
// Generated by build_wat.js
System.register("wat_modules", [], function (exports_19, context_19) {
    "use strict";
    var __moduleName = context_19 && context_19.id;
    function yaz0_asInstance(imports) {
        return WebAssembly.compile(yaz0_asCode).then(function (module) {
            return WebAssembly.instantiate(module, imports);
        }).then(function (instance) {
            return instance.exports;
        });
    }
    exports_19("yaz0_asInstance", yaz0_asInstance);
    function gx_texture_asInstance(imports) {
        return WebAssembly.compile(gx_texture_asCode).then(function (module) {
            return WebAssembly.instantiate(module, imports);
        }).then(function (instance) {
            return instance.exports;
        });
    }
    exports_19("gx_texture_asInstance", gx_texture_asInstance);
    var yaz0_asCode, gx_texture_asCode;
    return {
        setters: [],
        execute: function () {
            yaz0_asCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 11, 2, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 6, 6, 1, 127, 0, 65, 4, 11, 7, 23, 2, 10, 100, 101, 99, 111, 109, 112, 114, 101, 115, 115, 0, 0, 6, 109, 101, 109, 111, 114, 121, 2, 0, 10, 178, 3, 1, 175, 3, 1, 17, 127, 32, 0, 33, 3, 32, 1, 33, 4, 2, 64, 3, 64, 65, 1, 4, 64, 2, 64, 2, 64, 2, 127, 2, 127, 32, 4, 33, 5, 32, 5, 65, 1, 106, 33, 4, 32, 5, 11, 33, 5, 32, 5, 45, 0, 0, 12, 0, 11, 33, 6, 65, 8, 33, 7, 2, 64, 3, 64, 2, 127, 32, 7, 33, 8, 32, 8, 65, 1, 107, 33, 7, 32, 8, 11, 65, 255, 1, 113, 4, 64, 2, 64, 2, 64, 32, 6, 65, 1, 32, 7, 116, 113, 65, 255, 1, 113, 4, 64, 2, 64, 32, 2, 65, 1, 107, 33, 2, 2, 64, 2, 127, 32, 3, 33, 8, 32, 8, 65, 1, 106, 33, 3, 32, 8, 11, 33, 8, 2, 127, 2, 127, 32, 4, 33, 9, 32, 9, 65, 1, 106, 33, 4, 32, 9, 11, 33, 9, 32, 9, 45, 0, 0, 12, 0, 11, 33, 10, 32, 8, 32, 10, 58, 0, 0, 11, 11, 5, 2, 64, 2, 127, 32, 4, 45, 0, 0, 65, 8, 116, 32, 4, 65, 1, 106, 45, 0, 0, 114, 65, 255, 255, 3, 113, 12, 0, 11, 33, 11, 32, 4, 65, 2, 106, 33, 4, 32, 11, 65, 255, 31, 113, 65, 1, 106, 33, 12, 32, 11, 65, 255, 255, 3, 113, 65, 12, 118, 65, 2, 106, 65, 255, 1, 113, 33, 13, 32, 13, 65, 2, 70, 4, 64, 2, 64, 2, 127, 2, 127, 32, 4, 33, 14, 32, 14, 65, 1, 106, 33, 4, 32, 14, 11, 33, 14, 32, 14, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 15, 32, 13, 32, 15, 65, 16, 106, 106, 33, 13, 11, 11, 32, 3, 32, 12, 65, 255, 255, 3, 113, 107, 33, 16, 32, 2, 32, 13, 107, 33, 2, 2, 64, 3, 64, 2, 127, 32, 13, 33, 17, 32, 17, 65, 1, 107, 33, 13, 32, 17, 11, 65, 255, 255, 3, 113, 4, 64, 2, 64, 2, 64, 2, 127, 32, 3, 33, 17, 32, 17, 65, 1, 106, 33, 3, 32, 17, 11, 33, 17, 2, 127, 2, 127, 32, 16, 33, 18, 32, 18, 65, 1, 106, 33, 16, 32, 18, 11, 33, 18, 32, 18, 45, 0, 0, 12, 0, 11, 33, 19, 32, 17, 32, 19, 58, 0, 0, 11, 12, 2, 11, 11, 11, 11, 11, 11, 32, 2, 65, 0, 76, 4, 64, 15, 11, 11, 12, 2, 11, 11, 11, 11, 11, 12, 2, 11, 11, 11, 11, 11]);
            gx_texture_asCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 5, 127, 127, 127, 127, 127, 0, 96, 0, 1, 127, 3, 9, 8, 0, 0, 0, 0, 0, 0, 0, 0, 5, 3, 1, 0, 1, 6, 6, 1, 127, 0, 65, 4, 11, 7, 121, 9, 9, 100, 101, 99, 111, 100, 101, 95, 73, 52, 0, 0, 9, 100, 101, 99, 111, 100, 101, 95, 73, 56, 0, 1, 10, 100, 101, 99, 111, 100, 101, 95, 73, 65, 52, 0, 2, 10, 100, 101, 99, 111, 100, 101, 95, 73, 65, 56, 0, 3, 13, 100, 101, 99, 111, 100, 101, 95, 82, 71, 66, 53, 54, 53, 0, 4, 13, 100, 101, 99, 111, 100, 101, 95, 82, 71, 66, 53, 65, 51, 0, 5, 12, 100, 101, 99, 111, 100, 101, 95, 82, 71, 66, 65, 56, 0, 6, 11, 100, 101, 99, 111, 100, 101, 95, 67, 77, 80, 82, 0, 7, 6, 109, 101, 109, 111, 114, 121, 2, 0, 10, 166, 36, 8, 178, 2, 1, 15, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 8, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 8, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 65, 1, 118, 106, 33, 12, 32, 12, 45, 0, 0, 12, 0, 11, 33, 13, 32, 13, 65, 255, 1, 113, 32, 5, 65, 1, 113, 4, 127, 65, 0, 5, 65, 4, 11, 118, 65, 15, 113, 33, 14, 2, 127, 32, 14, 65, 4, 116, 32, 14, 114, 65, 255, 1, 113, 12, 0, 11, 33, 15, 2, 64, 32, 11, 65, 0, 106, 33, 16, 32, 16, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 17, 32, 17, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 18, 32, 18, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 19, 32, 19, 32, 15, 58, 0, 0, 11, 32, 5, 65, 1, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 8, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 8, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 131, 2, 1, 13, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 8, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 106, 33, 12, 32, 12, 45, 0, 0, 12, 0, 11, 33, 13, 2, 64, 32, 11, 65, 0, 106, 33, 14, 32, 14, 32, 13, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 15, 32, 15, 32, 13, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 16, 32, 16, 32, 13, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 17, 32, 17, 32, 13, 58, 0, 0, 11, 32, 5, 65, 1, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 8, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 187, 2, 1, 17, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 8, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 106, 33, 12, 32, 12, 45, 0, 0, 12, 0, 11, 33, 13, 2, 127, 32, 13, 65, 255, 1, 113, 65, 4, 118, 33, 14, 32, 14, 65, 4, 116, 32, 14, 114, 65, 255, 1, 113, 12, 0, 11, 33, 15, 2, 127, 32, 13, 65, 15, 113, 33, 16, 32, 16, 65, 4, 116, 32, 16, 114, 65, 255, 1, 113, 12, 0, 11, 33, 17, 2, 64, 32, 11, 65, 0, 106, 33, 18, 32, 18, 32, 17, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 19, 32, 19, 32, 17, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 20, 32, 20, 32, 17, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 21, 32, 21, 32, 15, 58, 0, 0, 11, 32, 5, 65, 1, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 8, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 156, 2, 1, 15, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 4, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 106, 65, 0, 106, 33, 12, 32, 12, 45, 0, 0, 12, 0, 11, 33, 13, 2, 127, 32, 2, 32, 5, 106, 65, 1, 106, 33, 14, 32, 14, 45, 0, 0, 12, 0, 11, 33, 15, 2, 64, 32, 11, 65, 0, 106, 33, 16, 32, 16, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 17, 32, 17, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 18, 32, 18, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 19, 32, 19, 32, 13, 58, 0, 0, 11, 32, 5, 65, 2, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 4, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 146, 3, 1, 20, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 4, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 106, 33, 12, 32, 12, 45, 0, 0, 65, 8, 116, 32, 12, 65, 1, 106, 45, 0, 0, 114, 65, 255, 255, 3, 113, 12, 0, 11, 33, 13, 2, 64, 32, 11, 65, 0, 106, 33, 14, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 11, 118, 65, 31, 113, 33, 15, 32, 15, 65, 8, 65, 5, 107, 116, 32, 15, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 16, 32, 14, 32, 16, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 17, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 5, 118, 65, 63, 113, 33, 18, 32, 18, 65, 8, 65, 6, 107, 116, 32, 18, 65, 12, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 19, 32, 17, 32, 19, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 20, 2, 127, 32, 13, 65, 31, 113, 33, 21, 32, 21, 65, 8, 65, 5, 107, 116, 32, 21, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 22, 32, 20, 32, 22, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 23, 65, 255, 1, 33, 24, 32, 23, 32, 24, 58, 0, 0, 11, 32, 5, 65, 2, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 4, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 250, 4, 1, 32, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 4, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 106, 33, 12, 32, 12, 45, 0, 0, 65, 8, 116, 32, 12, 65, 1, 106, 45, 0, 0, 114, 65, 255, 255, 3, 113, 12, 0, 11, 33, 13, 32, 13, 65, 128, 128, 2, 113, 4, 64, 2, 64, 2, 64, 32, 11, 65, 0, 106, 33, 14, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 10, 118, 65, 31, 113, 33, 15, 32, 15, 65, 8, 65, 5, 107, 116, 32, 15, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 16, 32, 14, 32, 16, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 17, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 5, 118, 65, 31, 113, 33, 18, 32, 18, 65, 8, 65, 5, 107, 116, 32, 18, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 19, 32, 17, 32, 19, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 20, 2, 127, 32, 13, 65, 31, 113, 33, 21, 32, 21, 65, 8, 65, 5, 107, 116, 32, 21, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 22, 32, 20, 32, 22, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 23, 65, 255, 1, 33, 24, 32, 23, 32, 24, 58, 0, 0, 11, 11, 5, 2, 64, 2, 64, 32, 11, 65, 0, 106, 33, 25, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 8, 118, 65, 15, 113, 33, 26, 32, 26, 65, 4, 116, 32, 26, 114, 65, 255, 1, 113, 12, 0, 11, 33, 27, 32, 25, 32, 27, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 28, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 4, 118, 65, 15, 113, 33, 29, 32, 29, 65, 4, 116, 32, 29, 114, 65, 255, 1, 113, 12, 0, 11, 33, 30, 32, 28, 32, 30, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 31, 2, 127, 32, 13, 65, 15, 113, 33, 32, 32, 32, 65, 4, 116, 32, 32, 114, 65, 255, 1, 113, 12, 0, 11, 33, 33, 32, 31, 32, 33, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 34, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 12, 118, 33, 35, 32, 35, 65, 8, 65, 3, 107, 116, 32, 35, 65, 8, 65, 6, 107, 116, 114, 32, 35, 65, 255, 1, 113, 65, 9, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 36, 32, 34, 32, 36, 58, 0, 0, 11, 11, 11, 32, 5, 65, 2, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 4, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 163, 3, 1, 23, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 4, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 106, 108, 32, 7, 106, 32, 9, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 64, 32, 11, 65, 3, 106, 33, 12, 2, 127, 32, 2, 32, 5, 106, 65, 0, 106, 33, 13, 32, 13, 45, 0, 0, 12, 0, 11, 33, 14, 32, 12, 32, 14, 58, 0, 0, 11, 2, 64, 32, 11, 65, 0, 106, 33, 15, 2, 127, 32, 2, 32, 5, 106, 65, 1, 106, 33, 16, 32, 16, 45, 0, 0, 12, 0, 11, 33, 17, 32, 15, 32, 17, 58, 0, 0, 11, 32, 5, 65, 2, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 2, 64, 65, 0, 33, 18, 3, 64, 32, 18, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 19, 3, 64, 32, 19, 65, 4, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 18, 106, 108, 32, 7, 106, 32, 19, 106, 33, 20, 32, 1, 32, 20, 65, 4, 108, 106, 33, 21, 2, 64, 32, 21, 65, 1, 106, 33, 22, 2, 127, 32, 2, 32, 5, 106, 65, 0, 106, 33, 23, 32, 23, 45, 0, 0, 12, 0, 11, 33, 24, 32, 22, 32, 24, 58, 0, 0, 11, 2, 64, 32, 21, 65, 2, 106, 33, 25, 2, 127, 32, 2, 32, 5, 106, 65, 1, 106, 33, 26, 32, 26, 45, 0, 0, 12, 0, 11, 33, 27, 32, 25, 32, 27, 58, 0, 0, 11, 32, 5, 65, 2, 106, 33, 5, 11, 32, 19, 65, 1, 106, 33, 19, 12, 2, 11, 11, 11, 11, 32, 18, 65, 1, 106, 33, 18, 12, 2, 11, 11, 11, 11, 11, 32, 7, 65, 4, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 218, 15, 1, 131, 1, 127, 32, 0, 33, 5, 32, 2, 33, 6, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 8, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 10, 3, 64, 32, 10, 65, 8, 73, 4, 64, 2, 64, 2, 64, 2, 127, 32, 6, 65, 0, 106, 33, 11, 32, 11, 45, 0, 0, 65, 8, 116, 32, 11, 65, 1, 106, 45, 0, 0, 114, 65, 255, 255, 3, 113, 12, 0, 11, 33, 12, 2, 127, 32, 6, 65, 2, 106, 33, 13, 32, 13, 45, 0, 0, 65, 8, 116, 32, 13, 65, 1, 106, 45, 0, 0, 114, 65, 255, 255, 3, 113, 12, 0, 11, 33, 14, 2, 64, 32, 5, 65, 0, 106, 33, 15, 2, 127, 32, 12, 65, 255, 255, 3, 113, 65, 11, 118, 65, 31, 113, 33, 16, 32, 16, 65, 8, 65, 5, 107, 116, 32, 16, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 17, 32, 15, 32, 17, 58, 0, 0, 11, 2, 64, 32, 5, 65, 1, 106, 33, 18, 2, 127, 32, 12, 65, 255, 255, 3, 113, 65, 5, 118, 65, 63, 113, 33, 19, 32, 19, 65, 8, 65, 6, 107, 116, 32, 19, 65, 12, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 20, 32, 18, 32, 20, 58, 0, 0, 11, 2, 64, 32, 5, 65, 2, 106, 33, 21, 2, 127, 32, 12, 65, 31, 113, 33, 22, 32, 22, 65, 8, 65, 5, 107, 116, 32, 22, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 23, 32, 21, 32, 23, 58, 0, 0, 11, 2, 64, 32, 5, 65, 3, 106, 33, 24, 65, 255, 1, 33, 25, 32, 24, 32, 25, 58, 0, 0, 11, 2, 64, 32, 5, 65, 4, 106, 33, 26, 2, 127, 32, 14, 65, 255, 255, 3, 113, 65, 11, 118, 65, 31, 113, 33, 27, 32, 27, 65, 8, 65, 5, 107, 116, 32, 27, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 28, 32, 26, 32, 28, 58, 0, 0, 11, 2, 64, 32, 5, 65, 5, 106, 33, 29, 2, 127, 32, 14, 65, 255, 255, 3, 113, 65, 5, 118, 65, 63, 113, 33, 30, 32, 30, 65, 8, 65, 6, 107, 116, 32, 30, 65, 12, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 31, 32, 29, 32, 31, 58, 0, 0, 11, 2, 64, 32, 5, 65, 6, 106, 33, 32, 2, 127, 32, 14, 65, 31, 113, 33, 33, 32, 33, 65, 8, 65, 5, 107, 116, 32, 33, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 34, 32, 32, 32, 34, 58, 0, 0, 11, 2, 64, 32, 5, 65, 7, 106, 33, 35, 65, 255, 1, 33, 36, 32, 35, 32, 36, 58, 0, 0, 11, 32, 12, 65, 255, 255, 3, 113, 32, 14, 65, 255, 255, 3, 113, 75, 4, 64, 2, 64, 2, 64, 32, 5, 65, 8, 106, 33, 37, 2, 127, 2, 127, 32, 5, 65, 4, 106, 33, 38, 32, 38, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 39, 2, 127, 32, 5, 65, 0, 106, 33, 40, 32, 40, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 41, 32, 39, 65, 1, 116, 32, 39, 106, 32, 41, 65, 2, 116, 32, 41, 106, 106, 65, 3, 118, 33, 42, 32, 42, 65, 255, 1, 113, 12, 0, 11, 33, 43, 32, 37, 32, 43, 58, 0, 0, 11, 2, 64, 32, 5, 65, 9, 106, 33, 44, 2, 127, 2, 127, 32, 5, 65, 5, 106, 33, 45, 32, 45, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 46, 2, 127, 32, 5, 65, 1, 106, 33, 47, 32, 47, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 48, 32, 46, 65, 1, 116, 32, 46, 106, 32, 48, 65, 2, 116, 32, 48, 106, 106, 65, 3, 118, 33, 49, 32, 49, 65, 255, 1, 113, 12, 0, 11, 33, 50, 32, 44, 32, 50, 58, 0, 0, 11, 2, 64, 32, 5, 65, 10, 106, 33, 51, 2, 127, 2, 127, 32, 5, 65, 6, 106, 33, 52, 32, 52, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 53, 2, 127, 32, 5, 65, 2, 106, 33, 54, 32, 54, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 55, 32, 53, 65, 1, 116, 32, 53, 106, 32, 55, 65, 2, 116, 32, 55, 106, 106, 65, 3, 118, 33, 56, 32, 56, 65, 255, 1, 113, 12, 0, 11, 33, 57, 32, 51, 32, 57, 58, 0, 0, 11, 2, 64, 32, 5, 65, 11, 106, 33, 58, 65, 255, 1, 33, 59, 32, 58, 32, 59, 58, 0, 0, 11, 2, 64, 32, 5, 65, 12, 106, 33, 60, 2, 127, 2, 127, 32, 5, 65, 0, 106, 33, 61, 32, 61, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 62, 2, 127, 32, 5, 65, 4, 106, 33, 63, 32, 63, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 64, 32, 62, 65, 1, 116, 32, 62, 106, 32, 64, 65, 2, 116, 32, 64, 106, 106, 65, 3, 118, 33, 65, 32, 65, 65, 255, 1, 113, 12, 0, 11, 33, 66, 32, 60, 32, 66, 58, 0, 0, 11, 2, 64, 32, 5, 65, 13, 106, 33, 67, 2, 127, 2, 127, 32, 5, 65, 1, 106, 33, 68, 32, 68, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 69, 2, 127, 32, 5, 65, 5, 106, 33, 70, 32, 70, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 71, 32, 69, 65, 1, 116, 32, 69, 106, 32, 71, 65, 2, 116, 32, 71, 106, 106, 65, 3, 118, 33, 72, 32, 72, 65, 255, 1, 113, 12, 0, 11, 33, 73, 32, 67, 32, 73, 58, 0, 0, 11, 2, 64, 32, 5, 65, 14, 106, 33, 74, 2, 127, 2, 127, 32, 5, 65, 2, 106, 33, 75, 32, 75, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 76, 2, 127, 32, 5, 65, 6, 106, 33, 77, 32, 77, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 78, 32, 76, 65, 1, 116, 32, 76, 106, 32, 78, 65, 2, 116, 32, 78, 106, 106, 65, 3, 118, 33, 79, 32, 79, 65, 255, 1, 113, 12, 0, 11, 33, 80, 32, 74, 32, 80, 58, 0, 0, 11, 2, 64, 32, 5, 65, 15, 106, 33, 81, 65, 255, 1, 33, 82, 32, 81, 32, 82, 58, 0, 0, 11, 11, 5, 2, 64, 2, 64, 32, 5, 65, 8, 106, 33, 83, 2, 127, 2, 127, 32, 5, 65, 0, 106, 33, 84, 32, 84, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 85, 2, 127, 32, 5, 65, 4, 106, 33, 86, 32, 86, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 87, 32, 85, 32, 87, 106, 65, 1, 118, 33, 88, 32, 88, 65, 255, 1, 113, 12, 0, 11, 33, 89, 32, 83, 32, 89, 58, 0, 0, 11, 2, 64, 32, 5, 65, 9, 106, 33, 90, 2, 127, 2, 127, 32, 5, 65, 1, 106, 33, 91, 32, 91, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 92, 2, 127, 32, 5, 65, 5, 106, 33, 93, 32, 93, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 94, 32, 92, 32, 94, 106, 65, 1, 118, 33, 95, 32, 95, 65, 255, 1, 113, 12, 0, 11, 33, 96, 32, 90, 32, 96, 58, 0, 0, 11, 2, 64, 32, 5, 65, 10, 106, 33, 97, 2, 127, 2, 127, 32, 5, 65, 2, 106, 33, 98, 32, 98, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 99, 2, 127, 32, 5, 65, 6, 106, 33, 100, 32, 100, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 101, 32, 99, 32, 101, 106, 65, 1, 118, 33, 102, 32, 102, 65, 255, 1, 113, 12, 0, 11, 33, 103, 32, 97, 32, 103, 58, 0, 0, 11, 2, 64, 32, 5, 65, 11, 106, 33, 104, 65, 255, 1, 33, 105, 32, 104, 32, 105, 58, 0, 0, 11, 2, 64, 32, 5, 65, 12, 106, 33, 106, 2, 127, 32, 5, 65, 8, 106, 33, 107, 32, 107, 45, 0, 0, 12, 0, 11, 33, 108, 32, 106, 32, 108, 58, 0, 0, 11, 2, 64, 32, 5, 65, 13, 106, 33, 109, 2, 127, 32, 5, 65, 9, 106, 33, 110, 32, 110, 45, 0, 0, 12, 0, 11, 33, 111, 32, 109, 32, 111, 58, 0, 0, 11, 2, 64, 32, 5, 65, 14, 106, 33, 112, 2, 127, 32, 5, 65, 10, 106, 33, 113, 32, 113, 45, 0, 0, 12, 0, 11, 33, 114, 32, 112, 32, 114, 58, 0, 0, 11, 2, 64, 32, 5, 65, 15, 106, 33, 115, 65, 0, 33, 116, 32, 115, 32, 116, 58, 0, 0, 11, 11, 11, 2, 64, 65, 0, 33, 117, 3, 64, 32, 117, 65, 4, 72, 4, 64, 2, 64, 2, 64, 2, 127, 32, 6, 65, 4, 106, 32, 117, 106, 33, 118, 32, 118, 45, 0, 0, 12, 0, 11, 33, 119, 2, 64, 65, 0, 33, 120, 3, 64, 32, 120, 65, 4, 72, 4, 64, 2, 64, 2, 64, 32, 7, 32, 9, 106, 32, 117, 106, 32, 3, 108, 32, 8, 106, 32, 10, 106, 32, 120, 106, 33, 121, 32, 1, 32, 121, 65, 4, 108, 106, 33, 122, 32, 119, 65, 255, 1, 113, 65, 6, 118, 65, 3, 113, 33, 123, 2, 64, 32, 122, 65, 0, 106, 33, 124, 2, 127, 32, 5, 32, 123, 65, 4, 108, 65, 255, 1, 113, 106, 65, 0, 106, 33, 125, 32, 125, 45, 0, 0, 12, 0, 11, 33, 126, 32, 124, 32, 126, 58, 0, 0, 11, 2, 64, 32, 122, 65, 1, 106, 33, 127, 2, 127, 32, 5, 32, 123, 65, 4, 108, 65, 255, 1, 113, 106, 65, 1, 106, 33, 128, 1, 32, 128, 1, 45, 0, 0, 12, 0, 11, 33, 129, 1, 32, 127, 32, 129, 1, 58, 0, 0, 11, 2, 64, 32, 122, 65, 2, 106, 33, 130, 1, 2, 127, 32, 5, 32, 123, 65, 4, 108, 65, 255, 1, 113, 106, 65, 2, 106, 33, 131, 1, 32, 131, 1, 45, 0, 0, 12, 0, 11, 33, 132, 1, 32, 130, 1, 32, 132, 1, 58, 0, 0, 11, 2, 64, 32, 122, 65, 3, 106, 33, 133, 1, 2, 127, 32, 5, 32, 123, 65, 4, 108, 65, 255, 1, 113, 106, 65, 3, 106, 33, 134, 1, 32, 134, 1, 45, 0, 0, 12, 0, 11, 33, 135, 1, 32, 133, 1, 32, 135, 1, 58, 0, 0, 11, 32, 119, 65, 2, 116, 33, 119, 11, 32, 120, 65, 1, 106, 33, 120, 12, 2, 11, 11, 11, 11, 11, 32, 117, 65, 1, 106, 33, 117, 12, 2, 11, 11, 11, 11, 32, 6, 65, 8, 106, 33, 6, 11, 32, 10, 65, 4, 106, 33, 10, 12, 2, 11, 11, 11, 11, 32, 9, 65, 4, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 8, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 8, 106, 33, 7, 12, 2, 11, 11, 11, 11, 11]);
        }
    };
});
// Nintendo Yaz0 format.
System.register("compression/Yaz0", ["util", "wat_modules", "ArrayBufferSlice", "WasmMemoryManager"], function (exports_20, context_20) {
    "use strict";
    var __moduleName = context_20 && context_20.id;
    function decompress(srcBuffer) {
        return _wasmInstance.then(function (wasmInstance) {
            var srcView = srcBuffer.createDataView();
            util_9.assert(util_9.readString(srcBuffer, 0x00, 0x04) === 'Yaz0');
            var dstSize = srcView.getUint32(0x04, false);
            var srcSize = srcBuffer.byteLength;
            var pDst = 0;
            var pSrc = util_9.align(dstSize, 0x10);
            var heapSize = pSrc + util_9.align(srcSize, 0x10);
            var wasmMemory = new WasmMemoryManager_1.default(wasmInstance.memory);
            var heap = wasmMemory.resize(heapSize);
            // Copy src buffer.
            heap.set(srcBuffer.createTypedArray(Uint8Array, 0x10), pSrc);
            wasmInstance.decompress(pDst, pSrc, dstSize);
            // Copy the result buffer to a new buffer for memory usage purposes.
            var result = new ArrayBufferSlice_2.default(heap.buffer).copyToSlice(pDst, dstSize);
            return result;
        });
    }
    exports_20("decompress", decompress);
    var util_9, wat_modules_1, ArrayBufferSlice_2, WasmMemoryManager_1, _wasmInstance;
    return {
        setters: [
            function (util_9_1) {
                util_9 = util_9_1;
            },
            function (wat_modules_1_1) {
                wat_modules_1 = wat_modules_1_1;
            },
            function (ArrayBufferSlice_2_1) {
                ArrayBufferSlice_2 = ArrayBufferSlice_2_1;
            },
            function (WasmMemoryManager_1_1) {
                WasmMemoryManager_1 = WasmMemoryManager_1_1;
            }
        ],
        execute: function () {
            // XXX(jstpierre): Firefox has GC pressure when constructing new WebAssembly.Memory instances
            // on 64-bit machines. Construct a global WebAssembly.Memory and use it. Remove this when the
            // bug is fixed. https://bugzilla.mozilla.org/show_bug.cgi?id=1459761#c5
            _wasmInstance = wat_modules_1.yaz0_asInstance();
        }
    };
});
// GX constants. Mostly taken from libogc.
System.register("gx/gx_enum", [], function (exports_21, context_21) {
    "use strict";
    var __moduleName = context_21 && context_21.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("fres/gx2_enum", [], function (exports_22, context_22) {
    "use strict";
    var __moduleName = context_22 && context_22.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("fres/gx2_surface", [], function (exports_23, context_23) {
    "use strict";
    var __moduleName = context_23 && context_23.id;
    function parseGX2Surface(buffer, gx2SurfaceOffs) {
        var view = buffer.slice(gx2SurfaceOffs, gx2SurfaceOffs + 0x9C).createDataView();
        var dimension = view.getUint32(0x00, false);
        var width = view.getUint32(0x04, false);
        var height = view.getUint32(0x08, false);
        var depth = view.getUint32(0x0C, false);
        var numMips = view.getUint32(0x10, false);
        var format = view.getUint32(0x14, false);
        var aaMode = view.getUint32(0x18, false);
        var texDataSize = view.getUint32(0x20, false);
        var mipDataSize = view.getUint32(0x28, false);
        var tileMode = view.getUint32(0x30, false);
        var swizzle = view.getUint32(0x34, false);
        var align = view.getUint32(0x38, false);
        var pitch = view.getUint32(0x3C, false);
        var mipDataOffsetTableIdx = 0x40;
        var mipDataOffsets = [];
        for (var i = 0; i < 13; i++) {
            mipDataOffsets.push(view.getUint32(mipDataOffsetTableIdx, false));
            mipDataOffsetTableIdx += 0x04;
        }
        var surface = { format: format, tileMode: tileMode, swizzle: swizzle, width: width, height: height, depth: depth, pitch: pitch, numMips: numMips, aaMode: aaMode, texDataSize: texDataSize, mipDataSize: mipDataSize, mipDataOffsets: mipDataOffsets };
        return surface;
    }
    exports_23("parseGX2Surface", parseGX2Surface);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("fres/bfres", ["fres/gx2_surface", "util"], function (exports_24, context_24) {
    "use strict";
    var __moduleName = context_24 && context_24.id;
    function readBinPtrT(view, offs, littleEndian) {
        var offs2 = view.getInt32(offs, littleEndian);
        if (offs2 === 0)
            return 0;
        else
            return offs + offs2;
    }
    function parseResDic(buffer, tableOffs, littleEndian) {
        if (tableOffs === 0)
            return [];
        var view = buffer.createDataView();
        var tableSize = view.getUint32(tableOffs + 0x00, littleEndian);
        var tableCount = view.getUint32(tableOffs + 0x04, littleEndian);
        util_10.assert(tableCount === tableCount);
        var entries = [];
        var tableIdx = tableOffs + 0x08;
        // Skip root entry.
        tableIdx += 0x10;
        for (var i = 0; i < tableCount; i++) {
            // There's a fancy search tree in here which I don't care about at all...
            var name_1 = util_10.readString(buffer, readBinPtrT(view, tableIdx + 0x08, littleEndian));
            var offs = readBinPtrT(view, tableIdx + 0x0C, littleEndian);
            entries.push({ name: name_1, offs: offs });
            tableIdx += 0x10;
        }
        return entries;
    }
    function parseFTEX(buffer, entry, littleEndian) {
        var offs = entry.offs;
        var view = buffer.createDataView();
        util_10.assert(util_10.readString(buffer, offs + 0x00, 0x04) === 'FTEX');
        // GX2 is Wii U which is a little-endian system.
        util_10.assert(!littleEndian);
        var gx2SurfaceOffs = offs + 0x04;
        var surface = gx2_surface_1.parseGX2Surface(buffer, gx2SurfaceOffs);
        var texDataOffs = readBinPtrT(view, offs + 0xB0, littleEndian);
        var mipDataOffs = readBinPtrT(view, offs + 0xB4, littleEndian);
        var texData = buffer.subarray(texDataOffs, surface.texDataSize);
        var mipData = buffer.subarray(mipDataOffs, surface.mipDataSize);
        return { surface: surface, texData: texData, mipData: mipData };
    }
    function parseFMDL(buffer, entry, littleEndian) {
        var offs = entry.offs;
        var view = buffer.createDataView();
        util_10.assert(util_10.readString(buffer, offs + 0x00, 0x04) === 'FMDL');
        var fileName = readBinPtrT(view, offs + 0x04, littleEndian);
        var filePath = readBinPtrT(view, offs + 0x08, littleEndian);
        var fsklOffs = readBinPtrT(view, offs + 0x0C, littleEndian);
        var fvtxOffs = readBinPtrT(view, offs + 0x10, littleEndian);
        var fshpResDic = parseResDic(buffer, readBinPtrT(view, offs + 0x14, littleEndian), littleEndian);
        var fmatResDic = parseResDic(buffer, readBinPtrT(view, offs + 0x18, littleEndian), littleEndian);
        var fvtxCount = view.getUint16(offs + 0x20, littleEndian);
        var fshpCount = view.getUint16(offs + 0x22, littleEndian);
        var fmatCount = view.getUint16(offs + 0x24, littleEndian);
        util_10.assert(fshpCount === fshpResDic.length);
        util_10.assert(fmatCount === fmatResDic.length);
        function readBufferData(offs) {
            var size = view.getUint32(offs + 0x04, littleEndian);
            var stride = view.getUint16(offs + 0x0C, littleEndian);
            var dataOffs = readBinPtrT(view, offs + 0x14, littleEndian);
            var data = buffer.subarray(dataOffs, size);
            return { data: data, stride: stride };
        }
        function parseShaderAssignDict(offs) {
            var resDic = parseResDic(buffer, offs, littleEndian);
            var entries = [];
            try {
                for (var resDic_1 = __values(resDic), resDic_1_1 = resDic_1.next(); !resDic_1_1.done; resDic_1_1 = resDic_1.next()) {
                    var entry_1 = resDic_1_1.value;
                    var key = entry_1.name;
                    var value = util_10.readString(buffer, entry_1.offs);
                    entries.push({ key: key, value: value });
                }
            }
            catch (e_18_1) { e_18 = { error: e_18_1 }; }
            finally {
                try {
                    if (resDic_1_1 && !resDic_1_1.done && (_a = resDic_1.return)) _a.call(resDic_1);
                }
                finally { if (e_18) throw e_18.error; }
            }
            return entries;
            var e_18, _a;
        }
        // Vertex buffers.
        var fvtxIdx = fvtxOffs;
        var fvtx = [];
        for (var i = 0; i < fvtxCount; i++) {
            util_10.assert(util_10.readString(buffer, fvtxIdx + 0x00, 0x04) === 'FVTX');
            var attribCount = view.getUint8(fvtxIdx + 0x04);
            var bufferCount = view.getUint8(fvtxIdx + 0x05);
            var sectionIndex = view.getUint16(fvtxIdx + 0x06);
            util_10.assert(i === sectionIndex);
            var vtxCount = view.getUint32(fvtxIdx + 0x08);
            var attribArrayOffs = readBinPtrT(view, fvtxIdx + 0x10, littleEndian);
            var bufferArrayOffs = readBinPtrT(view, fvtxIdx + 0x18, littleEndian);
            var attribs = [];
            var attribArrayIdx = attribArrayOffs;
            for (var j = 0; j < attribCount; j++) {
                var name_2 = util_10.readString(buffer, readBinPtrT(view, attribArrayIdx + 0x00, littleEndian));
                var bufferIndex = view.getUint8(attribArrayIdx + 0x04);
                var bufferStart = view.getUint16(attribArrayIdx + 0x06, littleEndian);
                var format = view.getUint32(attribArrayIdx + 0x08, littleEndian);
                attribs.push({ name: name_2, bufferIndex: bufferIndex, bufferStart: bufferStart, format: format });
                attribArrayIdx += 0x0C;
            }
            var buffers = [];
            var bufferArrayIdx = bufferArrayOffs;
            for (var j = 0; j < bufferCount; j++) {
                var bufferData = readBufferData(bufferArrayIdx);
                buffers.push(bufferData);
                bufferArrayIdx += 0x18;
            }
            fvtx.push({ buffers: buffers, attribs: attribs, vtxCount: vtxCount });
            fvtxIdx += 0x20;
        }
        // Shapes.
        var fshp = [];
        try {
            for (var fshpResDic_1 = __values(fshpResDic), fshpResDic_1_1 = fshpResDic_1.next(); !fshpResDic_1_1.done; fshpResDic_1_1 = fshpResDic_1.next()) {
                var fshpEntry = fshpResDic_1_1.value;
                var offs_1 = fshpEntry.offs;
                util_10.assert(util_10.readString(buffer, offs_1 + 0x00, 0x04) === 'FSHP');
                var name_3 = util_10.readString(buffer, readBinPtrT(view, offs_1 + 0x04, littleEndian));
                var fmatIndex = view.getUint16(offs_1 + 0x0E, littleEndian);
                var fsklIndex = view.getUint16(offs_1 + 0x10, littleEndian);
                var fvtxIndex = view.getUint16(offs_1 + 0x12, littleEndian);
                // Each mesh corresponds to one LoD.
                var meshArrayCount = view.getUint8(offs_1 + 0x17);
                var meshArrayOffs = readBinPtrT(view, offs_1 + 0x24, littleEndian);
                var meshArrayIdx = meshArrayOffs;
                var meshes = [];
                for (var i = 0; i < meshArrayCount; i++) {
                    var primType = view.getUint32(meshArrayIdx + 0x00, littleEndian);
                    var indexFormat = view.getUint32(meshArrayIdx + 0x04, littleEndian);
                    var indexBufferOffs = readBinPtrT(view, meshArrayIdx + 0x14, littleEndian);
                    var indexBufferData = readBufferData(indexBufferOffs);
                    var submeshArrayCount = view.getUint16(meshArrayIdx + 0x0C, littleEndian);
                    var submeshArrayOffs = readBinPtrT(view, meshArrayIdx + 0x10, littleEndian);
                    var submeshArrayIdx = submeshArrayOffs;
                    var submeshes = [];
                    for (var j = 0; j < submeshArrayCount; j++) {
                        var indexBufferOffset = view.getUint32(submeshArrayIdx + 0x00, littleEndian);
                        var indexBufferCount = view.getUint32(submeshArrayIdx + 0x04, littleEndian);
                        submeshes.push({ indexBufferOffset: indexBufferOffset, indexBufferCount: indexBufferCount });
                        submeshArrayIdx += 0x08;
                    }
                    meshes.push({ primType: primType, indexFormat: indexFormat, indexBufferData: indexBufferData, submeshes: submeshes });
                    meshArrayIdx += 0x1C;
                }
                fshp.push({ name: name_3, fmatIndex: fmatIndex, fvtxIndex: fvtxIndex, meshes: meshes });
            }
        }
        catch (e_19_1) { e_19 = { error: e_19_1 }; }
        finally {
            try {
                if (fshpResDic_1_1 && !fshpResDic_1_1.done && (_a = fshpResDic_1.return)) _a.call(fshpResDic_1);
            }
            finally { if (e_19) throw e_19.error; }
        }
        // Materials.
        var fmat = [];
        try {
            for (var fmatResDic_1 = __values(fmatResDic), fmatResDic_1_1 = fmatResDic_1.next(); !fmatResDic_1_1.done; fmatResDic_1_1 = fmatResDic_1.next()) {
                var fmatEntry = fmatResDic_1_1.value;
                var offs_2 = fmatEntry.offs;
                util_10.assert(util_10.readString(buffer, offs_2 + 0x00, 0x04) === 'FMAT');
                var name_4 = util_10.readString(buffer, readBinPtrT(view, offs_2 + 0x04, littleEndian));
                var renderInfoParameterCount = view.getUint16(offs_2 + 0x0E, littleEndian);
                var textureReferenceCount = view.getUint8(offs_2 + 0x10);
                var textureSamplerCount = view.getUint8(offs_2 + 0x11);
                var materialParameterCount = view.getUint16(offs_2 + 0x12);
                var materialParameterDataLength = view.getUint16(offs_2 + 0x16);
                var renderInfoParameterResDic = parseResDic(buffer, readBinPtrT(view, offs_2 + 0x1C, littleEndian), littleEndian);
                var renderStateOffs = readBinPtrT(view, offs_2 + 0x20, littleEndian);
                var shaderAssignOffs = readBinPtrT(view, offs_2 + 0x24, littleEndian);
                var textureReferenceArrayOffs = readBinPtrT(view, offs_2 + 0x28, littleEndian);
                var textureSamplerArrayOffs = readBinPtrT(view, offs_2 + 0x2C, littleEndian);
                var materialParameterArrayOffs = readBinPtrT(view, offs_2 + 0x34, littleEndian);
                var materialParameterDataOffs = readBinPtrT(view, offs_2 + 0x3C, littleEndian);
                var materialParameterDataBuffer = buffer.subarray(materialParameterDataOffs, materialParameterDataLength);
                var renderInfoParameters = [];
                try {
                    for (var renderInfoParameterResDic_1 = __values(renderInfoParameterResDic), renderInfoParameterResDic_1_1 = renderInfoParameterResDic_1.next(); !renderInfoParameterResDic_1_1.done; renderInfoParameterResDic_1_1 = renderInfoParameterResDic_1.next()) {
                        var renderInfoParameterEntry = renderInfoParameterResDic_1_1.value;
                        var offs_3 = renderInfoParameterEntry.offs;
                        var arrayLength = view.getUint16(offs_3 + 0x00, littleEndian);
                        var type = view.getUint8(offs_3 + 0x02);
                        var name_5 = util_10.readString(buffer, readBinPtrT(view, offs_3 + 0x04, littleEndian));
                        var arrayIdx = offs_3 + 0x08;
                        switch (type) {
                            case RenderInfoParameterType.Int: {
                                var data = [];
                                for (var i = 0; i < arrayLength; i++) {
                                    data.push(view.getInt32(arrayIdx, littleEndian));
                                    arrayIdx += 0x04;
                                }
                                renderInfoParameters.push({ type: type, name: name_5, data: data });
                                break;
                            }
                            case RenderInfoParameterType.Float: {
                                var data = [];
                                for (var i = 0; i < arrayLength; i++) {
                                    data.push(view.getFloat32(arrayIdx, littleEndian));
                                    arrayIdx += 0x04;
                                }
                                renderInfoParameters.push({ type: type, name: name_5, data: data });
                                break;
                            }
                            case RenderInfoParameterType.String: {
                                var data = [];
                                for (var i = 0; i < arrayLength; i++) {
                                    data.push(util_10.readString(buffer, readBinPtrT(view, arrayIdx, littleEndian)));
                                    arrayIdx += 0x04;
                                }
                                renderInfoParameters.push({ type: type, name: name_5, data: data });
                                break;
                            }
                        }
                    }
                }
                catch (e_20_1) { e_20 = { error: e_20_1 }; }
                finally {
                    try {
                        if (renderInfoParameterResDic_1_1 && !renderInfoParameterResDic_1_1.done && (_b = renderInfoParameterResDic_1.return)) _b.call(renderInfoParameterResDic_1);
                    }
                    finally { if (e_20) throw e_20.error; }
                }
                util_10.assert(textureSamplerCount === textureReferenceCount);
                var textureSamplerArrayIdx = textureSamplerArrayOffs;
                var textureReferenceArrayIdx = textureReferenceArrayOffs;
                var textureAssigns = [];
                for (var i = 0; i < textureSamplerCount; i++) {
                    var samplerParam0 = view.getUint32(textureSamplerArrayIdx + 0x00, littleEndian);
                    var samplerParam1 = view.getUint32(textureSamplerArrayIdx + 0x04, littleEndian);
                    var samplerParam2 = view.getUint32(textureSamplerArrayIdx + 0x08, littleEndian);
                    var attribName = util_10.readString(buffer, readBinPtrT(view, textureSamplerArrayIdx + 0x10, littleEndian));
                    var index = view.getUint8(textureSamplerArrayIdx + 0x14);
                    util_10.assert(index === i);
                    textureSamplerArrayIdx += 0x18;
                    var textureName = util_10.readString(buffer, readBinPtrT(view, textureReferenceArrayIdx + 0x00, littleEndian));
                    var ftexOffs = readBinPtrT(view, textureReferenceArrayIdx + 0x04, littleEndian);
                    textureReferenceArrayIdx += 0x08;
                    var texClampU = (samplerParam0 >>> 0) & 0x07;
                    var texClampV = (samplerParam0 >>> 3) & 0x07;
                    var texFilterMag = (samplerParam0 >>> 9) & 0x03;
                    var texFilterMin = (samplerParam0 >>> 12) & 0x03;
                    var texFilterMip = (samplerParam0 >>> 17) & 0x03;
                    textureAssigns.push({ attribName: attribName, textureName: textureName, ftexOffs: ftexOffs, texClampU: texClampU, texClampV: texClampV, texFilterMin: texFilterMin, texFilterMag: texFilterMag, texFilterMip: texFilterMip });
                }
                var materialParameterArrayIdx = materialParameterArrayOffs;
                var materialParameters = [];
                for (var i = 0; i < materialParameterCount; i++) {
                    var type = view.getUint8(materialParameterArrayIdx + 0x00);
                    var size = view.getUint8(materialParameterArrayIdx + 0x01);
                    var dataOffs = view.getUint16(materialParameterArrayIdx + 0x02, littleEndian);
                    var dependedIndex = view.getUint16(materialParameterArrayIdx + 0x0C, littleEndian);
                    var dependIndex = view.getUint16(materialParameterArrayIdx + 0x0E, littleEndian);
                    var name_6 = util_10.readString(buffer, readBinPtrT(view, materialParameterArrayIdx + 0x10, littleEndian));
                    materialParameterArrayIdx += 0x14;
                    materialParameters.push({ type: type, size: size, dataOffs: dataOffs, name: name_6 });
                }
                // Shader assign.
                var shaderArchiveName = util_10.readString(buffer, readBinPtrT(view, shaderAssignOffs + 0x00, littleEndian));
                var shadingModelName = util_10.readString(buffer, readBinPtrT(view, shaderAssignOffs + 0x04, littleEndian));
                var vertShaderInputCount = view.getUint8(shaderAssignOffs + 0x0C);
                var vertShaderInputDict = parseShaderAssignDict(readBinPtrT(view, shaderAssignOffs + 0x10, littleEndian));
                util_10.assert(vertShaderInputDict.length === vertShaderInputCount);
                var fragShaderInputCount = view.getUint8(shaderAssignOffs + 0x0D);
                var fragShaderInputDict = parseShaderAssignDict(readBinPtrT(view, shaderAssignOffs + 0x14, littleEndian));
                util_10.assert(fragShaderInputDict.length === fragShaderInputCount);
                var paramDict = parseShaderAssignDict(readBinPtrT(view, shaderAssignOffs + 0x18, littleEndian));
                var paramCount = view.getUint16(shaderAssignOffs + 0x0E);
                util_10.assert(paramDict.length === paramCount);
                var shaderAssign = {
                    shaderArchiveName: shaderArchiveName,
                    shadingModelName: shadingModelName,
                    vertShaderInputDict: vertShaderInputDict,
                    fragShaderInputDict: fragShaderInputDict,
                    paramDict: paramDict,
                };
                // Render state.
                var renderState0 = view.getUint32(renderStateOffs + 0x00, littleEndian);
                var renderState1 = view.getUint32(renderStateOffs + 0x04, littleEndian);
                var renderState2 = view.getUint32(renderStateOffs + 0x08, littleEndian);
                var cullFront = !!((renderState1 >>> 0) & 0x01);
                var cullBack = !!((renderState1 >>> 1) & 0x01);
                var frontFaceMode = (renderState1 >>> 2) & 0x01;
                var depthTest = !!((renderState2 >>> 1) & 0x01);
                var depthWrite = !!((renderState2 >>> 2) & 0x01);
                var depthCompareFunc = (renderState2 >> 4) & 0x07;
                var renderState = { cullFront: cullFront, cullBack: cullBack, frontFaceMode: frontFaceMode, depthTest: depthTest, depthWrite: depthWrite, depthCompareFunc: depthCompareFunc };
                fmat.push({ name: name_4, renderInfoParameters: renderInfoParameters, textureAssigns: textureAssigns, materialParameterDataBuffer: materialParameterDataBuffer, materialParameters: materialParameters, shaderAssign: shaderAssign, renderState: renderState });
            }
        }
        catch (e_21_1) { e_21 = { error: e_21_1 }; }
        finally {
            try {
                if (fmatResDic_1_1 && !fmatResDic_1_1.done && (_c = fmatResDic_1.return)) _c.call(fmatResDic_1);
            }
            finally { if (e_21) throw e_21.error; }
        }
        return { fvtx: fvtx, fshp: fshp, fmat: fmat };
        var e_19, _a, e_21, _c, e_20, _b;
    }
    function parse(buffer) {
        var view = buffer.createDataView();
        util_10.assert(util_10.readString(buffer, 0x00, 0x04) === 'FRES');
        var littleEndian;
        switch (view.getUint16(0x08, false)) {
            case 0xFEFF:
                littleEndian = false;
                break;
            case 0xFFFE:
                littleEndian = true;
                break;
            default:
                throw new Error("Invalid BOM");
        }
        var version = view.getUint32(0x04, littleEndian);
        var supportedVersions = [
            0x03040001,
            0x03040002,
            0x03040004,
            0x03050003,
        ];
        util_10.assert(supportedVersions.includes(version));
        var fileNameOffs = readBinPtrT(view, 0x14, littleEndian);
        var fileName = util_10.readString(buffer, fileNameOffs);
        function parseResDicIdx(idx) {
            var tableOffs = readBinPtrT(view, 0x20 + idx * 0x04, littleEndian);
            var tableCount = view.getUint16(0x50 + idx * 0x02, littleEndian);
            var resDic = parseResDic(buffer, tableOffs, littleEndian);
            util_10.assert(tableCount === resDic.length);
            return resDic;
        }
        var fmdlTable = parseResDicIdx(0x00);
        var ftexTable = parseResDicIdx(0x01);
        var fskaTable = parseResDicIdx(0x02);
        var textures = [];
        try {
            for (var ftexTable_1 = __values(ftexTable), ftexTable_1_1 = ftexTable_1.next(); !ftexTable_1_1.done; ftexTable_1_1 = ftexTable_1.next()) {
                var entry = ftexTable_1_1.value;
                var texture = parseFTEX(buffer, entry, littleEndian);
                textures.push({ entry: entry, texture: texture });
            }
        }
        catch (e_22_1) { e_22 = { error: e_22_1 }; }
        finally {
            try {
                if (ftexTable_1_1 && !ftexTable_1_1.done && (_a = ftexTable_1.return)) _a.call(ftexTable_1);
            }
            finally { if (e_22) throw e_22.error; }
        }
        var models = [];
        try {
            for (var fmdlTable_1 = __values(fmdlTable), fmdlTable_1_1 = fmdlTable_1.next(); !fmdlTable_1_1.done; fmdlTable_1_1 = fmdlTable_1.next()) {
                var entry = fmdlTable_1_1.value;
                var fmdl = parseFMDL(buffer, entry, littleEndian);
                models.push({ entry: entry, fmdl: fmdl });
            }
        }
        catch (e_23_1) { e_23 = { error: e_23_1 }; }
        finally {
            try {
                if (fmdlTable_1_1 && !fmdlTable_1_1.done && (_b = fmdlTable_1.return)) _b.call(fmdlTable_1);
            }
            finally { if (e_23) throw e_23.error; }
        }
        return { textures: textures, models: models };
        var e_22, _a, e_23, _b;
    }
    exports_24("parse", parse);
    var gx2_surface_1, util_10, UBOParameterType, RenderInfoParameterType;
    return {
        setters: [
            function (gx2_surface_1_1) {
                gx2_surface_1 = gx2_surface_1_1;
            },
            function (util_10_1) {
                util_10 = util_10_1;
            }
        ],
        execute: function () {
            (function (UBOParameterType) {
                UBOParameterType[UBOParameterType["Bool1"] = 0] = "Bool1";
                UBOParameterType[UBOParameterType["Bool2"] = 1] = "Bool2";
                UBOParameterType[UBOParameterType["Bool3"] = 2] = "Bool3";
                UBOParameterType[UBOParameterType["Bool4"] = 3] = "Bool4";
                UBOParameterType[UBOParameterType["Int1"] = 4] = "Int1";
                UBOParameterType[UBOParameterType["Int2"] = 5] = "Int2";
                UBOParameterType[UBOParameterType["Int3"] = 6] = "Int3";
                UBOParameterType[UBOParameterType["Int4"] = 7] = "Int4";
                UBOParameterType[UBOParameterType["Uint1"] = 8] = "Uint1";
                UBOParameterType[UBOParameterType["Uint2"] = 9] = "Uint2";
                UBOParameterType[UBOParameterType["Uint3"] = 10] = "Uint3";
                UBOParameterType[UBOParameterType["Uint4"] = 11] = "Uint4";
                UBOParameterType[UBOParameterType["Float1"] = 12] = "Float1";
                UBOParameterType[UBOParameterType["Float2"] = 13] = "Float2";
                UBOParameterType[UBOParameterType["Float3"] = 14] = "Float3";
                UBOParameterType[UBOParameterType["Float4"] = 15] = "Float4";
                UBOParameterType[UBOParameterType["_Reserved_0"] = 16] = "_Reserved_0";
                UBOParameterType[UBOParameterType["Float2x2"] = 17] = "Float2x2";
                UBOParameterType[UBOParameterType["Float2x3"] = 18] = "Float2x3";
                UBOParameterType[UBOParameterType["Float2x4"] = 19] = "Float2x4";
                UBOParameterType[UBOParameterType["_Reserved_1"] = 20] = "_Reserved_1";
                UBOParameterType[UBOParameterType["Float3x2"] = 21] = "Float3x2";
                UBOParameterType[UBOParameterType["Float3x3"] = 22] = "Float3x3";
                UBOParameterType[UBOParameterType["Float3x4"] = 23] = "Float3x4";
                UBOParameterType[UBOParameterType["_Reserved_2"] = 24] = "_Reserved_2";
                UBOParameterType[UBOParameterType["Float4x2"] = 25] = "Float4x2";
                UBOParameterType[UBOParameterType["Float4x3"] = 26] = "Float4x3";
                UBOParameterType[UBOParameterType["Float4x4"] = 27] = "Float4x4";
                UBOParameterType[UBOParameterType["SRT2D"] = 28] = "SRT2D";
                UBOParameterType[UBOParameterType["SRT3D"] = 29] = "SRT3D";
                UBOParameterType[UBOParameterType["TextureSRT"] = 30] = "TextureSRT";
            })(UBOParameterType || (UBOParameterType = {}));
            (function (RenderInfoParameterType) {
                RenderInfoParameterType[RenderInfoParameterType["Int"] = 0] = "Int";
                RenderInfoParameterType[RenderInfoParameterType["Float"] = 1] = "Float";
                RenderInfoParameterType[RenderInfoParameterType["String"] = 2] = "String";
            })(RenderInfoParameterType || (RenderInfoParameterType = {}));
            ;
        }
    };
});
// GX Display List parsing.
System.register("gx/gx_displaylist", ["MemoizeCache", "util", "endian"], function (exports_25, context_25) {
    "use strict";
    var __moduleName = context_25 && context_25.id;
    function getComponentSizeRaw(compType) {
        switch (compType) {
            case 0 /* U8 */:
            case 1 /* S8 */:
            case 5 /* RGBA8 */:
                return 1;
            case 2 /* U16 */:
            case 3 /* S16 */:
                return 2;
            case 4 /* F32 */:
                return 4;
        }
    }
    exports_25("getComponentSizeRaw", getComponentSizeRaw);
    // PNMTXIDX, TEXnMTXIDX are special cases in GX.
    function isVtxAttribMtxIdx(vtxAttrib) {
        switch (vtxAttrib) {
            case 0 /* PNMTXIDX */:
            case 1 /* TEX0MTXIDX */:
            case 2 /* TEX1MTXIDX */:
            case 3 /* TEX2MTXIDX */:
            case 4 /* TEX3MTXIDX */:
            case 5 /* TEX4MTXIDX */:
            case 6 /* TEX5MTXIDX */:
            case 7 /* TEX6MTXIDX */:
            case 8 /* TEX7MTXIDX */:
                return true;
            default:
                return false;
        }
    }
    function getComponentSize(vtxAttrib, vatFormat) {
        // MTXIDX fields don't have VAT entries.
        if (isVtxAttribMtxIdx(vtxAttrib))
            return 1;
        return getComponentSizeRaw(vatFormat.compType);
    }
    function getComponentCountRaw(vtxAttrib, compCnt) {
        switch (vtxAttrib) {
            case 9 /* POS */:
                if (compCnt === 0 /* POS_XY */)
                    return 2;
                else if (compCnt === 1 /* POS_XYZ */)
                    return 3;
            case 10 /* NRM */:
                if (compCnt === 0 /* NRM_XYZ */)
                    return 3;
                // NBT*XYZ
                else if (compCnt === 1 /* NRM_NBT */)
                    return 9;
                // Separated NBT has three components per index.
                else if (compCnt === 2 /* NRM_NBT3 */)
                    return 3;
            case 11 /* CLR0 */:
            case 12 /* CLR1 */:
                if (compCnt === 0 /* CLR_RGB */)
                    return 3;
                else if (compCnt === 1 /* CLR_RGBA */)
                    return 4;
            case 13 /* TEX0 */:
            case 14 /* TEX1 */:
            case 15 /* TEX2 */:
            case 16 /* TEX3 */:
            case 17 /* TEX4 */:
            case 18 /* TEX5 */:
            case 19 /* TEX6 */:
            case 20 /* TEX7 */:
                if (compCnt === 0 /* TEX_S */)
                    return 1;
                else if (compCnt === 1 /* TEX_ST */)
                    return 2;
            case 255 /* NULL */:
            default:
                // Shouldn't ever happen
                throw new Error("whoops");
        }
    }
    exports_25("getComponentCountRaw", getComponentCountRaw);
    function getComponentCount(vtxAttrib, vatFormat) {
        // MTXIDX fields don't have VAT entries.
        if (isVtxAttribMtxIdx(vtxAttrib))
            return 1;
        return getComponentCountRaw(vtxAttrib, vatFormat.compCnt);
    }
    function getComponentShiftRaw(compType, compShift) {
        switch (compType) {
            case 4 /* F32 */:
            case 5 /* RGBA8 */:
                return 0;
            case 0 /* U8 */:
            case 2 /* U16 */:
            case 1 /* S8 */:
            case 3 /* S16 */:
                return compShift;
        }
    }
    function getComponentShift(vtxAttrib, vatFormat) {
        // MTXIDX fields don't have VAT entries.
        if (isVtxAttribMtxIdx(vtxAttrib))
            return 0;
        return getComponentShiftRaw(vatFormat.compType, vatFormat.compShift);
    }
    function getComponentType(vtxAttrib, vatFormat) {
        if (isVtxAttribMtxIdx(vtxAttrib))
            return 0 /* U8 */;
        return vatFormat.compType;
    }
    function getIndexNumComponents(vtxAttrib, vatFormat) {
        switch (vtxAttrib) {
            case 10 /* NRM */:
                if (vatFormat.compCnt === 2 /* NRM_NBT3 */)
                    return 3;
            // Fallthrough
            default:
                return 1;
        }
    }
    function getAttrName(vtxAttrib) {
        switch (vtxAttrib) {
            case 0 /* PNMTXIDX */: return "PNMTXIDX";
            case 1 /* TEX0MTXIDX */: return "TEX0MTXIDX";
            case 2 /* TEX1MTXIDX */: return "TEX1MTXIDX";
            case 3 /* TEX2MTXIDX */: return "TEX2MTXIDX";
            case 4 /* TEX3MTXIDX */: return "TEX3MTXIDX";
            case 5 /* TEX4MTXIDX */: return "TEX4MTXIDX";
            case 6 /* TEX5MTXIDX */: return "TEX5MTXIDX";
            case 7 /* TEX6MTXIDX */: return "TEX6MTXIDX";
            case 8 /* TEX7MTXIDX */: return "TEX7MTXIDX";
            case 9 /* POS */: return "POS";
            case 10 /* NRM */: return "NRM";
            case 11 /* CLR0 */: return "CLR0";
            case 12 /* CLR1 */: return "CLR1";
            case 13 /* TEX0 */: return "TEX0";
            case 14 /* TEX1 */: return "TEX1";
            case 15 /* TEX2 */: return "TEX2";
            case 16 /* TEX3 */: return "TEX3";
            case 17 /* TEX4 */: return "TEX4";
            case 18 /* TEX5 */: return "TEX5";
            case 19 /* TEX6 */: return "TEX6";
            case 20 /* TEX7 */: return "TEX7";
            default:
                throw new Error("whoops");
        }
    }
    function getAttributeFormat(vtxAttrib) {
        if (isVtxAttribMtxIdx(vtxAttrib))
            return 0 /* U8 */;
        return 2 /* F32 */;
    }
    function getAttributeFormatSize(attributeFormat) {
        switch (attributeFormat) {
            case 0 /* U8 */:
                return 1;
            case 1 /* U16 */:
                return 2;
            case 2 /* F32 */:
                return 4;
        }
    }
    function translateVatLayout(vatFormat, vcd) {
        if (vatFormat === undefined)
            return undefined;
        var srcVertexSize = 0;
        for (var vtxAttrib = 0; vtxAttrib < vcd.length; vtxAttrib++) {
            // Describes packed vertex layout.
            var vtxAttrDesc = vcd[vtxAttrib];
            // Describes format of pointed-to data.
            var vtxAttrFmt = vatFormat[vtxAttrib];
            if (!vtxAttrDesc || vtxAttrDesc.type === 0 /* NONE */)
                continue;
            // TODO(jstpierre): Find a better way to do NBT3.
            var srcIndexComponentCount = getIndexNumComponents(vtxAttrib, vtxAttrFmt);
            // MTXIDX entries can only be DIRECT if they exist.
            if (isVtxAttribMtxIdx(vtxAttrib))
                util_11.assert(vtxAttrDesc.type === 1 /* DIRECT */);
            switch (vtxAttrDesc.type) {
                case 1 /* DIRECT */: {
                    var srcAttrCompSize = getComponentSize(vtxAttrib, vtxAttrFmt);
                    var srcAttrCompCount = getComponentCount(vtxAttrib, vtxAttrFmt);
                    var srcAttrByteSize = srcAttrCompSize * srcAttrCompCount;
                    srcVertexSize += srcAttrByteSize;
                    break;
                }
                case 2 /* INDEX8 */:
                    srcVertexSize += 1 * srcIndexComponentCount;
                    break;
                case 3 /* INDEX16 */:
                    srcVertexSize += 2 * srcIndexComponentCount;
                    break;
            }
        }
        return { srcVertexSize: srcVertexSize, vatFormat: vatFormat, vcd: vcd };
    }
    function translateVertexLayout(vat, vcd) {
        // Create source VAT layouts.
        var vatLayouts = vat.map(function (vatFormat) { return translateVatLayout(vatFormat, vcd); });
        // Create destination vertex layout.
        var dstVertexSize = 0;
        var dstVertexAttributeLayouts = [];
        var _loop_3 = function (vtxAttrib) {
            var vtxAttrDesc = vcd[vtxAttrib];
            if (!vtxAttrDesc || vtxAttrDesc.type === 0 /* NONE */)
                return "continue";
            var enableOutput = (vtxAttrDesc.enableOutput === undefined || vtxAttrDesc.enableOutput);
            if (!enableOutput)
                return "continue";
            // TODO(jstpierre): Worth supporting other component types?
            var format = getAttributeFormat(vtxAttrib);
            var formatComponentSize = getAttributeFormatSize(format);
            dstVertexSize = util_11.align(dstVertexSize, formatComponentSize);
            var offset = dstVertexSize;
            // Find our maximum component count by choosing from a maximum of all the VAT formats.
            var componentCount = 0;
            vatLayouts.forEach(function (vatLayout) {
                var fmtComponentCount = getComponentCount(vtxAttrib, vatLayout.vatFormat[vtxAttrib]);
                componentCount = Math.max(componentCount, fmtComponentCount);
            });
            dstVertexSize += formatComponentSize * componentCount;
            dstVertexAttributeLayouts.push({ vtxAttrib: vtxAttrib, offset: offset, format: format, componentCount: componentCount });
        };
        for (var vtxAttrib = 0; vtxAttrib < vcd.length; vtxAttrib++) {
            _loop_3(vtxAttrib);
        }
        // Align the whole thing to our minimum required alignment (F32).
        dstVertexSize = util_11.align(dstVertexSize, 4);
        return { dstVertexSize: dstVertexSize, dstVertexAttributeLayouts: dstVertexAttributeLayouts, vatLayouts: vatLayouts };
    }
    function _compileVtxLoader(vat, vcd) {
        var loadedVertexLayout = translateVertexLayout(vat, vcd);
        function makeLoaderName() {
            var name = 'VtxLoader';
            // TODO(jstpierre): Re-enable this at some point. Right now it's not so easy...
            /*
            for (let vtxAttrib: GX.VertexAttribute = 0; vtxAttrib < vat.length; vtxAttrib++) {
                if (!vtxDescs[vtxAttrib] || vtxDescs[vtxAttrib].type === GX.AttrType.NONE)
                    continue;
    
                const attrName = getAttrName(vtxAttrib);
    
                const compSizeSuffix = vat[vtxAttrib] ? getComponentSize(vat[vtxAttrib].compType) : '';
                const compCntSuffix = vat[vtxAttrib] ? getComponentCount(vtxAttrib, vat[vtxAttrib].compCnt) : '';
    
                const attrTypeSuffixes = ['', 'D', 'I8', 'I16'];
                const attrTypeSuffix = attrTypeSuffixes[vtxDescs[vtxAttrib].type];
                name += `_${attrName}$${attrTypeSuffix}$${compSizeSuffix}x${compCntSuffix}`;
            }
            */
            return name;
        }
        function compileVtxArrayViewName(vtxAttrib) {
            return "srcAttrArrayView" + vtxAttrib;
        }
        function compileVtxArrayViews() {
            var sources = [];
            var _loop_4 = function (vtxAttrib) {
                var dstAttribLayout = loadedVertexLayout.dstVertexAttributeLayouts.find(function (layout) { return layout.vtxAttrib === vtxAttrib; });
                var outputEnabled = !!dstAttribLayout;
                if (!outputEnabled)
                    return "continue";
                var attrType = vcd[vtxAttrib].type;
                if (attrType === 3 /* INDEX16 */ || attrType === 2 /* INDEX8 */) {
                    var viewName = compileVtxArrayViewName(vtxAttrib);
                    sources.push("const " + viewName + " = vtxArrays[" + vtxAttrib + "].buffer.createDataView(vtxArrays[" + vtxAttrib + "].offs);");
                }
            };
            for (var vtxAttrib = 0; vtxAttrib < 20 /* MAX */; vtxAttrib++) {
                _loop_4(vtxAttrib);
            }
            return sources.join('\n');
        }
        // Loads a single vertex layout.
        function compileVatLayoutAttribute(vatLayout, vtxAttrib) {
            var vtxAttrFmt = vatLayout.vatFormat[vtxAttrib];
            var vtxAttrDesc = vatLayout.vcd[vtxAttrib];
            var dstAttribLayout = loadedVertexLayout.dstVertexAttributeLayouts.find(function (layout) { return layout.vtxAttrib === vtxAttrib; });
            if (!vtxAttrDesc || vtxAttrDesc.type === 0 /* NONE */)
                return '';
            // If we don't have a destination for the data, then don't bother outputting.
            var outputEnabled = !!dstAttribLayout;
            var srcAttrCompSize;
            var srcAttrCompCount;
            var srcAttrByteSize;
            // We only need vtxAttrFmt if we're going to read the data.
            if (vtxAttrDesc.type === 1 /* DIRECT */ || outputEnabled) {
                srcAttrCompSize = getComponentSize(vtxAttrib, vtxAttrFmt);
                srcAttrCompCount = getComponentCount(vtxAttrib, vtxAttrFmt);
                srcAttrByteSize = srcAttrCompSize * srcAttrCompCount;
            }
            function compileShift(n) {
                // Instead of just doing `${n} >> srcAttrCompShift`, we use division
                // to get us the fractional components...
                var srcAttrCompShift = getComponentShift(vtxAttrib, vtxAttrFmt);
                var divisor = 1 << srcAttrCompShift;
                if (divisor === 1)
                    return n;
                else
                    return "(" + n + " / " + divisor + ")";
            }
            function compileReadOneComponent(viewName, attrOffset) {
                switch (getComponentType(vtxAttrib, vtxAttrFmt)) {
                    case 4 /* F32 */:
                        return viewName + ".getFloat32(" + attrOffset + ")";
                    case 5 /* RGBA8 */:
                        // This gets four components.
                        return "(" + viewName + ".getUint8(" + attrOffset + ") / 0xFF)";
                    case 0 /* U8 */:
                        return compileShift(viewName + ".getUint8(" + attrOffset + ")");
                    case 2 /* U16 */:
                        return compileShift(viewName + ".getUint16(" + attrOffset + ")");
                    case 1 /* S8 */:
                        return compileShift(viewName + ".getInt8(" + attrOffset + ")");
                    case 3 /* S16 */:
                        return compileShift(viewName + ".getInt16(" + attrOffset + ")");
                    default:
                        throw "whoops";
                }
            }
            function compileWriteOneComponentF32(dstOffs, value) {
                var littleEndian = (endian_2.getSystemEndianness() === 0 /* LITTLE_ENDIAN */);
                return "dstVertexDataView.setFloat32(" + dstOffs + ", " + value + ", " + littleEndian + ")";
            }
            function compileWriteOneComponentU8(dstOffs, value) {
                return "dstVertexDataView.setUint8(" + dstOffs + ", " + value + ")";
            }
            function compileWriteOneComponent(offs, value) {
                var dstOffs = "dstVertexDataOffs + " + offs;
                if (dstAttribLayout.format === 2 /* F32 */)
                    return compileWriteOneComponentF32(dstOffs, value);
                else if (dstAttribLayout.format === 0 /* U8 */)
                    return compileWriteOneComponentU8(dstOffs, value);
                else
                    throw "whoops";
            }
            function compileOneAttrib(viewName, attrOffsetBase, drawCallIdxIncr) {
                var S = "";
                if (outputEnabled) {
                    var dstComponentSize = getAttributeFormatSize(dstAttribLayout.format);
                    for (var i = 0; i < dstAttribLayout.componentCount; i++) {
                        var dstOffs = dstAttribLayout.offset + (i * dstComponentSize);
                        var srcOffs = attrOffsetBase + " + " + i * srcAttrCompSize;
                        // Fill in components not in the source with zero.
                        var value = void 0;
                        if (i < srcAttrCompCount)
                            value = compileReadOneComponent(viewName, srcOffs);
                        else
                            value = "0";
                        S += "\n        " + compileWriteOneComponent(dstOffs, value) + ";";
                    }
                }
                S += "\n        drawCallIdx += " + drawCallIdxIncr + ";\n";
                return S;
            }
            function compileOneIndex(viewName, readIndex, drawCallIdxIncr, uniqueSuffix) {
                if (uniqueSuffix === void 0) { uniqueSuffix = ''; }
                // TODO(jstpierre): Stride.
                var attrOffsetBase = "(" + readIndex + ") * " + srcAttrByteSize;
                var arrayOffsetVarName = "arrayOffset" + vtxAttrib + uniqueSuffix;
                var S = '';
                if (outputEnabled) {
                    return "const " + arrayOffsetVarName + " = " + attrOffsetBase + ";" + compileOneAttrib(viewName, arrayOffsetVarName, drawCallIdxIncr);
                }
                else {
                    return compileOneAttrib('', '', drawCallIdxIncr);
                }
            }
            function compileAttribIndex(viewName, readIndex, drawCallIdxIncr) {
                if (vtxAttrib === 10 /* NRM */ && vtxAttrFmt.compCnt === 2 /* NRM_NBT3 */) {
                    // Special case: NBT3.
                    return "\n        // NBT Normal\n        " + compileOneIndex(viewName, readIndex + " + 0", drawCallIdxIncr, "_N") + "\n        // NBT Bitangent\n        " + compileOneIndex(viewName, readIndex + " + 3", drawCallIdxIncr, "_B") + "\n        // NBT Tangent\n        " + compileOneIndex(viewName, readIndex + " + 6", drawCallIdxIncr, "_T");
                }
                else {
                    return "\n        // " + getAttrName(vtxAttrib) + "\n        " + compileOneIndex(viewName, readIndex, drawCallIdxIncr);
                }
            }
            switch (vtxAttrDesc.type) {
                case 1 /* DIRECT */:
                    return compileOneAttrib("dlView", "drawCallIdx", srcAttrByteSize);
                case 2 /* INDEX8 */:
                    return compileAttribIndex(compileVtxArrayViewName(vtxAttrib), "dlView.getUint8(drawCallIdx)", 1);
                case 3 /* INDEX16 */:
                    return compileAttribIndex(compileVtxArrayViewName(vtxAttrib), "dlView.getUint16(drawCallIdx)", 2);
                default:
                    throw "whoops";
            }
        }
        function compileVatFormats() {
            var sources = [];
            var vatLayoutSources = new Map();
            for (var i = 0; i < 7 /* VTXFMT7 */; i++) {
                var vatLayout = loadedVertexLayout.vatLayouts[i];
                if (!vatLayout)
                    continue;
                util_11.assert(vatLayout.vcd === vcd);
                var S_1 = '';
                for (var vtxAttrib = 0; vtxAttrib < 20 /* MAX */; vtxAttrib++) {
                    S_1 += compileVatLayoutAttribute(vatLayout, vtxAttrib);
                }
                vatLayoutSources.set(i, S_1);
            }
            if (vatLayoutSources.size === 0)
                throw "whoops";
            if (vatLayoutSources.size === 1)
                return vatLayoutSources.values().next().value;
            // Dynamic dispatch.
            var S = "\n        ";
            try {
                for (var _a = __values(vatLayoutSources.entries()), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var _c = __read(_b.value, 2), vtxFmt = _c[0], vatLayoutSource = _c[1];
                    S += "if (drawCall.vertexFormat === " + vtxFmt + ") {\n\n            " + vatLayoutSource + "\n\n        } else ";
                }
            }
            catch (e_24_1) { e_24 = { error: e_24_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                }
                finally { if (e_24) throw e_24.error; }
            }
            S += "{\n            throw new Error(\"Invalid vertex format \" + vertexFormat);\n        }";
            return S;
            var e_24, _d;
        }
        function compileSrcVertexSizes() {
            return JSON.stringify(loadedVertexLayout.vatLayouts.map(function (vatLayout) { return vatLayout && vatLayout.srcVertexSize; }));
        }
        var loaderName = makeLoaderName();
        var source = "\n\"use strict\";\n\nreturn function " + loaderName + "(vtxArrays, srcBuffer) {\n// Parse display list.\nconst dlView = srcBuffer.createDataView();\nconst drawCalls = [];\nconst srcVertexSizes = " + compileSrcVertexSizes() + ";\nlet totalVertexCount = 0;\nlet totalTriangleCount = 0;\nlet drawCallIdx = 0;\nwhile (true) {\n    if (drawCallIdx >= srcBuffer.byteLength)\n        break;\n    const cmd = dlView.getUint8(drawCallIdx);\n    if (cmd === 0)\n        break;\n\n    const primType = cmd & 0xF8;\n    const vertexFormat = cmd & 0x07;\n\n    const vertexCount = dlView.getUint16(drawCallIdx + 0x01);\n    drawCallIdx += 0x03;\n    const srcOffs = drawCallIdx;\n    const first = totalVertexCount;\n    totalVertexCount += vertexCount;\n\n    switch (primType) {\n    case " + 144 /* DRAW_TRIANGLES */ + ":\n        totalTriangleCount += (vertexCount / 3);\n        break;\n    case " + 160 /* DRAW_TRIANGLE_FAN */ + ":\n    case " + 152 /* DRAW_TRIANGLE_STRIP */ + ":\n        totalTriangleCount += (vertexCount - 2);\n        break;\n    case " + 128 /* DRAW_QUADS */ + ":\n    case " + 136 /* DRAW_QUADS_2 */ + ":\n        totalTriangleCount += (vertexCount * 6) / 4;\n        break;\n    default:\n        throw new Error(\"Invalid data at \" + srcBuffer.byteOffset.toString(16) + \"/\" + drawCallIdx.toString(16) + \" primType \" + primType.toString(16));\n    }\n\n    drawCalls.push({ primType, vertexFormat, srcOffs, vertexCount });\n\n    // Skip over the index data.\n    drawCallIdx += srcVertexSizes[vertexFormat] * vertexCount;\n}\n\n// Now make the data.\nlet indexDataIdx = 0;\nconst dstIndexData = new Uint16Array(totalTriangleCount * 3);\nlet vertexId = 0;\n\nconst dstVertexDataSize = " + loadedVertexLayout.dstVertexSize + " * totalVertexCount;\nconst dstVertexData = new ArrayBuffer(dstVertexDataSize);\nconst dstVertexDataView = new DataView(dstVertexData);\nlet dstVertexDataOffs = 0;\n\n" + compileVtxArrayViews() + "\n\nfor (let z = 0; z < drawCalls.length; z++) {\n    const drawCall = drawCalls[z];\n\n    // Convert topology to triangles.\n    switch (drawCall.primType) {\n    case " + 144 /* DRAW_TRIANGLES */ + ":\n        // Copy vertices.\n        for (let i = 0; i < drawCall.vertexCount; i++) {\n            dstIndexData[indexDataIdx++] = vertexId++;\n        }\n        break;\n    case " + 152 /* DRAW_TRIANGLE_STRIP */ + ":\n        // First vertex defines original triangle.\n        for (let i = 0; i < 3; i++) {\n            dstIndexData[indexDataIdx++] = vertexId++;\n        }\n\n        for (let i = 3; i < drawCall.vertexCount; i++) {\n            dstIndexData[indexDataIdx++] = vertexId - ((i & 1) ? 1 : 2);\n            dstIndexData[indexDataIdx++] = vertexId - ((i & 1) ? 2 : 1);\n            dstIndexData[indexDataIdx++] = vertexId++;\n        }\n        break;\n    case " + 160 /* DRAW_TRIANGLE_FAN */ + ":\n        // First vertex defines original triangle.\n        const firstVertex = vertexId;\n\n        for (let i = 0; i < 3; i++) {\n            dstIndexData[indexDataIdx++] = vertexId++;\n        }\n\n        for (let i = 3; i < drawCall.vertexCount; i++) {\n            dstIndexData[indexDataIdx++] = firstVertex;\n            dstIndexData[indexDataIdx++] = vertexId - 1;\n            dstIndexData[indexDataIdx++] = vertexId++;\n        }\n        break;\n    case " + 128 /* DRAW_QUADS */ + ":\n    case " + 136 /* DRAW_QUADS_2 */ + ":\n        // Each quad (4 vertices) is split into 2 triangles (6 vertices)\n        for (let i = 0; i < drawCall.vertexCount; i += 4) {\n            dstIndexData[indexDataIdx++] = vertexId + 0;\n            dstIndexData[indexDataIdx++] = vertexId + 1;\n            dstIndexData[indexDataIdx++] = vertexId + 2;\n\n            dstIndexData[indexDataIdx++] = vertexId + 1;\n            dstIndexData[indexDataIdx++] = vertexId + 3;\n            dstIndexData[indexDataIdx++] = vertexId + 2;\n            vertexId += 4;\n        }\n    }\n\n    let drawCallIdx = drawCall.srcOffs;\n    for (let j = 0; j < drawCall.vertexCount; j++) {\n" + compileVatFormats() + "\n        dstVertexDataOffs += " + loadedVertexLayout.dstVertexSize + ";\n    }\n}\n\nif (dstIndexData.length !== totalTriangleCount * 3)\n    throw new Error(\"Number of indexes does not match triangle count\");\n\nreturn { indexFormat: " + 1 /* U16 */ + ", indexData: dstIndexData.buffer, packedVertexData: dstVertexData, totalVertexCount: totalVertexCount, totalTriangleCount: totalTriangleCount };\n\n};\n";
        var runVerticesGenerator = new Function(source);
        var runVertices = runVerticesGenerator();
        return { loadedVertexLayout: loadedVertexLayout, runVertices: runVertices };
    }
    var MemoizeCache_2, util_11, endian_2, VtxLoaderCache, cache, compileVtxLoader, compileVtxLoaderMultiVat;
    return {
        setters: [
            function (MemoizeCache_2_1) {
                MemoizeCache_2 = MemoizeCache_2_1;
            },
            function (util_11_1) {
                util_11 = util_11_1;
            },
            function (endian_2_1) {
                endian_2 = endian_2_1;
            }
        ],
        execute: function () {
            VtxLoaderCache = /** @class */ (function (_super) {
                __extends(VtxLoaderCache, _super);
                function VtxLoaderCache() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.compileVtxLoader = function (vatFormat, vcd) {
                        var vat = [vatFormat];
                        return _this.get({ vat: vat, vcd: vcd });
                    };
                    _this.compileVtxLoaderMultiVat = function (vat, vcd) {
                        return _this.get({ vat: vat, vcd: vcd });
                    };
                    return _this;
                }
                VtxLoaderCache.prototype.make = function (key) {
                    return _compileVtxLoader(key.vat, key.vcd);
                };
                VtxLoaderCache.prototype.makeKey = function (key) {
                    return JSON.stringify(key);
                };
                return VtxLoaderCache;
            }(MemoizeCache_2.default));
            cache = new VtxLoaderCache();
            exports_25("compileVtxLoader", compileVtxLoader = cache.compileVtxLoader);
            exports_25("compileVtxLoaderMultiVat", compileVtxLoaderMultiVat = cache.compileVtxLoaderMultiVat);
        }
    };
});
// GX materials.
System.register("gx/gx_material", ["render", "Program", "Color"], function (exports_26, context_26) {
    "use strict";
    var __moduleName = context_26 && context_26.id;
    function getVertexAttribLocation(vtxAttrib) {
        return vtxAttributeGenDefs.findIndex(function (genDef) { return genDef.attrib === vtxAttrib; });
    }
    exports_26("getVertexAttribLocation", getVertexAttribLocation);
    function getVertexAttribGenDef(vtxAttrib) {
        return vtxAttributeGenDefs.find(function (genDef) { return genDef.attrib === vtxAttrib; });
    }
    exports_26("getVertexAttribGenDef", getVertexAttribGenDef);
    // #endregion
    // #region Material flags generation.
    function translateCullMode(cullMode) {
        switch (cullMode) {
            case 3 /* ALL */:
                return render_2.CullMode.FRONT_AND_BACK;
            case 1 /* FRONT */:
                return render_2.CullMode.FRONT;
            case 2 /* BACK */:
                return render_2.CullMode.BACK;
            case 0 /* NONE */:
                return render_2.CullMode.NONE;
        }
    }
    function translateBlendFactorCommon(blendFactor) {
        switch (blendFactor) {
            case 0 /* ZERO */:
                return render_2.BlendFactor.ZERO;
            case 1 /* ONE */:
                return render_2.BlendFactor.ONE;
            case 4 /* SRCALPHA */:
                return render_2.BlendFactor.SRC_ALPHA;
            case 5 /* INVSRCALPHA */:
                return render_2.BlendFactor.ONE_MINUS_SRC_ALPHA;
            case 6 /* DSTALPHA */:
                return render_2.BlendFactor.DST_ALPHA;
            case 7 /* INVDSTALPHA */:
                return render_2.BlendFactor.ONE_MINUS_DST_ALPHA;
            default:
                throw new Error("whoops");
        }
    }
    function translateBlendSrcFactor(blendFactor) {
        switch (blendFactor) {
            case 2 /* SRCCLR */:
                return render_2.BlendFactor.DST_COLOR;
            case 3 /* INVSRCCLR */:
                return render_2.BlendFactor.ONE_MINUS_DST_COLOR;
            default:
                return translateBlendFactorCommon(blendFactor);
        }
    }
    function translateBlendDstFactor(blendFactor) {
        switch (blendFactor) {
            case 2 /* SRCCLR */:
                return render_2.BlendFactor.SRC_COLOR;
            case 3 /* INVSRCCLR */:
                return render_2.BlendFactor.ONE_MINUS_SRC_COLOR;
            default:
                return translateBlendFactorCommon(blendFactor);
        }
    }
    function translateCompareType(compareType) {
        switch (compareType) {
            case 0 /* NEVER */:
                return render_2.CompareMode.NEVER;
            case 1 /* LESS */:
                return render_2.CompareMode.LESS;
            case 2 /* EQUAL */:
                return render_2.CompareMode.EQUAL;
            case 3 /* LEQUAL */:
                return render_2.CompareMode.LEQUAL;
            case 4 /* GREATER */:
                return render_2.CompareMode.GREATER;
            case 5 /* NEQUAL */:
                return render_2.CompareMode.NEQUAL;
            case 6 /* GEQUAL */:
                return render_2.CompareMode.GEQUAL;
            case 7 /* ALWAYS */:
                return render_2.CompareMode.ALWAYS;
        }
    }
    function translateRenderFlags(material) {
        var renderFlags = new render_2.RenderFlags();
        renderFlags.cullMode = translateCullMode(material.cullMode);
        renderFlags.depthWrite = material.ropInfo.depthWrite;
        renderFlags.depthTest = material.ropInfo.depthTest;
        renderFlags.depthFunc = translateCompareType(material.ropInfo.depthFunc);
        renderFlags.frontFace = render_2.FrontFaceMode.CW;
        if (material.ropInfo.blendMode.type === 0 /* NONE */) {
            renderFlags.blendMode = render_2.BlendMode.NONE;
        }
        else if (material.ropInfo.blendMode.type === 1 /* BLEND */) {
            renderFlags.blendMode = render_2.BlendMode.ADD;
            renderFlags.blendSrc = translateBlendSrcFactor(material.ropInfo.blendMode.srcFactor);
            renderFlags.blendDst = translateBlendDstFactor(material.ropInfo.blendMode.dstFactor);
        }
        else if (material.ropInfo.blendMode.type === 3 /* SUBTRACT */) {
            renderFlags.blendMode = render_2.BlendMode.REVERSE_SUBTRACT;
            renderFlags.blendSrc = render_2.BlendFactor.ONE;
            renderFlags.blendDst = render_2.BlendFactor.ONE;
        }
        else if (material.ropInfo.blendMode.type === 2 /* LOGIC */) {
            throw new Error("whoops");
        }
        return renderFlags;
    }
    exports_26("translateRenderFlags", translateRenderFlags);
    // #endregion
    function getRasColorChannelID(v) {
        switch (v) {
            case 0 /* COLOR0 */:
            case 2 /* ALPHA0 */:
            case 4 /* COLOR0A0 */:
                return 0 /* COLOR0A0 */;
            case 1 /* COLOR1 */:
            case 3 /* ALPHA1 */:
            case 5 /* COLOR1A1 */:
                return 1 /* COLOR1A1 */;
            case 7 /* ALPHA_BUMP */:
                return 5 /* ALPHA_BUMP */;
            case 8 /* ALPHA_BUMP_N */:
                return 6 /* ALPHA_BUMP_N */;
            case 6 /* COLOR_ZERO */:
            case 255 /* COLOR_NULL */:
                return 7 /* COLOR_ZERO */;
            default:
                throw "whoops";
        }
    }
    exports_26("getRasColorChannelID", getRasColorChannelID);
    var render_2, Program_3, Color_1, EFB_WIDTH, EFB_HEIGHT, Color, vtxAttributeGenDefs, textureSamplerIdentities, GX_Program;
    return {
        setters: [
            function (render_2_1) {
                render_2 = render_2_1;
            },
            function (Program_3_1) {
                Program_3 = Program_3_1;
            },
            function (Color_1_1) {
                Color_1 = Color_1_1;
            }
        ],
        execute: function () {
            // TODO(jstpierre): Move somewhere better...
            exports_26("EFB_WIDTH", EFB_WIDTH = 640);
            exports_26("EFB_HEIGHT", EFB_HEIGHT = 528);
            Color = /** @class */ (function () {
                function Color(r, g, b, a) {
                    if (r === void 0) { r = 0; }
                    if (g === void 0) { g = 0; }
                    if (b === void 0) { b = 0; }
                    if (a === void 0) { a = 0; }
                    this.r = r;
                    this.g = g;
                    this.b = b;
                    this.a = a;
                }
                Color.prototype.set = function (r, g, b, a) {
                    this.r = r;
                    this.g = g;
                    this.b = b;
                    this.a = a;
                };
                Color.prototype.copy = function (c, a) {
                    if (a === void 0) { a = c.a; }
                    return Color_1.colorCopy(this, c, a);
                };
                Color.prototype.copy32 = function (c) {
                    return Color_1.colorFromRGBA8(this, c);
                };
                Color.prototype.get32 = function () {
                    return Color_1.colorToRGBA8(this);
                };
                return Color;
            }());
            exports_26("Color", Color);
            vtxAttributeGenDefs = [
                { attrib: 0 /* PNMTXIDX */, name: "PosMtxIdx", storage: "uint" },
                { attrib: 9 /* POS */, name: "Position", storage: "vec3" },
                { attrib: 10 /* NRM */, name: "Normal", storage: "vec3" },
                { attrib: 11 /* CLR0 */, name: "Color0", storage: "vec4" },
                { attrib: 12 /* CLR1 */, name: "Color1", storage: "vec4" },
                { attrib: 13 /* TEX0 */, name: "Tex0", storage: "vec2" },
                { attrib: 14 /* TEX1 */, name: "Tex1", storage: "vec2" },
                { attrib: 15 /* TEX2 */, name: "Tex2", storage: "vec2" },
                { attrib: 16 /* TEX3 */, name: "Tex3", storage: "vec2" },
                { attrib: 17 /* TEX4 */, name: "Tex4", storage: "vec2" },
                { attrib: 18 /* TEX5 */, name: "Tex5", storage: "vec2" },
                { attrib: 19 /* TEX6 */, name: "Tex6", storage: "vec2" },
                { attrib: 20 /* TEX7 */, name: "Tex7", storage: "vec2" },
            ];
            textureSamplerIdentities = Int32Array.of(0, 1, 2, 3, 4, 5, 6, 7);
            GX_Program = /** @class */ (function (_super) {
                __extends(GX_Program, _super);
                function GX_Program(material, hacks) {
                    if (hacks === void 0) { hacks = null; }
                    var _this = _super.call(this) || this;
                    _this.material = material;
                    _this.hacks = hacks;
                    _this.generateShaders();
                    return _this;
                }
                GX_Program.prototype.bind = function (gl, prog) {
                    gl.uniformBlockBinding(prog, gl.getUniformBlockIndex(prog, "ub_SceneParams"), GX_Program.ub_SceneParams);
                    gl.uniformBlockBinding(prog, gl.getUniformBlockIndex(prog, "ub_MaterialParams"), GX_Program.ub_MaterialParams);
                    gl.uniformBlockBinding(prog, gl.getUniformBlockIndex(prog, "ub_PacketParams"), GX_Program.ub_PacketParams);
                    this.u_Texture = gl.getUniformLocation(prog, "u_Texture");
                };
                GX_Program.prototype.bindTextureSamplerIdentities = function (gl) {
                    gl.uniform1iv(this.u_Texture, textureSamplerIdentities);
                };
                GX_Program.prototype.generateFloat = function (v) {
                    var s = v.toString();
                    if (!s.includes('.'))
                        s += '.0';
                    return s;
                };
                GX_Program.prototype.generateColorConstant = function (c) {
                    return "vec4(" + c.r + ", " + c.g + ", " + c.b + ", " + c.a + ")";
                };
                // Color Channels
                GX_Program.prototype.generateMaterialSource = function (chan, i) {
                    switch (chan.matColorSource) {
                        case 1 /* VTX */: return "a_Color" + i;
                        case 0 /* REG */: return "u_ColorMatReg[" + i + "]";
                    }
                };
                GX_Program.prototype.generateAmbientSource = function (chan, i) {
                    switch (chan.ambColorSource) {
                        case 1 /* VTX */: return "a_Color" + i;
                        case 0 /* REG */: return "u_ColorAmbReg[" + i + "]";
                    }
                };
                GX_Program.prototype.generateColorChannel = function (chan, i, isAlpha) {
                    // TODO(jstpierre): amb & lighting
                    var matSource = this.generateMaterialSource(chan, i);
                    if (chan.lightingEnabled) {
                        var ambSource = this.generateAmbientSource(chan, i);
                        // HACK.
                        if (this.hacks) {
                            var fudger = isAlpha ? this.hacks.alphaLightingFudge : this.hacks.colorLightingFudge;
                            if (fudger) {
                                var vtx = "a_Color" + i;
                                var amb = "u_ColorAmbReg[" + i + "]";
                                var mat = "u_ColorMatReg[" + i + "]";
                                var fudged = fudger({ vtx: vtx, amb: amb, mat: mat, ambSource: ambSource, matSource: matSource });
                                return "vec4(" + fudged + ")";
                            }
                        }
                        // XXX(jstpierre): This is awful but seems to work.
                        return "(0.5 * (" + ambSource + " + 0.6) * " + matSource + ")";
                    }
                    else {
                        // If lighting is off, it's the material color.
                        return matSource;
                    }
                };
                GX_Program.prototype.generateLightChannel = function (lightChannel, i) {
                    return "vec4(" + this.generateColorChannel(lightChannel.colorChannel, i, false) + ".rgb, " + this.generateColorChannel(lightChannel.alphaChannel, i, true) + ".a)";
                };
                GX_Program.prototype.generateLightChannels = function () {
                    var _this = this;
                    return this.material.lightChannels.map(function (lightChannel, i) {
                        return "    v_Color" + i + " = " + _this.generateLightChannel(lightChannel, i) + ";";
                    }).join('\n');
                };
                // TexGen
                GX_Program.prototype.generateTexGenSource = function (src) {
                    switch (src) {
                        case 0 /* POS */: return "vec4(a_Position, 1.0)";
                        case 1 /* NRM */: return "vec4(a_Normal, 1.0)";
                        case 19 /* COLOR0 */: return "a_Color0";
                        case 20 /* COLOR1 */: return "a_Color1";
                        case 4 /* TEX0 */: return "vec4(a_Tex0, 1.0, 1.0)";
                        case 5 /* TEX1 */: return "vec4(a_Tex1, 1.0, 1.0)";
                        case 6 /* TEX2 */: return "vec4(a_Tex2, 1.0, 1.0)";
                        case 7 /* TEX3 */: return "vec4(a_Tex3, 1.0, 1.0)";
                        case 8 /* TEX4 */: return "vec4(a_Tex4, 1.0, 1.0)";
                        case 9 /* TEX5 */: return "vec4(a_Tex5, 1.0, 1.0)";
                        case 10 /* TEX6 */: return "vec4(a_Tex6, 1.0, 1.0)";
                        case 11 /* TEX7 */: return "vec4(a_Tex7, 1.0, 1.0)";
                        // Use a previously generated texcoordgen.
                        case 12 /* TEXCOORD0 */: return "vec4(v_TexCoord0, 1.0)";
                        case 13 /* TEXCOORD1 */: return "vec4(v_TexCoord1, 1.0)";
                        case 14 /* TEXCOORD2 */: return "vec4(v_TexCoord2, 1.0)";
                        case 15 /* TEXCOORD3 */: return "vec4(v_TexCoord3, 1.0)";
                        case 16 /* TEXCOORD4 */: return "vec4(v_TexCoord4, 1.0)";
                        case 17 /* TEXCOORD5 */: return "vec4(v_TexCoord5, 1.0)";
                        case 18 /* TEXCOORD6 */: return "vec4(v_TexCoord6, 1.0)";
                        default:
                            throw new Error("whoops");
                    }
                };
                GX_Program.prototype.generateTexGenMatrix = function (src, texCoordGen) {
                    var matrix = texCoordGen.matrix;
                    if (matrix === 60 /* IDENTITY */) {
                        return src + ".xyz";
                    }
                    else if (matrix >= 30 /* TEXMTX0 */) {
                        var texMtxIdx = (matrix - 30 /* TEXMTX0 */) / 3;
                        return "(u_TexMtx[" + texMtxIdx + "] * " + src + ")";
                    }
                    else if (matrix >= 0 /* PNMTX0 */) {
                        var pnMtxIdx = (matrix - 0 /* PNMTX0 */) / 3;
                        return "(u_PosMtx[" + pnMtxIdx + "] * " + src + ")";
                    }
                    else {
                        throw "whoops";
                    }
                };
                GX_Program.prototype.generateTexGenType = function (texCoordGen) {
                    var src = this.generateTexGenSource(texCoordGen.source);
                    switch (texCoordGen.type) {
                        case 10 /* SRTG */:
                            // Expected to be used with colors, I suspect...
                            return src + ".xyz";
                        case 1 /* MTX2x4 */:
                            if (texCoordGen.matrix === 60 /* IDENTITY */)
                                return src + ".xyz";
                            return "vec3(" + this.generateTexGenMatrix(src, texCoordGen) + ".xy, 1.0)";
                        case 0 /* MTX3x4 */:
                            return "" + this.generateTexGenMatrix(src, texCoordGen);
                        default:
                            throw new Error("whoops");
                    }
                };
                GX_Program.prototype.generateTexGenNrm = function (texCoordGen) {
                    var type = this.generateTexGenType(texCoordGen);
                    if (texCoordGen.normalize)
                        return "normalize(" + type + ")";
                    else
                        return type;
                };
                GX_Program.prototype.generateTexGenPost = function (texCoordGen) {
                    var tex = this.generateTexGenNrm(texCoordGen);
                    if (texCoordGen.postMatrix === 125 /* PTIDENTITY */) {
                        return tex;
                    }
                    else {
                        var matrixIdx = (texCoordGen.postMatrix - 64 /* PTTEXMTX0 */) / 3;
                        return "u_PostTexMtx[" + matrixIdx + "] * vec4(" + tex + ", 1.0)";
                    }
                };
                GX_Program.prototype.generateTexGen = function (texCoordGen) {
                    var i = texCoordGen.index;
                    return "\n    // TexGen " + i + "  Type: " + texCoordGen.type + " Source: " + texCoordGen.source + " Matrix: " + texCoordGen.matrix + "\n    v_TexCoord" + i + " = " + this.generateTexGenPost(texCoordGen) + ";";
                };
                GX_Program.prototype.generateTexGens = function (texGens) {
                    var _this = this;
                    return texGens.map(function (tg) {
                        return _this.generateTexGen(tg);
                    }).join('');
                };
                GX_Program.prototype.generateTexCoordGetters = function () {
                    return this.material.texGens.map(function (n, i) {
                        return "vec2 ReadTexCoord" + i + "() { return v_TexCoord" + i + ".xy / v_TexCoord" + i + ".z; }\n";
                    }).join('');
                };
                // IndTex
                GX_Program.prototype.generateIndTexStageScaleN = function (scale) {
                    switch (scale) {
                        case 0 /* _1 */: return "1.0";
                        case 1 /* _2 */: return "1.0/2.0";
                        case 2 /* _4 */: return "1.0/4.0";
                        case 3 /* _8 */: return "1.0/8.0";
                        case 4 /* _16 */: return "1.0/16.0";
                        case 5 /* _32 */: return "1.0/32.0";
                        case 6 /* _64 */: return "1.0/64.0";
                        case 7 /* _128 */: return "1.0/128.0";
                        case 8 /* _256 */: return "1.0/256.0";
                    }
                };
                GX_Program.prototype.generateIndTexStageScale = function (stage) {
                    var baseCoord = "ReadTexCoord" + stage.texCoordId + "()";
                    if (stage.scaleS === 0 /* _1 */ && stage.scaleT === 0 /* _1 */)
                        return baseCoord;
                    else
                        return baseCoord + " * vec2(" + this.generateIndTexStageScaleN(stage.scaleS) + ", " + this.generateIndTexStageScaleN(stage.scaleT) + ")";
                };
                GX_Program.prototype.generateIndTexStage = function (stage) {
                    var i = stage.index;
                    return "\n    // Indirect " + i + "\n    vec3 t_IndTexCoord" + i + " = TextureSample(" + stage.texture + ", " + this.generateIndTexStageScale(stage) + ").abg;";
                };
                GX_Program.prototype.generateIndTexStages = function (stages) {
                    var _this = this;
                    return stages.map(function (stage) {
                        return _this.generateIndTexStage(stage);
                    }).join('');
                };
                // TEV
                GX_Program.prototype.generateKonstColorSel = function (konstColor) {
                    switch (konstColor) {
                        case 0 /* KCSEL_1 */: return 'vec3(8.0/8.0)';
                        case 1 /* KCSEL_7_8 */: return 'vec3(7.0/8.0)';
                        case 2 /* KCSEL_3_4 */: return 'vec3(6.0/8.0)';
                        case 3 /* KCSEL_5_8 */: return 'vec3(5.0/8.0)';
                        case 4 /* KCSEL_1_2 */: return 'vec3(4.0/8.0)';
                        case 5 /* KCSEL_3_8 */: return 'vec3(3.0/8.0)';
                        case 6 /* KCSEL_1_4 */: return 'vec3(2.0/8.0)';
                        case 7 /* KCSEL_1_8 */: return 'vec3(1.0/8.0)';
                        case 12 /* KCSEL_K0 */: return 's_kColor0.rgb';
                        case 16 /* KCSEL_K0_R */: return 's_kColor0.rrr';
                        case 20 /* KCSEL_K0_G */: return 's_kColor0.ggg';
                        case 24 /* KCSEL_K0_B */: return 's_kColor0.bbb';
                        case 28 /* KCSEL_K0_A */: return 's_kColor0.aaa';
                        case 13 /* KCSEL_K1 */: return 's_kColor1.rgb';
                        case 17 /* KCSEL_K1_R */: return 's_kColor1.rrr';
                        case 21 /* KCSEL_K1_G */: return 's_kColor1.ggg';
                        case 25 /* KCSEL_K1_B */: return 's_kColor1.bbb';
                        case 29 /* KCSEL_K1_A */: return 's_kColor1.aaa';
                        case 14 /* KCSEL_K2 */: return 's_kColor2.rgb';
                        case 18 /* KCSEL_K2_R */: return 's_kColor2.rrr';
                        case 22 /* KCSEL_K2_G */: return 's_kColor2.ggg';
                        case 26 /* KCSEL_K2_B */: return 's_kColor2.bbb';
                        case 30 /* KCSEL_K2_A */: return 's_kColor2.aaa';
                        case 15 /* KCSEL_K3 */: return 's_kColor3.rgb';
                        case 19 /* KCSEL_K3_R */: return 's_kColor3.rrr';
                        case 23 /* KCSEL_K3_G */: return 's_kColor3.ggg';
                        case 27 /* KCSEL_K3_B */: return 's_kColor3.bbb';
                        case 31 /* KCSEL_K3_A */: return 's_kColor3.aaa';
                    }
                };
                GX_Program.prototype.generateKonstAlphaSel = function (konstAlpha) {
                    switch (konstAlpha) {
                        case 0 /* KASEL_1 */: return '(8.0/8.0)';
                        case 1 /* KASEL_7_8 */: return '(7.0/8.0)';
                        case 2 /* KASEL_3_4 */: return '(6.0/8.0)';
                        case 3 /* KASEL_5_8 */: return '(5.0/8.0)';
                        case 4 /* KASEL_1_2 */: return '(4.0/8.0)';
                        case 5 /* KASEL_3_8 */: return '(3.0/8.0)';
                        case 6 /* KASEL_1_4 */: return '(2.0/8.0)';
                        case 7 /* KASEL_1_8 */: return '(1.0/8.0)';
                        case 16 /* KASEL_K0_R */: return 's_kColor0.r';
                        case 20 /* KASEL_K0_G */: return 's_kColor0.g';
                        case 24 /* KASEL_K0_B */: return 's_kColor0.b';
                        case 28 /* KASEL_K0_A */: return 's_kColor0.a';
                        case 17 /* KASEL_K1_R */: return 's_kColor1.r';
                        case 21 /* KASEL_K1_G */: return 's_kColor1.g';
                        case 25 /* KASEL_K1_B */: return 's_kColor1.b';
                        case 29 /* KASEL_K1_A */: return 's_kColor1.a';
                        case 18 /* KASEL_K2_R */: return 's_kColor2.r';
                        case 22 /* KASEL_K2_G */: return 's_kColor2.g';
                        case 26 /* KASEL_K2_B */: return 's_kColor2.b';
                        case 30 /* KASEL_K2_A */: return 's_kColor2.a';
                        case 19 /* KASEL_K3_R */: return 's_kColor3.r';
                        case 23 /* KASEL_K3_G */: return 's_kColor3.g';
                        case 27 /* KASEL_K3_B */: return 's_kColor3.b';
                        case 31 /* KASEL_K3_A */: return 's_kColor3.a';
                    }
                };
                GX_Program.prototype.generateRas = function (stage) {
                    switch (stage.channelId) {
                        case 0 /* COLOR0A0 */: return "v_Color0";
                        case 1 /* COLOR1A1 */: return "v_Color1";
                        case 7 /* COLOR_ZERO */: return "vec4(0, 0, 0, 0)";
                        default:
                            throw new Error("whoops " + stage.channelId);
                    }
                };
                GX_Program.prototype.generateTexAccess = function (stage) {
                    // Skyward Sword is amazing sometimes. I hope you're happy...
                    // assert(stage.texMap !== GX.TexMapID.TEXMAP_NULL);
                    if (stage.texMap === 255 /* TEXMAP_NULL */)
                        return 'vec4(1.0, 1.0, 1.0, 1.0)';
                    return "TextureSample(" + stage.texMap + ", t_TexCoord)";
                };
                GX_Program.prototype.generateColorIn = function (stage, colorIn) {
                    var i = stage.index;
                    switch (colorIn) {
                        case 0 /* CPREV */: return "t_ColorPrev.rgb";
                        case 1 /* APREV */: return "t_ColorPrev.aaa";
                        case 2 /* C0 */: return "t_Color0.rgb";
                        case 3 /* A0 */: return "t_Color0.aaa";
                        case 4 /* C1 */: return "t_Color1.rgb";
                        case 5 /* A1 */: return "t_Color1.aaa";
                        case 6 /* C2 */: return "t_Color2.rgb";
                        case 7 /* A2 */: return "t_Color2.aaa";
                        case 8 /* TEXC */: return this.generateTexAccess(stage) + ".rgb";
                        case 9 /* TEXA */: return this.generateTexAccess(stage) + ".aaa";
                        case 10 /* RASC */: return this.generateRas(stage) + ".rgb";
                        case 11 /* RASA */: return this.generateRas(stage) + ".aaa";
                        case 12 /* ONE */: return "vec3(1)";
                        case 13 /* HALF */: return "vec3(1.0/2.0)";
                        case 14 /* KONST */: return "" + this.generateKonstColorSel(stage.konstColorSel);
                        case 15 /* ZERO */: return "vec3(0)";
                    }
                };
                GX_Program.prototype.generateAlphaIn = function (stage, alphaIn) {
                    var i = stage.index;
                    switch (alphaIn) {
                        case 0 /* APREV */: return "t_ColorPrev.a";
                        case 1 /* A0 */: return "t_Color0.a";
                        case 2 /* A1 */: return "t_Color1.a";
                        case 3 /* A2 */: return "t_Color2.a";
                        case 4 /* TEXA */: return this.generateTexAccess(stage) + ".a";
                        case 5 /* RASA */: return this.generateRas(stage) + ".a";
                        case 6 /* KONST */: return "" + this.generateKonstAlphaSel(stage.konstAlphaSel);
                        case 7 /* ZERO */: return "0.0";
                    }
                };
                GX_Program.prototype.generateTevInputs = function (stage) {
                    return ("\n    t_TevA = TevOverflow(vec4(" + this.generateColorIn(stage, stage.colorInA) + ", " + this.generateAlphaIn(stage, stage.alphaInA) + "));\n    t_TevB = TevOverflow(vec4(" + this.generateColorIn(stage, stage.colorInB) + ", " + this.generateAlphaIn(stage, stage.alphaInB) + "));\n    t_TevC = TevOverflow(vec4(" + this.generateColorIn(stage, stage.colorInC) + ", " + this.generateAlphaIn(stage, stage.alphaInC) + "));\n    t_TevD = TevOverflow(vec4(" + this.generateColorIn(stage, stage.colorInD) + ", " + this.generateAlphaIn(stage, stage.alphaInD) + "));\n").trim();
                };
                GX_Program.prototype.generateTevRegister = function (regId) {
                    switch (regId) {
                        case 0 /* PREV */: return "t_ColorPrev";
                        case 1 /* REG0 */: return "t_Color0";
                        case 2 /* REG1 */: return "t_Color1";
                        case 3 /* REG2 */: return "t_Color2";
                    }
                };
                GX_Program.prototype.generateTevOpBiasScaleClamp = function (value, bias, scale) {
                    var v = value;
                    if (bias === 1 /* ADDHALF */)
                        v = "TevBias(" + v + ", 0.5)";
                    else if (bias === 2 /* SUBHALF */)
                        v = "TevBias(" + v + ", -0.5)";
                    if (scale === 1 /* SCALE_2 */)
                        v = "(" + v + ") * 2.0";
                    else if (scale === 2 /* SCALE_4 */)
                        v = "(" + v + ") * 4.0";
                    else if (scale === 3 /* DIVIDE_2 */)
                        v = "(" + v + ") * 0.5";
                    return v;
                };
                GX_Program.prototype.generateTevOp = function (op, bias, scale, a, b, c, d, zero) {
                    switch (op) {
                        case 0 /* ADD */:
                        case 1 /* SUB */:
                            var neg = (op === 1 /* SUB */) ? '-' : '';
                            var v = neg + "mix(" + a + ", " + b + ", " + c + ") + " + d;
                            return this.generateTevOpBiasScaleClamp(v, bias, scale);
                        case 8 /* COMP_R8_GT */: return "((t_TevA.r >  t_TevB.r) ? " + c + " : " + zero + ") + " + d;
                        case 9 /* COMP_R8_EQ */: return "((t_TevA.r == t_TevB.r) ? " + c + " : " + zero + ") + " + d;
                        case 10 /* COMP_GR16_GT */: return "((TevPack16(t_TevA.rg) >  TevPack16(t_TevB.rg)) ? " + c + " : " + zero + ") + " + d;
                        case 11 /* COMP_GR16_EQ */: return "((TevPack16(t_TevA.rg) == TevPack16(t_TevB.rg)) ? " + c + " : " + zero + ") + " + d;
                        case 14 /* COMP_RGB8_GT */: return "(TevPerCompGT(" + a + ", " + b + ") * " + c + ") + " + d;
                        case 15 /* COMP_RGB8_EQ */: return "(TevPerCompEQ(" + a + ", " + b + ") * " + c + ") + " + d;
                        default:
                            throw new Error("whoops");
                    }
                };
                GX_Program.prototype.generateTevOpValue = function (op, bias, scale, clamp, a, b, c, d, zero) {
                    var expr = this.generateTevOp(op, bias, scale, a, b, c, d, zero);
                    if (clamp)
                        return "TevSaturate(" + expr + ")";
                    else
                        return expr;
                };
                GX_Program.prototype.generateColorOp = function (stage) {
                    var a = "t_TevA.rgb", b = "t_TevB.rgb", c = "t_TevC.rgb", d = "t_TevD.rgb", zero = "vec3(0)";
                    var value = this.generateTevOpValue(stage.colorOp, stage.colorBias, stage.colorScale, stage.colorClamp, a, b, c, d, zero);
                    return this.generateTevRegister(stage.colorRegId) + ".rgb = " + value + ";";
                };
                GX_Program.prototype.generateAlphaOp = function (stage) {
                    var a = "t_TevA.a", b = "t_TevB.a", c = "t_TevC.a", d = "t_TevD.a", zero = '0.0';
                    var value = this.generateTevOpValue(stage.alphaOp, stage.alphaBias, stage.alphaScale, stage.alphaClamp, a, b, c, d, zero);
                    return this.generateTevRegister(stage.alphaRegId) + ".a = " + value + ";";
                };
                GX_Program.prototype.generateTevTexCoordWrapN = function (texCoord, wrap) {
                    switch (wrap) {
                        case 0 /* OFF */: return texCoord;
                        case 6 /* _0 */: return '0.0';
                        case 1 /* _256 */: return "mod(" + texCoord + ", 256.0)";
                        case 2 /* _128 */: return "mod(" + texCoord + ", 128.0)";
                        case 3 /* _64 */: return "mod(" + texCoord + ", 64.0)";
                        case 4 /* _32 */: return "mod(" + texCoord + ", 32.0)";
                        case 5 /* _16 */: return "mod(" + texCoord + ", 16.0)";
                    }
                };
                GX_Program.prototype.generateTevTexCoordWrap = function (stage) {
                    var lastTexGenId = this.material.texGens.length - 1;
                    var texGenId = stage.texCoordId;
                    if (texGenId >= lastTexGenId)
                        texGenId = lastTexGenId;
                    if (texGenId < 0)
                        return "vec2(0.0, 0.0)";
                    var baseCoord = "ReadTexCoord" + texGenId + "()";
                    if (stage.indTexWrapS === 0 /* OFF */ && stage.indTexWrapT === 0 /* OFF */)
                        return baseCoord;
                    else
                        return "vec2(" + this.generateTevTexCoordWrapN(baseCoord + ".x", stage.indTexWrapS) + ", " + this.generateTevTexCoordWrapN(baseCoord + ".y", stage.indTexWrapT) + ")";
                };
                GX_Program.prototype.generateTevTexCoordIndTexCoordBias = function (stage) {
                    var bias = (stage.indTexFormat === 0 /* _8 */) ? '-128.0' : "1.0";
                    switch (stage.indTexBiasSel) {
                        case 0 /* NONE */: return "";
                        case 1 /* S */: return " + vec3(" + bias + ", 0.0, 0.0)";
                        case 3 /* ST */: return " + vec3(" + bias + ", " + bias + ", 0.0)";
                        case 5 /* SU */: return " + vec3(" + bias + ", 0.0, " + bias + ")";
                        case 2 /* T */: return " + vec3(0.0, " + bias + ", 0.0)";
                        case 6 /* TU */: return " + vec3(0.0, " + bias + ", " + bias + ")";
                        case 4 /* U */: return " + vec3(0.0, 0.0, " + bias + ")";
                        case 7 /* STU */: return " + vec3(" + bias + ")";
                    }
                };
                GX_Program.prototype.generateTevTexCoordIndTexCoord = function (stage) {
                    var baseCoord = "(t_IndTexCoord" + stage.indTexStage + " * 255.0)";
                    switch (stage.indTexFormat) {
                        case 0 /* _8 */: return baseCoord;
                        default:
                        case 1 /* _5 */: throw new Error("whoops");
                    }
                };
                GX_Program.prototype.generateTevTexCoordIndirectMtx = function (stage) {
                    var indTevCoord = "(" + this.generateTevTexCoordIndTexCoord(stage) + this.generateTevTexCoordIndTexCoordBias(stage) + ")";
                    switch (stage.indTexMatrix) {
                        case 1 /* _0 */: return "(u_IndTexMtx[0] * vec4(" + indTevCoord + ", 0.0))";
                        case 2 /* _1 */: return "(u_IndTexMtx[1] * vec4(" + indTevCoord + ", 0.0))";
                        case 3 /* _2 */: return "(u_IndTexMtx[2] * vec4(" + indTevCoord + ", 0.0))";
                        default:
                        case 0 /* OFF */: throw new Error("whoops");
                    }
                };
                GX_Program.prototype.generateTevTexCoordIndirectTranslation = function (stage) {
                    return "(" + this.generateTevTexCoordIndirectMtx(stage) + " / TextureSize(" + stage.texCoordId + "))";
                };
                GX_Program.prototype.generateTevTexCoordIndirect = function (stage) {
                    var baseCoord = this.generateTevTexCoordWrap(stage);
                    if (stage.indTexMatrix !== 0 /* OFF */ && stage.indTexStage < this.material.indTexStages.length)
                        return baseCoord + " + " + this.generateTevTexCoordIndirectTranslation(stage);
                    else
                        return baseCoord;
                };
                GX_Program.prototype.generateTevTexCoord = function (stage) {
                    if (stage.texCoordId === 255 /* NULL */)
                        return '';
                    var finalCoord = this.generateTevTexCoordIndirect(stage);
                    if (stage.indTexAddPrev) {
                        return "t_TexCoord += " + finalCoord + ";";
                    }
                    else {
                        return "t_TexCoord = " + finalCoord + ";";
                    }
                };
                GX_Program.prototype.generateTevStage = function (stage) {
                    var i = stage.index;
                    return "\n    // TEV Stage " + i + "\n    " + this.generateTevTexCoord(stage) + "\n    // Color Combine\n    // colorIn: " + stage.colorInA + " " + stage.colorInB + " " + stage.colorInC + " " + stage.colorInD + "  colorOp: " + stage.colorOp + " colorBias: " + stage.colorBias + " colorScale: " + stage.colorScale + " colorClamp: " + stage.colorClamp + " colorRegId: " + stage.colorRegId + "\n    // alphaIn: " + stage.alphaInA + " " + stage.alphaInB + " " + stage.alphaInC + " " + stage.alphaInD + "  alphaOp: " + stage.alphaOp + " alphaBias: " + stage.alphaBias + " alphaScale: " + stage.alphaScale + " alphaClamp: " + stage.alphaClamp + " alphaRegId: " + stage.alphaRegId + "\n    // texCoordId: " + stage.texCoordId + " texMap: " + stage.texMap + " channelId: " + stage.channelId + "\n    " + this.generateTevInputs(stage) + "\n    " + this.generateColorOp(stage) + "\n    " + this.generateAlphaOp(stage);
                };
                GX_Program.prototype.generateTevStages = function (tevStages) {
                    var _this = this;
                    return tevStages.map(function (s) { return _this.generateTevStage(s); }).join("\n");
                };
                GX_Program.prototype.generateTevStagesLastMinuteFixup = function (tevStages) {
                    // Despite having a destination register, the output of the last stage
                    // is what gets output from the color combinations...
                    var lastTevStage = tevStages[tevStages.length - 1];
                    var colorReg = this.generateTevRegister(lastTevStage.colorRegId);
                    var alphaReg = this.generateTevRegister(lastTevStage.alphaRegId);
                    if (colorReg === alphaReg) {
                        return "\n    vec4 t_TevOutput = " + colorReg + ";";
                    }
                    else {
                        return "\n    vec4 t_TevOutput = vec4(" + colorReg + ".rgb, " + alphaReg + ".a);";
                    }
                };
                GX_Program.prototype.generateAlphaTestCompare = function (compare, reference) {
                    var ref = this.generateFloat(reference);
                    switch (compare) {
                        case 0 /* NEVER */: return "false";
                        case 1 /* LESS */: return "t_TevOutput.a <  " + ref;
                        case 2 /* EQUAL */: return "t_TevOutput.a == " + ref;
                        case 3 /* LEQUAL */: return "t_TevOutput.a <= " + ref;
                        case 4 /* GREATER */: return "t_TevOutput.a >  " + ref;
                        case 5 /* NEQUAL */: return "t_TevOutput.a != " + ref;
                        case 6 /* GEQUAL */: return "t_TevOutput.a >= " + ref;
                        case 7 /* ALWAYS */: return "true";
                    }
                };
                GX_Program.prototype.generateAlphaTestOp = function (op) {
                    switch (op) {
                        case 0 /* AND */: return "t_AlphaTestA && t_AlphaTestB";
                        case 1 /* OR */: return "t_AlphaTestA || t_AlphaTestB";
                        case 2 /* XOR */: return "t_AlphaTestA != t_AlphaTestB";
                        case 3 /* XNOR */: return "t_AlphaTestA == t_AlphaTestB";
                    }
                };
                GX_Program.prototype.generateAlphaTest = function (alphaTest) {
                    return "\n    // Alpha Test: Op " + alphaTest.op + "\n    // Compare A: " + alphaTest.compareA + " Reference A: " + this.generateFloat(alphaTest.referenceA) + "\n    // Compare B: " + alphaTest.compareB + " Reference B: " + this.generateFloat(alphaTest.referenceB) + "\n    bool t_AlphaTestA = " + this.generateAlphaTestCompare(alphaTest.compareA, alphaTest.referenceA) + ";\n    bool t_AlphaTestB = " + this.generateAlphaTestCompare(alphaTest.compareB, alphaTest.referenceB) + ";\n    if (!(" + this.generateAlphaTestOp(alphaTest.op) + "))\n        discard;\n";
                };
                GX_Program.prototype.generateVertAttributeDefs = function () {
                    return vtxAttributeGenDefs.map(function (a, i) {
                        return "layout(location = " + i + ") in " + a.storage + " a_" + a.name + ";";
                    }).join('\n');
                };
                GX_Program.prototype.generateUBO = function () {
                    return "\n// Expected to be constant across the entire scene.\nlayout(row_major, std140) uniform ub_SceneParams {\n    mat4 u_Projection;\n    vec4 u_Misc0;\n};\n\n#define u_SceneTextureLODBias u_Misc0[0]\n\n// Expected to change with each material.\nlayout(row_major, std140) uniform ub_MaterialParams {\n    vec4 u_ColorMatReg[2];\n    vec4 u_ColorAmbReg[2];\n    vec4 u_KonstColor[4];\n    vec4 u_Color[4];\n    mat4x3 u_TexMtx[10];\n    mat4x3 u_PostTexMtx[20];\n    mat4x2 u_IndTexMtx[3];\n    // SizeX, SizeY, 0, Bias\n    vec4 u_TextureParams[8];\n};\n\n// Expected to change with each shape packet.\nlayout(row_major, std140) uniform ub_PacketParams {\n    mat4x3 u_PosMtx[10];\n};\n";
                };
                GX_Program.prototype.generateShaders = function () {
                    var ubo = this.generateUBO();
                    this.vert = "\n// " + this.material.name + "\nprecision mediump float;\n" + ubo + "\n" + this.generateVertAttributeDefs() + "\nout vec3 v_Position;\nout vec3 v_Normal;\nout vec4 v_Color0;\nout vec4 v_Color1;\nout vec3 v_TexCoord0;\nout vec3 v_TexCoord1;\nout vec3 v_TexCoord2;\nout vec3 v_TexCoord3;\nout vec3 v_TexCoord4;\nout vec3 v_TexCoord5;\nout vec3 v_TexCoord6;\nout vec3 v_TexCoord7;\n\nmat4 GetPosTexMatrix(uint mtxid) {\n    if (mtxid == " + 60 /* IDENTITY */ + "u)\n        return mat4(1.0);\n    else if (mtxid >= " + 30 /* TEXMTX0 */ + "u)\n        return mat4(u_TexMtx[(mtxid - 30u) / 3u]);\n    else\n        return mat4(u_PosMtx[mtxid / 3u]);\n}\n\nvoid main() {\n    mat4 t_PosMtx = GetPosTexMatrix(a_PosMtxIdx);\n    mat4 t_PosModelView = t_PosMtx;\n    vec4 t_Position = t_PosModelView * vec4(a_Position, 1.0);\n    v_Position = t_Position.xyz;\n    v_Normal = a_Normal;\n" + this.generateLightChannels() + "\n" + this.generateTexGens(this.material.texGens) + "\n    gl_Position = u_Projection * t_Position;\n}\n";
                    var tevStages = this.material.tevStages;
                    var indTexStages = this.material.indTexStages;
                    var alphaTest = this.material.alphaTest;
                    var kColors = this.material.colorConstants;
                    var rColors = this.material.colorRegisters;
                    this.frag = "\n// " + this.material.name + "\nprecision mediump float;\n" + ubo + "\nuniform sampler2D u_Texture[8];\n\nin vec3 v_Position;\nin vec3 v_Normal;\nin vec4 v_Color0;\nin vec4 v_Color1;\nin vec3 v_TexCoord0;\nin vec3 v_TexCoord1;\nin vec3 v_TexCoord2;\nin vec3 v_TexCoord3;\nin vec3 v_TexCoord4;\nin vec3 v_TexCoord5;\nin vec3 v_TexCoord6;\nin vec3 v_TexCoord7;\n" + this.generateTexCoordGetters() + "\n\nfloat TextureLODBias(int index) { return u_SceneTextureLODBias + u_TextureParams[index].w; }\nvec2 TextureSize(int index) { return u_TextureParams[index].xy; }\nvec4 TextureSample(int index, vec2 coord) { return texture(u_Texture[index], coord, TextureLODBias(index)); }\n\nvec3 TevBias(vec3 a, float b) { return a + vec3(b); }\nfloat TevBias(float a, float b) { return a + b; }\nvec3 TevSaturate(vec3 a) { return clamp(a, vec3(0), vec3(1)); }\nfloat TevSaturate(float a) { return clamp(a, 0.0, 1.0); }\nfloat TevOverflow(float a) { return float(int(a * 255.0) % 256) / 255.0; }\nvec4 TevOverflow(vec4 a) { return vec4(TevOverflow(a.r), TevOverflow(a.g), TevOverflow(a.b), TevOverflow(a.a)); }\nfloat TevPack16(vec2 a) { return dot(a, vec2(1.0, 256.0)); }\nfloat TevPack24(vec3 a) { return dot(a, vec3(1.0, 256.0, 256.0 * 256.0)); }\nfloat TevPerCompGT(float a, float b) { return float(a >  b); }\nfloat TevPerCompEQ(float a, float b) { return float(a == b); }\nvec3 TevPerCompGT(vec3 a, vec3 b) { return vec3(greaterThan(a, b)); }\nvec3 TevPerCompEQ(vec3 a, vec3 b) { return vec3(greaterThan(a, b)); }\n\nvoid main() {\n    vec4 s_kColor0   = u_KonstColor[0]; // " + this.generateColorConstant(kColors[0]) + "\n    vec4 s_kColor1   = u_KonstColor[1]; // " + this.generateColorConstant(kColors[1]) + "\n    vec4 s_kColor2   = u_KonstColor[2]; // " + this.generateColorConstant(kColors[2]) + "\n    vec4 s_kColor3   = u_KonstColor[3]; // " + this.generateColorConstant(kColors[3]) + "\n\n    vec4 t_ColorPrev = u_Color[0]; // " + this.generateColorConstant(rColors[0 /* PREV */]) + "\n    vec4 t_Color0    = u_Color[1]; // " + this.generateColorConstant(rColors[1 /* REG0 */]) + "\n    vec4 t_Color1    = u_Color[2]; // " + this.generateColorConstant(rColors[2 /* REG1 */]) + "\n    vec4 t_Color2    = u_Color[3]; // " + this.generateColorConstant(rColors[3 /* REG2 */]) + "\n\n    vec2 t_TexCoord = vec2(0.0, 0.0);\n" + this.generateIndTexStages(indTexStages) + "\n    vec4 t_TevA, t_TevB, t_TevC, t_TevD;\n" + this.generateTevStages(tevStages) + "\n\n" + this.generateTevStagesLastMinuteFixup(tevStages) + "\n    t_TevOutput = TevOverflow(t_TevOutput);\n" + this.generateAlphaTest(alphaTest) + "\n    gl_FragColor = t_TevOutput;\n}\n";
                };
                GX_Program.ub_SceneParams = 0;
                GX_Program.ub_MaterialParams = 1;
                GX_Program.ub_PacketParams = 2;
                return GX_Program;
            }(Program_3.BaseProgram));
            exports_26("GX_Program", GX_Program);
        }
    };
});
// GX texture decoding
System.register("gx/gx_texture", ["ArrayBufferSlice", "util", "wat_modules", "WasmMemoryManager"], function (exports_27, context_27) {
    "use strict";
    var __moduleName = context_27 && context_27.id;
    function calcPaletteSize(format, palette) {
        var paletteSize = 0;
        switch (format) {
            case 8 /* C4 */:
                paletteSize = 16;
                break;
            case 9 /* C8 */:
                paletteSize = 256;
                break;
            case 10 /* C14X2 */:
            default:
                throw new Error("whoops");
        }
        // All palette-formats are 16-bit.
        return paletteSize * 2;
    }
    exports_27("calcPaletteSize", calcPaletteSize);
    function calcTextureSize(format, width, height) {
        var numPixels = width * height;
        switch (format) {
            case 0 /* I4 */:
                return numPixels / 2;
            case 1 /* I8 */:
                return numPixels;
            case 2 /* IA4 */:
                return numPixels;
            case 3 /* IA8 */:
                return numPixels * 2;
            case 8 /* C4 */:
                return numPixels / 2;
            case 9 /* C8 */:
                return numPixels;
            case 4 /* RGB565 */:
                return numPixels * 2;
            case 5 /* RGB5A3 */:
                return numPixels * 2;
            case 6 /* RGBA8 */:
                return numPixels * 4;
            case 14 /* CMPR */:
                return numPixels / 2;
            default:
                throw new Error("whoops");
        }
    }
    exports_27("calcTextureSize", calcTextureSize);
    function calcMipChain(texture, mipCount) {
        if (mipCount === void 0) { mipCount = 0xFF; }
        var mipLevels = [];
        var name = texture.name;
        var textureSize = 0;
        var mipLevel = 0;
        var format = texture.format;
        var width = texture.width;
        var height = texture.height;
        while (width > 0 && height > 0 && mipLevel < mipCount) {
            var mipSize = calcTextureSize(format, width, height);
            var data = texture.data !== null ? texture.data.subarray(textureSize) : null;
            mipLevels.push({ name: texture.name + " mip level " + mipLevel, format: format, width: width, height: height, data: data });
            mipLevel++;
            textureSize += mipSize;
            width /= 2;
            height /= 2;
        }
        return { name: name, mipLevels: mipLevels, fullTextureSize: textureSize };
    }
    exports_27("calcMipChain", calcMipChain);
    function decode_Wasm(wasmInstance, texture, decoder, scratchSize) {
        if (scratchSize === void 0) { scratchSize = 0; }
        var dstSize = texture.width * texture.height * 4;
        var srcSize = texture.data.byteLength;
        var pScratch = 0;
        var pDst = util_12.align(pScratch + scratchSize, 0x10);
        var pSrc = util_12.align(pDst + dstSize, 0x10);
        var heapSize = util_12.align(pSrc + srcSize, 0x10);
        var wasmMemory = new WasmMemoryManager_2.default(wasmInstance.memory);
        var heap = wasmMemory.resize(heapSize);
        // Copy src buffer.
        heap.set(texture.data.createTypedArray(Uint8Array), pSrc);
        decoder(pScratch, pDst, pSrc, texture.width, texture.height);
        // Copy the result buffer to a new buffer for memory usage purposes.
        var pixelsBuffer = new ArrayBufferSlice_3.default(heap.buffer).copyToBuffer(pDst, dstSize);
        var pixels = new Uint8Array(pixelsBuffer);
        return { pixels: pixels };
    }
    function decode_Dummy(texture) {
        var pixels = new Uint8Array(texture.width * texture.height * 4);
        pixels.fill(0xFF);
        return { pixels: pixels };
    }
    function getFormatName(format) {
        switch (format) {
            case 0 /* I4 */:
                return "I4";
            case 1 /* I8 */:
                return "I8";
            case 2 /* IA4 */:
                return "IA4";
            case 3 /* IA8 */:
                return "IA8";
            case 4 /* RGB565 */:
                return "RGB565";
            case 5 /* RGB5A3 */:
                return "RGB5A3";
            case 6 /* RGBA8 */:
                return "RGBA8";
            case 14 /* CMPR */:
                return "CMPR";
            case 8 /* C4 */:
                return "C4 (TODO)";
            case 9 /* C8 */:
                return "C8 (TODO)";
            case 10 /* C14X2 */:
                return "C14X2 (TODO)";
            default:
                return "invalid";
        }
    }
    exports_27("getFormatName", getFormatName);
    function decodeTexture(texture) {
        if (texture.data === null)
            return Promise.resolve(decode_Dummy(texture));
        return _wasmInstance.then(function (wasmInstance) {
            switch (texture.format) {
                case 0 /* I4 */:
                    return decode_Wasm(wasmInstance, texture, wasmInstance.decode_I4);
                case 1 /* I8 */:
                    return decode_Wasm(wasmInstance, texture, wasmInstance.decode_I8);
                case 2 /* IA4 */:
                    return decode_Wasm(wasmInstance, texture, wasmInstance.decode_IA4);
                case 3 /* IA8 */:
                    return decode_Wasm(wasmInstance, texture, wasmInstance.decode_IA8);
                case 4 /* RGB565 */:
                    return decode_Wasm(wasmInstance, texture, wasmInstance.decode_RGB565);
                case 5 /* RGB5A3 */:
                    return decode_Wasm(wasmInstance, texture, wasmInstance.decode_RGB5A3);
                case 6 /* RGBA8 */:
                    return decode_Wasm(wasmInstance, texture, wasmInstance.decode_RGBA8);
                case 14 /* CMPR */:
                    return decode_Wasm(wasmInstance, texture, wasmInstance.decode_CMPR, 16);
                case 8 /* C4 */:
                case 9 /* C8 */:
                case 10 /* C14X2 */:
                default:
                    console.error("Unsupported texture format " + texture.format + " on texture " + texture.name);
                    return decode_Dummy(texture);
            }
        });
    }
    exports_27("decodeTexture", decodeTexture);
    var ArrayBufferSlice_3, util_12, wat_modules_2, WasmMemoryManager_2, _wasmInstance;
    return {
        setters: [
            function (ArrayBufferSlice_3_1) {
                ArrayBufferSlice_3 = ArrayBufferSlice_3_1;
            },
            function (util_12_1) {
                util_12 = util_12_1;
            },
            function (wat_modules_2_1) {
                wat_modules_2 = wat_modules_2_1;
            },
            function (WasmMemoryManager_2_1) {
                WasmMemoryManager_2 = WasmMemoryManager_2_1;
            }
        ],
        execute: function () {
            // XXX(jstpierre): Firefox has GC pressure when constructing new WebAssembly.Memory instances
            // on 64-bit machines. Construct a global WebAssembly.Memory and use it. Remove this when the
            // bug is fixed. https://bugzilla.mozilla.org/show_bug.cgi?id=1459761#c5
            _wasmInstance = wat_modules_2.gx_texture_asInstance();
        }
    };
});
// Common helpers for GX rendering.
System.register("gx/gx_render", ["gl-matrix", "gx/gx_material", "gx/gx_texture", "util", "BufferCoalescer", "ArrayBufferSlice"], function (exports_28, context_28) {
    "use strict";
    var __moduleName = context_28 && context_28.id;
    function fillVec4(d, offs, v0, v1, v2, v3) {
        if (v1 === void 0) { v1 = 0; }
        if (v2 === void 0) { v2 = 0; }
        if (v3 === void 0) { v3 = 0; }
        d[offs + 0] = v0;
        d[offs + 1] = v1;
        d[offs + 2] = v2;
        d[offs + 3] = v3;
        return 4;
    }
    function fillColor(d, offs, c) {
        d[offs + 0] = c.r;
        d[offs + 1] = c.g;
        d[offs + 2] = c.b;
        d[offs + 3] = c.a;
        return 4;
    }
    // All of our matrices are row-major.
    function fillMatrix4x4(d, offs, m) {
        d[offs + 0] = m[0];
        d[offs + 1] = m[4];
        d[offs + 2] = m[8];
        d[offs + 3] = m[12];
        d[offs + 4] = m[1];
        d[offs + 5] = m[5];
        d[offs + 6] = m[9];
        d[offs + 7] = m[13];
        d[offs + 8] = m[2];
        d[offs + 9] = m[6];
        d[offs + 10] = m[10];
        d[offs + 11] = m[14];
        d[offs + 12] = m[3];
        d[offs + 13] = m[7];
        d[offs + 14] = m[11];
        d[offs + 15] = m[15];
        return 4 * 4;
    }
    function fillMatrix4x3(d, offs, m) {
        d[offs + 0] = m[0];
        d[offs + 1] = m[4];
        d[offs + 2] = m[8];
        d[offs + 3] = m[12];
        d[offs + 4] = m[1];
        d[offs + 5] = m[5];
        d[offs + 6] = m[9];
        d[offs + 7] = m[13];
        d[offs + 8] = m[2];
        d[offs + 9] = m[6];
        d[offs + 10] = m[10];
        d[offs + 11] = m[14];
        return 4 * 3;
    }
    function fillMatrix3x2(d, offs, m) {
        // 3x2 matrices are actually sent across as 4x2.
        var ma = m[0], mb = m[1];
        var mc = m[2], md = m[3];
        var mx = m[4], my = m[5];
        d[offs + 0] = ma;
        d[offs + 1] = mc;
        d[offs + 2] = mx;
        d[offs + 3] = 0;
        d[offs + 4] = mb;
        d[offs + 5] = md;
        d[offs + 6] = my;
        d[offs + 7] = 0;
        return 4 * 2;
    }
    function fillSceneParamsData(d, sceneParams) {
        var offs = 0;
        offs += fillMatrix4x4(d, offs, sceneParams.u_Projection);
        // u_Misc0
        offs += fillVec4(d, offs, sceneParams.u_SceneTextureLODBias);
        util_13.assert(offs === u_SceneParamsBufferSize);
        util_13.assert(d.length >= offs);
    }
    exports_28("fillSceneParamsData", fillSceneParamsData);
    function fillMaterialParamsData(d, materialParams) {
        // Texture mapping requires special effort.
        var offs = 0;
        for (var i = 0; i < 2; i++)
            offs += fillColor(d, offs, materialParams.u_ColorMatReg[i]);
        for (var i = 0; i < 2; i++)
            offs += fillColor(d, offs, materialParams.u_ColorAmbReg[i]);
        for (var i = 0; i < 4; i++)
            offs += fillColor(d, offs, materialParams.u_KonstColor[i]);
        for (var i = 0; i < 4; i++)
            offs += fillColor(d, offs, materialParams.u_Color[i]);
        for (var i = 0; i < 10; i++)
            offs += fillMatrix4x3(d, offs, materialParams.u_TexMtx[i]);
        for (var i = 0; i < 20; i++)
            offs += fillMatrix4x3(d, offs, materialParams.u_PostTexMtx[i]);
        for (var i = 0; i < 3; i++)
            offs += fillMatrix3x2(d, offs, materialParams.u_IndTexMtx[i]);
        for (var i = 0; i < 8; i++)
            offs += fillVec4(d, offs, materialParams.m_TextureMapping[i].width, materialParams.m_TextureMapping[i].height, 0, materialParams.m_TextureMapping[i].lodBias);
        util_13.assert(offs === u_MaterialParamsBufferSize);
        util_13.assert(d.length >= offs);
    }
    exports_28("fillMaterialParamsData", fillMaterialParamsData);
    function fillPacketParamsData(d, packetParams) {
        var offs = 0;
        for (var i = 0; i < 10; i++)
            offs += fillMatrix4x3(d, offs, packetParams.u_PosMtx[i]);
        util_13.assert(offs === u_PacketParamsBufferSize);
        util_13.assert(d.length >= offs);
    }
    exports_28("fillPacketParamsData", fillPacketParamsData);
    function translateAttribType(gl, attribFormat) {
        switch (attribFormat) {
            case 0 /* U8 */:
                return { type: gl.UNSIGNED_BYTE, normalized: false };
            case 1 /* U16 */:
                return { type: gl.UNSIGNED_SHORT, normalized: false };
            case 2 /* F32 */:
                return { type: gl.FLOAT, normalized: false };
            default:
                throw "whoops";
        }
    }
    // Mip levels in GX are assumed to be relative to the GameCube's embedded framebuffer (EFB) size,
    // which is hardcoded to be 640x528. We need to bias our mipmap LOD selection by this amount to
    // make sure textures are sampled correctly...
    function getTextureLODBias(state) {
        var viewportWidth = state.onscreenColorTarget.width;
        var viewportHeight = state.onscreenColorTarget.height;
        var textureLODBias = Math.log2(Math.min(viewportWidth / GX_Material.EFB_WIDTH, viewportHeight / GX_Material.EFB_HEIGHT));
        return textureLODBias;
    }
    exports_28("getTextureLODBias", getTextureLODBias);
    function fillSceneParamsFromRenderState(sceneParams, state) {
        gl_matrix_4.mat4.copy(sceneParams.u_Projection, state.camera.projectionMatrix);
        sceneParams.u_SceneTextureLODBias = getTextureLODBias(state);
    }
    exports_28("fillSceneParamsFromRenderState", fillSceneParamsFromRenderState);
    function loadedDataCoalescer(gl, loadedVertexDatas) {
        return new BufferCoalescer_1.default(gl, loadedVertexDatas.map(function (data) { return new ArrayBufferSlice_4.default(data.packedVertexData); }), loadedVertexDatas.map(function (data) { return new ArrayBufferSlice_4.default(data.indexData); }));
    }
    exports_28("loadedDataCoalescer", loadedDataCoalescer);
    function loadTextureFromMipChain(gl, mipChain) {
        var glTexture = gl.createTexture();
        glTexture.name = mipChain.name;
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAX_LEVEL, mipChain.mipLevels.length - 1);
        var surfaces = [];
        var _loop_5 = function (i) {
            var level = i;
            var mipLevel = mipChain.mipLevels[i];
            var canvas = document.createElement('canvas');
            canvas.width = mipLevel.width;
            canvas.height = mipLevel.height;
            canvas.title = mipLevel.name;
            surfaces.push(canvas);
            GX_Texture.decodeTexture(mipLevel).then(function (rgbaTexture) {
                gl.bindTexture(gl.TEXTURE_2D, glTexture);
                gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA8, mipLevel.width, mipLevel.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, rgbaTexture.pixels);
                var ctx = canvas.getContext('2d');
                var imgData = new ImageData(mipLevel.width, mipLevel.height);
                imgData.data.set(new Uint8Array(rgbaTexture.pixels.buffer));
                ctx.putImageData(imgData, 0, 0);
            });
        };
        for (var i = 0; i < mipChain.mipLevels.length; i++) {
            _loop_5(i);
        }
        var viewerExtraInfo = new Map();
        viewerExtraInfo.set('Format', GX_Texture.getFormatName(mipChain.mipLevels[0].format));
        var viewerTexture = { name: mipChain.name, surfaces: surfaces, extraInfo: viewerExtraInfo };
        return { glTexture: glTexture, viewerTexture: viewerTexture };
    }
    exports_28("loadTextureFromMipChain", loadTextureFromMipChain);
    function translateTexFilter(gl, texFilter) {
        switch (texFilter) {
            case 3 /* LIN_MIP_NEAR */:
                return gl.LINEAR_MIPMAP_NEAREST;
            case 5 /* LIN_MIP_LIN */:
                return gl.LINEAR_MIPMAP_LINEAR;
            case 1 /* LINEAR */:
                return gl.LINEAR;
            case 2 /* NEAR_MIP_NEAR */:
                return gl.NEAREST_MIPMAP_NEAREST;
            case 4 /* NEAR_MIP_LIN */:
                return gl.NEAREST_MIPMAP_LINEAR;
            case 0 /* NEAR */:
                return gl.NEAREST;
        }
    }
    exports_28("translateTexFilter", translateTexFilter);
    function translateWrapMode(gl, wrapMode) {
        switch (wrapMode) {
            case 0 /* CLAMP */:
                return gl.CLAMP_TO_EDGE;
            case 2 /* MIRROR */:
                return gl.MIRRORED_REPEAT;
            case 1 /* REPEAT */:
                return gl.REPEAT;
        }
    }
    exports_28("translateWrapMode", translateWrapMode);
    var gl_matrix_4, GX_Material, GX_Texture, util_13, BufferCoalescer_1, ArrayBufferSlice_4, SceneParams, TextureMapping, MaterialParams, PacketParams, u_PacketParamsBufferSize, u_MaterialParamsBufferSize, u_SceneParamsBufferSize, bufferDataScratchSize, GXRenderHelper, GXShapeHelper, TextureHolder;
    return {
        setters: [
            function (gl_matrix_4_1) {
                gl_matrix_4 = gl_matrix_4_1;
            },
            function (GX_Material_1) {
                GX_Material = GX_Material_1;
            },
            function (GX_Texture_1) {
                GX_Texture = GX_Texture_1;
            },
            function (util_13_1) {
                util_13 = util_13_1;
            },
            function (BufferCoalescer_1_1) {
                BufferCoalescer_1 = BufferCoalescer_1_1;
            },
            function (ArrayBufferSlice_4_1) {
                ArrayBufferSlice_4 = ArrayBufferSlice_4_1;
            }
        ],
        execute: function () {
            SceneParams = /** @class */ (function () {
                function SceneParams() {
                    this.u_Projection = gl_matrix_4.mat4.create();
                    // u_Misc0
                    this.u_SceneTextureLODBias = 0;
                }
                return SceneParams;
            }());
            exports_28("SceneParams", SceneParams);
            TextureMapping = /** @class */ (function () {
                function TextureMapping() {
                    this.glTexture = null;
                    this.glSampler = null;
                    this.width = 0;
                    this.height = 0;
                    this.lodBias = 0;
                    // GL fucking sucks. This is a convenience when building texture matrices.
                    // gx_render does *not* use this parameter at all!
                    this.flipY = false;
                }
                return TextureMapping;
            }());
            exports_28("TextureMapping", TextureMapping);
            MaterialParams = /** @class */ (function () {
                function MaterialParams() {
                    this.m_TextureMapping = util_13.nArray(8, function () { return new TextureMapping(); });
                    this.u_ColorMatReg = util_13.nArray(2, function () { return new GX_Material.Color(); });
                    this.u_ColorAmbReg = util_13.nArray(2, function () { return new GX_Material.Color(); });
                    this.u_KonstColor = util_13.nArray(4, function () { return new GX_Material.Color(); });
                    this.u_Color = util_13.nArray(4, function () { return new GX_Material.Color(); });
                    this.u_TexMtx = util_13.nArray(10, function () { return gl_matrix_4.mat4.create(); }); // mat4x3
                    this.u_PostTexMtx = util_13.nArray(20, function () { return gl_matrix_4.mat4.create(); }); // mat4x3
                    this.u_IndTexMtx = util_13.nArray(3, function () { return gl_matrix_4.mat2d.create(); }); // mat4x2
                }
                return MaterialParams;
            }());
            exports_28("MaterialParams", MaterialParams);
            PacketParams = /** @class */ (function () {
                function PacketParams() {
                    this.u_PosMtx = util_13.nArray(10, function () { return gl_matrix_4.mat4.create(); });
                }
                return PacketParams;
            }());
            exports_28("PacketParams", PacketParams);
            exports_28("u_PacketParamsBufferSize", u_PacketParamsBufferSize = 4 * 3 * 10);
            exports_28("u_MaterialParamsBufferSize", u_MaterialParamsBufferSize = 4 * 2 + 4 * 2 + 4 * 4 + 4 * 4 + 4 * 3 * 10 + 4 * 3 * 20 + 4 * 2 * 3 + 4 * 8);
            exports_28("u_SceneParamsBufferSize", u_SceneParamsBufferSize = 4 * 4 + 4);
            bufferDataScratchSize = Math.max(u_PacketParamsBufferSize, u_MaterialParamsBufferSize, u_SceneParamsBufferSize);
            GXRenderHelper = /** @class */ (function () {
                function GXRenderHelper(gl) {
                    this.bufferDataScratch = new Float32Array(bufferDataScratchSize);
                    this.sceneParamsBuffer = gl.createBuffer();
                    this.materialParamsBuffer = gl.createBuffer();
                    this.packetParamsBuffer = gl.createBuffer();
                }
                GXRenderHelper.prototype.bindSceneParams = function (state, params) {
                    var gl = state.gl;
                    fillSceneParamsData(this.bufferDataScratch, params);
                    gl.bindBuffer(gl.UNIFORM_BUFFER, this.sceneParamsBuffer);
                    gl.bufferData(gl.UNIFORM_BUFFER, this.bufferDataScratch, gl.DYNAMIC_DRAW);
                };
                GXRenderHelper.prototype.bindMaterialParams = function (state, params) {
                    var gl = state.gl;
                    fillMaterialParamsData(this.bufferDataScratch, params);
                    gl.bindBuffer(gl.UNIFORM_BUFFER, this.materialParamsBuffer);
                    gl.bufferData(gl.UNIFORM_BUFFER, this.bufferDataScratch, gl.DYNAMIC_DRAW);
                };
                GXRenderHelper.prototype.bindPacketParams = function (state, params) {
                    var gl = state.gl;
                    fillPacketParamsData(this.bufferDataScratch, params);
                    gl.bindBuffer(gl.UNIFORM_BUFFER, this.packetParamsBuffer);
                    gl.bufferData(gl.UNIFORM_BUFFER, this.bufferDataScratch, gl.DYNAMIC_DRAW);
                };
                GXRenderHelper.prototype.bindMaterialTextureMapping = function (state, textureMapping, prog) {
                    var gl = state.gl;
                    util_13.assert(prog === state.currentProgram);
                    for (var i = 0; i < 8; i++) {
                        var m = textureMapping[i];
                        if (m.glTexture === null)
                            continue;
                        gl.activeTexture(gl.TEXTURE0 + i);
                        gl.bindTexture(gl.TEXTURE_2D, m.glTexture);
                        gl.bindSampler(i, m.glSampler);
                    }
                    prog.bindTextureSamplerIdentities(gl);
                };
                GXRenderHelper.prototype.bindMaterialTextures = function (state, materialParams, prog) {
                    var gl = state.gl;
                    this.bindMaterialTextureMapping(state, materialParams.m_TextureMapping, prog);
                };
                GXRenderHelper.prototype.bindUniformBuffers = function (state) {
                    var gl = state.gl;
                    gl.bindBufferBase(gl.UNIFORM_BUFFER, GX_Material.GX_Program.ub_SceneParams, this.sceneParamsBuffer);
                    gl.bindBufferBase(gl.UNIFORM_BUFFER, GX_Material.GX_Program.ub_MaterialParams, this.materialParamsBuffer);
                    gl.bindBufferBase(gl.UNIFORM_BUFFER, GX_Material.GX_Program.ub_PacketParams, this.packetParamsBuffer);
                };
                GXRenderHelper.prototype.destroy = function (gl) {
                    gl.deleteBuffer(this.packetParamsBuffer);
                    gl.deleteBuffer(this.materialParamsBuffer);
                    gl.deleteBuffer(this.sceneParamsBuffer);
                };
                return GXRenderHelper;
            }());
            exports_28("GXRenderHelper", GXRenderHelper);
            GXShapeHelper = /** @class */ (function () {
                function GXShapeHelper(gl, coalescedBuffers, loadedVertexLayout, loadedVertexData) {
                    this.coalescedBuffers = coalescedBuffers;
                    this.loadedVertexLayout = loadedVertexLayout;
                    this.loadedVertexData = loadedVertexData;
                    util_13.assert(this.loadedVertexData.indexFormat === 1 /* U16 */);
                    this.vao = gl.createVertexArray();
                    gl.bindVertexArray(this.vao);
                    gl.bindBuffer(gl.ARRAY_BUFFER, coalescedBuffers.vertexBuffer.buffer);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, coalescedBuffers.indexBuffer.buffer);
                    var _loop_6 = function (vtxAttrib) {
                        var attribLocation = GX_Material.getVertexAttribLocation(vtxAttrib);
                        // TODO(jstpierre): Handle TEXMTXIDX attributes.
                        if (attribLocation === -1)
                            return "continue";
                        var attribGenDef = GX_Material.getVertexAttribGenDef(vtxAttrib);
                        var attrib = this_3.loadedVertexLayout.dstVertexAttributeLayouts.find(function (attrib) { return attrib.vtxAttrib === vtxAttrib; });
                        if (attrib !== undefined) {
                            var _a = translateAttribType(gl, attrib.format), type = _a.type, normalized = _a.normalized;
                            var stride = this_3.loadedVertexLayout.dstVertexSize;
                            var offset = coalescedBuffers.vertexBuffer.offset + attrib.offset;
                            gl.enableVertexAttribArray(attribLocation);
                            switch (attribGenDef.storage) {
                                case 'uint':
                                    gl.vertexAttribIPointer(attribLocation, attrib.componentCount, type, stride, offset);
                                    break;
                                case 'vec2':
                                case 'vec3':
                                case 'vec4':
                                    gl.vertexAttribPointer(attribLocation, attrib.componentCount, type, normalized, stride, offset);
                                    break;
                                default:
                                    throw "whoops";
                            }
                        }
                        else {
                            // Set default.
                            switch (attribGenDef.storage) {
                                case 'uint':
                                    gl.vertexAttribI4ui(attribLocation, 0, 0, 0, 0);
                                case 'vec2':
                                case 'vec3':
                                case 'vec4':
                                    // Float defaults don't need to be initialized in GLES.
                                    break;
                                default:
                                    throw "whoops";
                            }
                        }
                    };
                    var this_3 = this;
                    for (var vtxAttrib = 0; vtxAttrib < 20 /* MAX */; vtxAttrib++) {
                        _loop_6(vtxAttrib);
                    }
                    gl.bindVertexArray(null);
                }
                GXShapeHelper.prototype.destroy = function (gl) {
                    gl.deleteVertexArray(this.vao);
                };
                GXShapeHelper.prototype.drawPrologue = function (gl) {
                    gl.bindVertexArray(this.vao);
                };
                GXShapeHelper.prototype.drawEpilogue = function (gl) {
                    gl.bindVertexArray(null);
                };
                GXShapeHelper.prototype.drawTriangles = function (gl, firstTriangle, numTriangles) {
                    var firstVertex = firstTriangle * 3;
                    var numVertices = numTriangles * 3;
                    var indexType = gl.UNSIGNED_SHORT, indexByteSize = 2;
                    var indexBufferOffset = this.coalescedBuffers.indexBuffer.offset + (firstVertex * indexByteSize);
                    gl.drawElements(gl.TRIANGLES, numVertices, indexType, indexBufferOffset);
                };
                GXShapeHelper.prototype.drawSimple = function (gl) {
                    this.drawPrologue(gl);
                    this.drawTriangles(gl, 0, this.loadedVertexData.totalTriangleCount);
                    this.drawEpilogue(gl);
                };
                return GXShapeHelper;
            }());
            exports_28("GXShapeHelper", GXShapeHelper);
            TextureHolder = /** @class */ (function () {
                function TextureHolder() {
                    this.viewerTextures = [];
                    this.glTextures = [];
                    this.textureEntries = [];
                    this.textureOverrides = new Map();
                }
                TextureHolder.prototype.destroy = function (gl) {
                    this.glTextures.forEach(function (texture) { return gl.deleteTexture(texture); });
                };
                // TODO(jstpierre): Optimize interface to not require an array construct every frame...
                TextureHolder.prototype.tryTextureNameVariants = function (name) {
                    // Default implementation.
                    return null;
                };
                TextureHolder.prototype.findTextureEntryIndex = function (name) {
                    var nameVariants = this.tryTextureNameVariants(name);
                    if (nameVariants !== null) {
                        for (var j = 0; j < nameVariants.length; j++) {
                            for (var i = 0; i < this.textureEntries.length; i++) {
                                if (this.textureEntries[i].name === nameVariants[j])
                                    return i;
                            }
                        }
                    }
                    else {
                        for (var i = 0; i < this.textureEntries.length; i++) {
                            if (this.textureEntries[i].name === name)
                                return i;
                        }
                    }
                    // console.error("Cannot find texture", name);
                    return -1;
                };
                TextureHolder.prototype.hasTexture = function (name) {
                    return this.findTextureEntryIndex(name) >= 0;
                };
                TextureHolder.prototype.fillTextureMapping = function (textureMapping, name) {
                    var textureOverride = this.textureOverrides.get(name);
                    if (textureOverride) {
                        textureMapping.glTexture = textureOverride.glTexture;
                        textureMapping.width = textureOverride.width;
                        textureMapping.height = textureOverride.height;
                        textureMapping.flipY = textureOverride.flipY;
                        return true;
                    }
                    var textureEntryIndex = this.findTextureEntryIndex(name);
                    if (textureEntryIndex >= 0) {
                        textureMapping.glTexture = this.glTextures[textureEntryIndex];
                        var tex0Entry = this.textureEntries[textureEntryIndex];
                        textureMapping.width = tex0Entry.width;
                        textureMapping.height = tex0Entry.height;
                        textureMapping.flipY = false;
                        return true;
                    }
                    return false;
                };
                TextureHolder.prototype.setTextureOverride = function (name, textureOverride) {
                    // Only allow setting texture overrides for textures that exist.
                    // TODO(jstpierre): Bring this back when I fix ZTP scene loader.
                    // if (!this.hasTexture(name))
                    //    throw new Error(`Trying to override non-existent texture ${name}`);
                    this.textureOverrides.set(name, textureOverride);
                };
                TextureHolder.prototype.addTextures = function (gl, textureEntries) {
                    var _loop_7 = function (texture) {
                        // Don't add textures without data.
                        if (texture.data === null)
                            return "continue";
                        // Don't add dupes for the same name.
                        if (this_4.textureEntries.find(function (entry) { return entry.name === texture.name; }) !== undefined)
                            return "continue";
                        var mipChain = GX_Texture.calcMipChain(texture, texture.mipCount);
                        var _a = loadTextureFromMipChain(gl, mipChain), glTexture = _a.glTexture, viewerTexture = _a.viewerTexture;
                        this_4.textureEntries.push(texture);
                        this_4.glTextures.push(glTexture);
                        this_4.viewerTextures.push(viewerTexture);
                    };
                    var this_4 = this;
                    try {
                        for (var textureEntries_1 = __values(textureEntries), textureEntries_1_1 = textureEntries_1.next(); !textureEntries_1_1.done; textureEntries_1_1 = textureEntries_1.next()) {
                            var texture = textureEntries_1_1.value;
                            _loop_7(texture);
                        }
                    }
                    catch (e_25_1) { e_25 = { error: e_25_1 }; }
                    finally {
                        try {
                            if (textureEntries_1_1 && !textureEntries_1_1.done && (_a = textureEntries_1.return)) _a.call(textureEntries_1);
                        }
                        finally { if (e_25) throw e_25.error; }
                    }
                    var e_25, _a;
                };
                return TextureHolder;
            }());
            exports_28("TextureHolder", TextureHolder);
        }
    };
});
System.register("j3d/render", ["gl-matrix", "j3d/j3d", "gx/gx_material", "gx/gx_render", "Camera"], function (exports_29, context_29) {
    "use strict";
    var __moduleName = context_29 && context_29.id;
    function texProjPerspMtx(dst, fov, aspect, scaleS, scaleT, transS, transT) {
        var cot = 1 / Math.tan(fov / 2);
        dst[0] = (cot / aspect) * scaleS;
        dst[4] = 0.0;
        dst[8] = -transS;
        dst[12] = 0.0;
        dst[1] = 0.0;
        dst[5] = cot * scaleT;
        dst[9] = -transT;
        dst[13] = 0.0;
        dst[2] = 0.0;
        dst[6] = 0.0;
        dst[10] = -1.0;
        dst[14] = 0.0;
        // Fill with junk to try and signal when something has gone horribly wrong. This should go unused,
        // since this is supposed to generate a mat4x3 matrix.
        dst[3] = 9999.0;
        dst[7] = 9999.0;
        dst[11] = 9999.0;
        dst[15] = 9999.0;
    }
    function texProjOrthoMtx(dst, t, b, l, r, scaleS, scaleT, transS, transT) {
        var h = 1 / (r - l);
        dst[0] = 2.0 * h * scaleS;
        dst[4] = 0.0;
        dst[8] = 0.0;
        dst[12] = ((-(r + l) * h) * scaleS) + transS;
        var v = 1 / (t - b);
        dst[1] = 0.0;
        dst[5] = 2.0 * v * scaleT;
        dst[9] = -transT;
        dst[13] = ((-(t + b) * v) * scaleT) + transT;
        dst[2] = 0.0;
        dst[6] = 0.0;
        dst[10] = -1.0;
        dst[14] = 0.0;
        dst[3] = 0.0;
        dst[7] = 0.0;
        dst[11] = 0.0;
        dst[15] = 1.0;
    }
    var gl_matrix_5, j3d_1, GX_Material, gx_render_1, Camera_3, J3DTextureHolder, scratchModelMatrix, scratchViewMatrix, Command_Shape, Command_Material, ColorOverride, matrixScratch, matrixScratch2, SceneLoaderToken, SceneLoader, Scene;
    return {
        setters: [
            function (gl_matrix_5_1) {
                gl_matrix_5 = gl_matrix_5_1;
            },
            function (j3d_1_1) {
                j3d_1 = j3d_1_1;
            },
            function (GX_Material_2) {
                GX_Material = GX_Material_2;
            },
            function (gx_render_1_1) {
                gx_render_1 = gx_render_1_1;
            },
            function (Camera_3_1) {
                Camera_3 = Camera_3_1;
            }
        ],
        execute: function () {
            J3DTextureHolder = /** @class */ (function (_super) {
                __extends(J3DTextureHolder, _super);
                function J3DTextureHolder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                J3DTextureHolder.prototype.addJ3DTextures = function (gl, bmd, bmt) {
                    if (bmt === void 0) { bmt = null; }
                    this.addTextures(gl, bmd.tex1.textureDatas);
                    if (bmt)
                        this.addTextures(gl, bmt.tex1.textureDatas);
                };
                return J3DTextureHolder;
            }(gx_render_1.TextureHolder));
            exports_29("J3DTextureHolder", J3DTextureHolder);
            scratchModelMatrix = gl_matrix_5.mat4.create();
            scratchViewMatrix = gl_matrix_5.mat4.create();
            Command_Shape = /** @class */ (function () {
                function Command_Shape(gl, sceneLoader, scene, shape, coalescedBuffers) {
                    this.scene = scene;
                    this.shape = shape;
                    this.packetParams = new gx_render_1.PacketParams();
                    this.bboxScratch = new Camera_3.AABB();
                    this.bmd = sceneLoader.bmd;
                    this.shapeHelper = new gx_render_1.GXShapeHelper(gl, coalescedBuffers, this.shape.loadedVertexLayout, this.shape.loadedVertexData);
                }
                Command_Shape.prototype.computeModelView = function (state) {
                    gl_matrix_5.mat4.copy(scratchModelMatrix, this.scene.modelMatrix);
                    switch (this.shape.displayFlags) {
                        case 0 /* NORMAL */:
                        case 3 /* USE_PNMTXIDX */:
                            // We should already be using PNMTXIDX in the normal case -- it's hardwired to 0.
                            break;
                        case 1 /* BILLBOARD */:
                            Camera_3.computeModelMatrixBillboard(scratchModelMatrix, state.camera);
                            gl_matrix_5.mat4.mul(scratchModelMatrix, this.scene.modelMatrix, scratchModelMatrix);
                            break;
                        case 2 /* Y_BILLBOARD */:
                            Camera_3.computeModelMatrixYBillboard(scratchModelMatrix, state.camera);
                            gl_matrix_5.mat4.mul(scratchModelMatrix, this.scene.modelMatrix, scratchModelMatrix);
                            break;
                        default:
                            throw new Error("whoops");
                    }
                    if (this.scene.isSkybox) {
                        Camera_3.computeViewMatrixSkybox(scratchViewMatrix, state.camera);
                    }
                    else {
                        Camera_3.computeViewMatrix(scratchViewMatrix, state.camera);
                    }
                    gl_matrix_5.mat4.mul(scratchViewMatrix, scratchViewMatrix, scratchModelMatrix);
                    return scratchViewMatrix;
                };
                Command_Shape.prototype.exec = function (state) {
                    if (!this.scene.currentMaterialCommand.visible)
                        return;
                    var gl = state.gl;
                    this.shapeHelper.drawPrologue(gl);
                    var modelView = this.computeModelView(state);
                    var needsUpload = false;
                    var posMtxVisibility = new Array(10);
                    for (var p = 0; p < this.shape.packets.length; p++) {
                        var packet = this.shape.packets[p];
                        // Update our matrix table.
                        for (var i = 0; i < packet.matrixTable.length; i++) {
                            var matrixIndex = packet.matrixTable[i];
                            // Leave existing matrix.
                            if (matrixIndex === 0xFFFF)
                                continue;
                            var posMtx = this.scene.weightedJointMatrices[matrixIndex];
                            posMtxVisibility[i] = this.scene.matrixVisibility[matrixIndex];
                            gl_matrix_5.mat4.mul(this.packetParams.u_PosMtx[i], modelView, posMtx);
                            needsUpload = true;
                        }
                        // If all matrices are invisible, we can cull.
                        var frustumCull = true;
                        for (var i = 0; i < posMtxVisibility.length; i++) {
                            if (posMtxVisibility[i] !== Camera_3.IntersectionState.FULLY_OUTSIDE) {
                                frustumCull = false;
                                break;
                            }
                        }
                        if (frustumCull)
                            return;
                        if (needsUpload) {
                            this.scene.renderHelper.bindPacketParams(state, this.packetParams);
                            needsUpload = false;
                        }
                        this.shapeHelper.drawTriangles(gl, packet.firstTriangle, packet.numTriangles);
                    }
                    this.shapeHelper.drawEpilogue(gl);
                };
                Command_Shape.prototype.destroy = function (gl) {
                    this.shapeHelper.destroy(gl);
                };
                return Command_Shape;
            }());
            Command_Material = /** @class */ (function () {
                function Command_Material(gl, scene, material) {
                    this.visible = true;
                    this.name = material.name;
                    this.scene = scene;
                    this.material = material;
                    this.program = new GX_Material.GX_Program(material.gxMaterial);
                    this.program.name = this.name;
                    this.renderFlags = GX_Material.translateRenderFlags(this.material.gxMaterial);
                }
                Command_Material.prototype.exec = function (state) {
                    this.scene.currentMaterialCommand = this;
                    if (!this.scene.currentMaterialCommand.visible)
                        return;
                    state.useProgram(this.program);
                    state.useFlags(this.renderFlags);
                    var materialParams = Command_Material.materialParams;
                    this.fillMaterialParams(materialParams, state);
                    this.scene.renderHelper.bindMaterialParams(state, materialParams);
                    this.scene.renderHelper.bindMaterialTextures(state, materialParams, this.program);
                };
                Command_Material.prototype.destroy = function (gl) {
                    this.program.destroy(gl);
                };
                Command_Material.prototype.fillMaterialParams = function (materialParams, state) {
                    var _this = this;
                    var animationFrame = this.scene.getTimeInFrames(state.time);
                    var copyColor = function (i, dst, fallbackColor) {
                        // First, check for a color animation.
                        if (_this.scene.brk !== null) {
                            if (_this.scene.brk.calcColorOverride(dst, _this.material.name, i, animationFrame))
                                return;
                        }
                        var color;
                        if (_this.scene.colorOverrides[i]) {
                            color = _this.scene.colorOverrides[i];
                        }
                        else {
                            color = fallbackColor;
                        }
                        var alpha;
                        if (_this.scene.alphaOverrides[i] !== undefined) {
                            alpha = _this.scene.alphaOverrides[i];
                        }
                        else {
                            alpha = fallbackColor.a;
                        }
                        dst.copy(color, alpha);
                    };
                    copyColor(ColorOverride.MAT0, materialParams.u_ColorMatReg[0], this.material.colorMatRegs[0]);
                    copyColor(ColorOverride.MAT1, materialParams.u_ColorMatReg[1], this.material.colorMatRegs[1]);
                    copyColor(ColorOverride.AMB0, materialParams.u_ColorAmbReg[0], this.material.colorAmbRegs[0]);
                    copyColor(ColorOverride.AMB1, materialParams.u_ColorAmbReg[1], this.material.colorAmbRegs[1]);
                    copyColor(ColorOverride.K0, materialParams.u_KonstColor[0], this.material.gxMaterial.colorConstants[0]);
                    copyColor(ColorOverride.K1, materialParams.u_KonstColor[1], this.material.gxMaterial.colorConstants[1]);
                    copyColor(ColorOverride.K2, materialParams.u_KonstColor[2], this.material.gxMaterial.colorConstants[2]);
                    copyColor(ColorOverride.K3, materialParams.u_KonstColor[3], this.material.gxMaterial.colorConstants[3]);
                    copyColor(ColorOverride.CPREV, materialParams.u_Color[0], this.material.gxMaterial.colorRegisters[0]);
                    copyColor(ColorOverride.C0, materialParams.u_Color[1], this.material.gxMaterial.colorRegisters[1]);
                    copyColor(ColorOverride.C1, materialParams.u_Color[2], this.material.gxMaterial.colorRegisters[2]);
                    copyColor(ColorOverride.C2, materialParams.u_Color[3], this.material.gxMaterial.colorRegisters[3]);
                    // Bind textures.
                    for (var i = 0; i < this.material.textureIndexes.length; i++) {
                        var texIndex = this.material.textureIndexes[i];
                        if (texIndex >= 0) {
                            this.scene.fillTextureMapping(materialParams.m_TextureMapping[i], texIndex);
                        }
                        else {
                            materialParams.m_TextureMapping[i].glTexture = null;
                        }
                    }
                    // Bind our texture matrices.
                    var scratch = Command_Material.matrixScratch;
                    for (var i = 0; i < this.material.texMatrices.length; i++) {
                        var texMtx = this.material.texMatrices[i];
                        if (texMtx === null)
                            continue;
                        var dst = materialParams.u_TexMtx[i];
                        var flipY = materialParams.m_TextureMapping[i].flipY;
                        var flipYScale = flipY ? -1.0 : 1.0;
                        // First, compute input matrix.
                        switch (texMtx.type) {
                            case 0x00:
                            case 0x01: // Delfino Plaza
                            case 0x0B: // Luigi Circuit
                            case 0x08: // Peach Beach.
                                // No mapping.
                                gl_matrix_5.mat4.identity(dst);
                                break;
                            case 0x06: // Rainbow Road
                            case 0x07: // Rainbow Road
                                // Environment mapping. Uses the normal matrix.
                                // Normal matrix. Emulated here by the view matrix with the translation lopped off...
                                gl_matrix_5.mat4.copy(dst, state.view);
                                dst[12] = 0;
                                dst[13] = 0;
                                dst[14] = 0;
                                break;
                            case 0x09:
                                // Projection. Used for indtexwater, mostly.
                                gl_matrix_5.mat4.copy(dst, state.view);
                                break;
                            default:
                                throw "whoops";
                        }
                        // Now apply effects.
                        switch (texMtx.type) {
                            case 0x00:
                            case 0x01:
                            case 0x0B:
                                break;
                            case 0x06: // Rainbow Road
                                // Environment mapping
                                Camera_3.texEnvMtx(scratch, -0.5, -0.5 * flipYScale, 0.5, 0.5);
                                gl_matrix_5.mat4.mul(dst, scratch, dst);
                                gl_matrix_5.mat4.mul(dst, texMtx.effectMatrix, dst);
                                break;
                            case 0x07: // Rainbow Road
                            case 0x08: // Peach Beach
                                gl_matrix_5.mat4.mul(dst, texMtx.effectMatrix, dst);
                                texProjPerspMtx(scratch, state.fov, state.getAspect(), 0.5, -0.5 * flipYScale, 0.5, 0.5);
                                gl_matrix_5.mat4.mul(dst, scratch, dst);
                                break;
                            case 0x09: // Rainbow Road
                                // Perspective.
                                // Don't apply effectMatrix to perspective. It appears to be
                                // a projection matrix preconfigured for GC.
                                // mat4.mul(dst, texMtx.effectMatrix, dst);
                                texProjPerspMtx(scratch, state.fov, state.getAspect(), 0.5, -0.5 * flipYScale, 0.5, 0.5);
                                gl_matrix_5.mat4.mul(dst, scratch, dst);
                                break;
                            default:
                                throw "whoops";
                        }
                        // Apply SRT.
                        gl_matrix_5.mat4.copy(scratch, texMtx.matrix);
                        if (this.scene.btk !== null)
                            this.scene.btk.calcAnimatedTexMtx(scratch, this.material.name, i, animationFrame);
                        // SRT matrices have translation in fourth component, but we want our matrix to have translation
                        // in third component. Swap.
                        var tx = scratch[12];
                        scratch[12] = scratch[8];
                        scratch[8] = tx;
                        var ty = scratch[13];
                        scratch[13] = scratch[9];
                        scratch[9] = ty;
                        gl_matrix_5.mat4.mul(dst, scratch, dst);
                    }
                    for (var i = 0; i < this.material.postTexMatrices.length; i++) {
                        var postTexMtx = this.material.postTexMatrices[i];
                        if (postTexMtx === null)
                            continue;
                        var finalMatrix = postTexMtx.matrix;
                        gl_matrix_5.mat4.copy(materialParams.u_PostTexMtx[i], finalMatrix);
                    }
                    for (var i = 0; i < this.material.indTexMatrices.length; i++) {
                        var indTexMtx = this.material.indTexMatrices[i];
                        if (indTexMtx === null)
                            continue;
                        var a = indTexMtx[0], c = indTexMtx[1], tx = indTexMtx[2];
                        var b = indTexMtx[3], d = indTexMtx[4], ty = indTexMtx[5];
                        gl_matrix_5.mat2d.set(materialParams.u_IndTexMtx[i], a, b, c, d, tx, ty);
                    }
                };
                Command_Material.matrixScratch = gl_matrix_5.mat4.create();
                Command_Material.materialParams = new gx_render_1.MaterialParams();
                return Command_Material;
            }());
            exports_29("Command_Material", Command_Material);
            (function (ColorOverride) {
                ColorOverride[ColorOverride["MAT0"] = 0] = "MAT0";
                ColorOverride[ColorOverride["MAT1"] = 1] = "MAT1";
                ColorOverride[ColorOverride["AMB0"] = 2] = "AMB0";
                ColorOverride[ColorOverride["AMB1"] = 3] = "AMB1";
                ColorOverride[ColorOverride["K0"] = 4] = "K0";
                ColorOverride[ColorOverride["K1"] = 5] = "K1";
                ColorOverride[ColorOverride["K2"] = 6] = "K2";
                ColorOverride[ColorOverride["K3"] = 7] = "K3";
                ColorOverride[ColorOverride["CPREV"] = 8] = "CPREV";
                ColorOverride[ColorOverride["C0"] = 9] = "C0";
                ColorOverride[ColorOverride["C1"] = 10] = "C1";
                ColorOverride[ColorOverride["C2"] = 11] = "C2";
            })(ColorOverride || (ColorOverride = {}));
            exports_29("ColorOverride", ColorOverride);
            matrixScratch = gl_matrix_5.mat4.create(), matrixScratch2 = gl_matrix_5.mat4.create();
            // SceneLoaderToken is a private class that's passed to Scene.
            // Basically, this emulates an internal constructor by making
            // it impossible to call...
            SceneLoaderToken = /** @class */ (function () {
                function SceneLoaderToken(gl) {
                    this.gl = gl;
                }
                return SceneLoaderToken;
            }());
            SceneLoader = /** @class */ (function () {
                function SceneLoader(textureHolder, bmd, bmt) {
                    if (bmt === void 0) { bmt = null; }
                    this.textureHolder = textureHolder;
                    this.bmd = bmd;
                    this.bmt = bmt;
                }
                SceneLoader.prototype.createScene = function (gl) {
                    return new Scene(new SceneLoaderToken(gl), this);
                };
                return SceneLoader;
            }());
            exports_29("SceneLoader", SceneLoader);
            Scene = /** @class */ (function () {
                function Scene(sceneLoaderToken, sceneLoader) {
                    this.name = '';
                    this.visible = true;
                    this.isSkybox = false;
                    this.fps = 30;
                    this.colorOverrides = [];
                    this.alphaOverrides = [];
                    this.sceneParams = new gx_render_1.SceneParams();
                    // TODO(jstpierre): Make BMT settable after load...
                    this.bmt = null;
                    // Animations.
                    this.bck = null;
                    this.brk = null;
                    this.btk = null;
                    this.jointVisibility = [];
                    this.matrixVisibility = [];
                    this.bboxScratch = new Camera_3.AABB();
                    var gl = sceneLoaderToken.gl;
                    this.bmd = sceneLoader.bmd;
                    this.bmt = sceneLoader.bmt;
                    this.textureHolder = sceneLoader.textureHolder;
                    // TODO(jstpierre): Remove textures from Scene onto MainScene.
                    this.textures = this.textureHolder.viewerTextures;
                    this.translateModel(gl, sceneLoader);
                    this.renderHelper = new gx_render_1.GXRenderHelper(gl);
                    this.modelMatrix = gl_matrix_5.mat4.create();
                }
                Scene.prototype.destroy = function (gl) {
                    this.renderHelper.destroy(gl);
                    this.bufferCoalescer.destroy(gl);
                    this.materialCommands.forEach(function (command) { return command.destroy(gl); });
                    this.shapeCommands.forEach(function (command) { return command.destroy(gl); });
                    this.glSamplers.forEach(function (sampler) { return gl.deleteSampler(sampler); });
                };
                Scene.prototype.setColorOverride = function (i, color) {
                    this.colorOverrides[i] = color;
                };
                Scene.prototype.setAlphaOverride = function (i, alpha) {
                    this.alphaOverrides[i] = alpha;
                };
                Scene.prototype.setIsSkybox = function (v) {
                    this.isSkybox = v;
                };
                Scene.prototype.setFPS = function (v) {
                    this.fps = v;
                };
                Scene.prototype.setVisible = function (v) {
                    this.visible = v;
                };
                Scene.prototype.setBCK = function (bck) {
                    this.bck = bck;
                };
                Scene.prototype.setBRK = function (brk) {
                    this.brk = brk;
                };
                Scene.prototype.setBTK = function (btk) {
                    this.btk = btk;
                };
                Scene.prototype.fillTextureMapping = function (m, texIndex) {
                    var tex1Sampler = this.tex1Samplers[texIndex];
                    this.textureHolder.fillTextureMapping(m, tex1Sampler.name);
                    m.glSampler = this.glSamplers[tex1Sampler.index];
                    m.lodBias = tex1Sampler.lodBias;
                };
                Scene.prototype.getTimeInFrames = function (milliseconds) {
                    return (milliseconds / 1000) * this.fps;
                };
                Scene.prototype.bindState = function (state) {
                    if (!this.visible)
                        return false;
                    state.setClipPlanes(20, 500000);
                    // XXX(jstpierre): Is this the right place to do this? Need an explicit update call...
                    this.updateJointMatrices(state);
                    this.renderHelper.bindUniformBuffers(state);
                    gx_render_1.fillSceneParamsFromRenderState(this.sceneParams, state);
                    this.renderHelper.bindSceneParams(state, this.sceneParams);
                    return true;
                };
                Scene.prototype.renderOpaque = function (state) {
                    this.execCommands(state, this.opaqueCommands);
                };
                Scene.prototype.renderTransparent = function (state) {
                    this.execCommands(state, this.transparentCommands);
                };
                Scene.prototype.render = function (state) {
                    if (!this.bindState(state))
                        return;
                    this.renderOpaque(state);
                    this.renderTransparent(state);
                };
                Scene.prototype.execCommands = function (state, commands) {
                    commands.forEach(function (command, i) {
                        command.exec(state);
                    });
                };
                Scene.translateSampler = function (gl, sampler) {
                    var glSampler = gl.createSampler();
                    gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, gx_render_1.translateTexFilter(gl, sampler.minFilter));
                    gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, gx_render_1.translateTexFilter(gl, sampler.magFilter));
                    gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, gx_render_1.translateWrapMode(gl, sampler.wrapS));
                    gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, gx_render_1.translateWrapMode(gl, sampler.wrapT));
                    gl.samplerParameterf(glSampler, gl.TEXTURE_MIN_LOD, sampler.minLOD);
                    gl.samplerParameterf(glSampler, gl.TEXTURE_MAX_LOD, sampler.maxLOD);
                    return glSampler;
                };
                Scene.prototype.translateTextures = function (gl, sceneLoader) {
                    var tex1 = sceneLoader.bmt !== null ? sceneLoader.bmt.tex1 : sceneLoader.bmd.tex1;
                    // TODO(jstpierre): How does separable textureData / sampler work with external
                    // texture resolve?
                    this.glSamplers = [];
                    try {
                        for (var _a = __values(tex1.samplers), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var sampler = _b.value;
                            this.glSamplers.push(Scene.translateSampler(gl, sampler));
                        }
                    }
                    catch (e_26_1) { e_26 = { error: e_26_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_26) throw e_26.error; }
                    }
                    this.tex1Samplers = tex1.samplers;
                    var e_26, _c;
                };
                Scene.prototype.translateModel = function (gl, sceneLoader) {
                    var _this = this;
                    var bmd = sceneLoader.bmd;
                    var bmt = sceneLoader.bmt;
                    var mat3 = (bmt !== null && bmt.mat3 !== null) ? bmt.mat3 : bmd.mat3;
                    this.opaqueCommands = [];
                    this.transparentCommands = [];
                    this.jointMatrices = [];
                    for (var i = 0; i < bmd.jnt1.bones.length; i++)
                        this.jointMatrices[i] = gl_matrix_5.mat4.create();
                    this.weightedJointMatrices = [];
                    try {
                        for (var _a = __values(bmd.drw1.drw1Joints), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var drw1Joint = _b.value;
                            this.weightedJointMatrices.push(gl_matrix_5.mat4.create());
                        }
                    }
                    catch (e_27_1) { e_27 = { error: e_27_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_27) throw e_27.error; }
                    }
                    this.translateTextures(gl, sceneLoader);
                    this.materialCommands = mat3.materialEntries.map(function (material) {
                        return new Command_Material(gl, _this, material);
                    });
                    this.bufferCoalescer = gx_render_1.loadedDataCoalescer(gl, bmd.shp1.shapes.map(function (shape) { return shape.loadedVertexData; }));
                    this.shapeCommands = bmd.shp1.shapes.map(function (shape, i) {
                        return new Command_Shape(gl, sceneLoader, _this, shape, _this.bufferCoalescer.coalescedBuffers[i]);
                    });
                    // Iterate through scene graph.
                    this.translateSceneGraph(bmd.inf1.sceneGraph, null);
                    var e_27, _c;
                };
                Scene.prototype.translateSceneGraph = function (node, commandList) {
                    switch (node.type) {
                        case j3d_1.HierarchyType.Shape:
                            commandList.push(this.shapeCommands[node.shapeIdx]);
                            break;
                        case j3d_1.HierarchyType.Material:
                            var materialCommand = this.materialCommands[node.materialIdx];
                            commandList = materialCommand.material.translucent ? this.transparentCommands : this.opaqueCommands;
                            commandList.push(materialCommand);
                            break;
                    }
                    try {
                        for (var _a = __values(node.children), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var child = _b.value;
                            this.translateSceneGraph(child, commandList);
                        }
                    }
                    catch (e_28_1) { e_28 = { error: e_28_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_28) throw e_28.error; }
                    }
                    var e_28, _c;
                };
                Scene.prototype.updateJointMatrixHierarchy = function (state, node, parentJointMatrix) {
                    // TODO(jstpierre): Don't pointer chase when traversing hierarchy every frame...
                    var jnt1 = this.bmd.jnt1;
                    var bbox = this.bboxScratch;
                    switch (node.type) {
                        case j3d_1.HierarchyType.Joint:
                            var jointIndex = node.jointIdx;
                            var boneMatrix = jnt1.bones[jointIndex].matrix;
                            if (this.bck !== null) {
                                boneMatrix = matrixScratch2;
                                this.bck.calcJointMatrix(boneMatrix, jointIndex, this.getTimeInFrames(state.time));
                            }
                            var jointMatrix = this.jointMatrices[jointIndex];
                            gl_matrix_5.mat4.mul(jointMatrix, parentJointMatrix, boneMatrix);
                            bbox.transform(jnt1.bones[jointIndex].bbox, jointMatrix);
                            this.jointVisibility[jointIndex] = state.camera.frustum.intersect(bbox);
                            parentJointMatrix = jointMatrix;
                            break;
                    }
                    for (var i = 0; i < node.children.length; i++)
                        this.updateJointMatrixHierarchy(state, node.children[i], parentJointMatrix);
                };
                Scene.prototype.updateJointMatrices = function (state) {
                    // First, update joint matrices from hierarchy.
                    gl_matrix_5.mat4.identity(matrixScratch);
                    this.updateJointMatrixHierarchy(state, this.bmd.inf1.sceneGraph, matrixScratch);
                    // Update weighted joint matrices.
                    for (var i = 0; i < this.bmd.drw1.drw1Joints.length; i++) {
                        var joint = this.bmd.drw1.drw1Joints[i];
                        var destMtx = this.weightedJointMatrices[i];
                        if (joint.kind === j3d_1.DRW1JointKind.NormalJoint) {
                            gl_matrix_5.mat4.copy(destMtx, this.jointMatrices[joint.jointIndex]);
                            this.matrixVisibility[i] = this.jointVisibility[joint.jointIndex];
                        }
                        else if (joint.kind === j3d_1.DRW1JointKind.WeightedJoint) {
                            destMtx.fill(0);
                            var envelope = this.bmd.evp1.envelopes[joint.envelopeIndex];
                            for (var i_1 = 0; i_1 < envelope.weightedBones.length; i_1++) {
                                var weightedBone = envelope.weightedBones[i_1];
                                var inverseBindPose = this.bmd.evp1.inverseBinds[weightedBone.index];
                                gl_matrix_5.mat4.mul(matrixScratch, this.jointMatrices[weightedBone.index], inverseBindPose);
                                gl_matrix_5.mat4.multiplyScalarAndAdd(destMtx, destMtx, matrixScratch, weightedBone.weight);
                            }
                            // TODO(jstpierre): Frustum cull weighted joints.
                            this.matrixVisibility[i] = Camera_3.IntersectionState.FULLY_INSIDE;
                        }
                    }
                };
                return Scene;
            }());
            exports_29("Scene", Scene);
        }
    };
});
// Implements Nintendo's J3D formats (BMD, BDL, BTK, etc.)
System.register("j3d/j3d", ["gl-matrix", "util", "gx/gx_displaylist", "gx/gx_material", "j3d/render", "Camera"], function (exports_30, context_30) {
    "use strict";
    var __moduleName = context_30 && context_30.id;
    function readStringTable(buffer, offs) {
        var view = buffer.createDataView(offs);
        var stringCount = view.getUint16(0x00);
        var tableIdx = 0x06;
        var strings = [];
        for (var i = 0; i < stringCount; i++) {
            var stringOffs = view.getUint16(tableIdx);
            var str = util_14.readString(buffer, offs + stringOffs, 255);
            strings.push(str);
            tableIdx += 0x04;
        }
        return strings;
    }
    function readINF1Chunk(buffer) {
        var view = buffer.createDataView();
        // unk
        var packetCount = view.getUint32(0x0C);
        var vertexCount = view.getUint32(0x10);
        var hierarchyOffs = view.getUint32(0x14);
        var node = { type: HierarchyType.End, children: [] };
        var parentStack = [node];
        var offs = hierarchyOffs;
        outer: while (true) {
            var type = view.getUint16(offs + 0x00);
            var value = view.getUint16(offs + 0x02);
            offs += 0x04;
            switch (type) {
                case HierarchyType.End:
                    break outer;
                case HierarchyType.Open:
                    parentStack.unshift(node);
                    break;
                case HierarchyType.Close:
                    node = parentStack.shift();
                    break;
                case HierarchyType.Joint:
                    node = { type: type, children: [], jointIdx: value };
                    parentStack[0].children.unshift(node);
                    break;
                case HierarchyType.Material:
                    node = { type: type, children: [], materialIdx: value };
                    parentStack[0].children.unshift(node);
                    break;
                case HierarchyType.Shape:
                    node = { type: type, children: [], shapeIdx: value };
                    parentStack[0].children.unshift(node);
                    break;
            }
        }
        util_14.assert(parentStack.length === 1);
        return { sceneGraph: parentStack.pop() };
    }
    function readVTX1Chunk(buffer) {
        var view = buffer.createDataView();
        var formatOffs = view.getUint32(0x08);
        var dataOffsLookupTable = 0x0C;
        // Data tables are stored in this order. Assumed to be hardcoded in a
        // struct somewhere inside JSystem.
        var dataTables = [
            9 /* POS */,
            10 /* NRM */,
            25 /* NBT */,
            11 /* CLR0 */,
            12 /* CLR1 */,
            13 /* TEX0 */,
            14 /* TEX1 */,
            15 /* TEX2 */,
            16 /* TEX3 */,
            17 /* TEX4 */,
            18 /* TEX5 */,
            19 /* TEX6 */,
            20 /* TEX7 */,
        ];
        var offs = formatOffs;
        var vertexArrays = new Map();
        while (true) {
            var vtxAttrib = view.getUint32(offs + 0x00);
            if (vtxAttrib === 255 /* NULL */)
                break;
            var compCnt = view.getUint32(offs + 0x04);
            var compType = view.getUint32(offs + 0x08);
            var compShift = view.getUint8(offs + 0x0C);
            offs += 0x10;
            var formatIdx = dataTables.indexOf(vtxAttrib);
            if (formatIdx < 0)
                continue;
            // Each attrib in the VTX1 chunk also has a corresponding data chunk containing
            // the data for that attribute, in the format stored above.
            // BMD doesn't tell us how big each data chunk is, but we need to know to figure
            // out how much data to upload. We assume the data offset lookup table is sorted
            // in order, and can figure it out by finding the next offset above us.
            var dataOffsLookupTableEntry = dataOffsLookupTable + formatIdx * 0x04;
            var dataOffsLookupTableEnd = dataOffsLookupTable + dataTables.length * 0x04;
            var dataStart = view.getUint32(dataOffsLookupTableEntry);
            var dataEnd = getDataEnd(dataOffsLookupTableEntry, dataOffsLookupTableEnd);
            var dataOffs = dataStart;
            var dataSize = dataEnd - dataStart;
            var vtxDataBuffer = buffer.subarray(dataOffs, dataSize);
            var vertexArray = { vtxAttrib: vtxAttrib, compType: compType, compCnt: compCnt, compShift: compShift, dataOffs: dataOffs, dataSize: dataSize, buffer: vtxDataBuffer };
            vertexArrays.set(vtxAttrib, vertexArray);
        }
        function getDataEnd(dataOffsLookupTableEntry, dataOffsLookupTableEnd) {
            var offs = dataOffsLookupTableEntry + 0x04;
            while (offs < dataOffsLookupTableEnd) {
                var dataOffs = view.getUint32(offs);
                if (dataOffs !== 0)
                    return dataOffs;
                offs += 0x04;
            }
            return buffer.byteLength;
        }
        return { vertexArrays: vertexArrays };
    }
    function readEVP1Chunk(buffer) {
        var view = buffer.createDataView();
        var envelopeTableCount = view.getUint16(0x08);
        var weightedBoneCountTableOffs = view.getUint32(0x0C);
        var weightedBoneIndexTableOffs = view.getUint32(0x10);
        var weightedBoneWeightTableOffs = view.getUint32(0x14);
        var inverseBindPoseTableOffs = view.getUint32(0x18);
        var weightedBoneId = 0;
        var maxBoneIndex = -1;
        var envelopes = [];
        for (var i = 0; i < envelopeTableCount; i++) {
            var numWeightedBones = view.getUint8(weightedBoneCountTableOffs + i);
            var weightedBones = [];
            for (var j = 0; j < numWeightedBones; j++) {
                var index = view.getUint16(weightedBoneIndexTableOffs + weightedBoneId * 0x02);
                var weight = view.getFloat32(weightedBoneWeightTableOffs + weightedBoneId * 0x04);
                weightedBones.push({ index: index, weight: weight });
                maxBoneIndex = Math.max(maxBoneIndex, index);
                weightedBoneId++;
            }
            envelopes.push({ weightedBones: weightedBones });
        }
        var inverseBinds = [];
        for (var i = 0; i < maxBoneIndex + 1; i++) {
            var offs = inverseBindPoseTableOffs + (i * 0x30);
            var m00 = view.getFloat32(offs + 0x00);
            var m10 = view.getFloat32(offs + 0x04);
            var m20 = view.getFloat32(offs + 0x08);
            var m30 = view.getFloat32(offs + 0x0C);
            var m01 = view.getFloat32(offs + 0x10);
            var m11 = view.getFloat32(offs + 0x14);
            var m21 = view.getFloat32(offs + 0x18);
            var m31 = view.getFloat32(offs + 0x1C);
            var m02 = view.getFloat32(offs + 0x20);
            var m12 = view.getFloat32(offs + 0x24);
            var m22 = view.getFloat32(offs + 0x28);
            var m32 = view.getFloat32(offs + 0x2C);
            inverseBinds.push(gl_matrix_6.mat4.fromValues(m00, m01, m02, 0, m10, m11, m12, 0, m20, m21, m22, 0, m30, m31, m32, 1));
        }
        return { envelopes: envelopes, inverseBinds: inverseBinds };
    }
    function readDRW1Chunk(buffer) {
        var view = buffer.createDataView();
        var weightedJointCount = view.getUint16(0x08);
        var isWeightedTableOffs = view.getUint32(0x0C);
        var jointIndexTableOffs = view.getUint32(0x10);
        var drw1Joints = [];
        for (var i = 0; i < weightedJointCount; i++) {
            var kind = view.getUint8(isWeightedTableOffs + i);
            var param = view.getUint16(jointIndexTableOffs + i * 0x02);
            if (kind === DRW1JointKind.NormalJoint) {
                drw1Joints.push({ kind: kind, jointIndex: param });
            }
            else if (kind === DRW1JointKind.WeightedJoint) {
                drw1Joints.push({ kind: kind, envelopeIndex: param });
            }
        }
        return { drw1Joints: drw1Joints };
    }
    function createJointMatrix(m, sx, sy, sz, rx, ry, rz, tx, ty, tz) {
        gl_matrix_6.quat.fromEuler(quatScratch, rx, ry, rz);
        gl_matrix_6.mat4.fromRotationTranslationScale(m, quatScratch, [tx, ty, tz], [sx, sy, sz]);
    }
    function readJNT1Chunk(buffer) {
        var view = buffer.createDataView();
        var boneDataCount = view.getUint16(0x08);
        util_14.assert(view.getUint16(0x0A) === 0xFFFF);
        var boneDataTableOffs = view.getUint32(0x0C);
        var remapTableOffs = view.getUint32(0x10);
        var remapTable = [];
        for (var i = 0; i < boneDataCount; i++)
            remapTable[i] = view.getUint16(remapTableOffs + i * 0x02);
        var nameTableOffs = view.getUint32(0x14);
        var nameTable = readStringTable(buffer, nameTableOffs);
        var bones = [];
        for (var i = 0; i < boneDataCount; i++) {
            var name_7 = nameTable[i];
            var boneDataTableIdx = boneDataTableOffs + (remapTable[i] * 0x40);
            var scaleX = view.getFloat32(boneDataTableIdx + 0x04);
            var scaleY = view.getFloat32(boneDataTableIdx + 0x08);
            var scaleZ = view.getFloat32(boneDataTableIdx + 0x0C);
            var rotationX = view.getInt16(boneDataTableIdx + 0x10) / 0x7FFF * 180;
            var rotationY = view.getInt16(boneDataTableIdx + 0x12) / 0x7FFF * 180;
            var rotationZ = view.getInt16(boneDataTableIdx + 0x14) / 0x7FFF * 180;
            var translationX = view.getFloat32(boneDataTableIdx + 0x18);
            var translationY = view.getFloat32(boneDataTableIdx + 0x1C);
            var translationZ = view.getFloat32(boneDataTableIdx + 0x20);
            var boundingSphereRadius = view.getFloat32(boneDataTableIdx + 0x24);
            var bboxMinX = view.getFloat32(boneDataTableIdx + 0x28);
            var bboxMinY = view.getFloat32(boneDataTableIdx + 0x2C);
            var bboxMinZ = view.getFloat32(boneDataTableIdx + 0x30);
            var bboxMaxX = view.getFloat32(boneDataTableIdx + 0x34);
            var bboxMaxY = view.getFloat32(boneDataTableIdx + 0x38);
            var bboxMaxZ = view.getFloat32(boneDataTableIdx + 0x3C);
            var bbox = new Camera_4.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
            var matrix = gl_matrix_6.mat4.create();
            createJointMatrix(matrix, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ, translationX, translationY, translationZ);
            bones.push({ name: name_7, matrix: matrix, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, bbox: bbox });
        }
        return { bones: bones };
    }
    function readSHP1Chunk(buffer, bmd) {
        var view = buffer.createDataView();
        var shapeCount = view.getUint16(0x08);
        var shapeTableOffs = view.getUint32(0x0C);
        var attribTableOffs = view.getUint32(0x18);
        var matrixTableOffs = view.getUint32(0x1C);
        var primDataOffs = view.getUint32(0x20);
        var matrixDataOffs = view.getUint32(0x24);
        var packetTableOffs = view.getUint32(0x28);
        // We have a number of "shapes". Each shape has a number of vertex attributes
        // (e.g. pos, nrm, txc) and a list of packets. Each packet has a list of draw
        // calls, and each draw call has a list of indices into *each* of the vertex
        // arrays, one per vertex.
        //
        // Instead of one global index per draw call like OGL and some amount of packed
        // vertex data, the GX instead allows specifying separate indices per attribute.
        // So you can have POS's indexes be 0 1 2 3 and NRM's indexes be 0 0 0 0.
        //
        // What we end up doing is similar to what Dolphin does with its vertex loader
        // JIT. We construct buffers for each of the components that are shape-specific.
        // Build vattrs for VTX1.
        var vat = [];
        var vtxArrays = [];
        try {
            // J3D only uses VTXFMT0.
            for (var _a = __values(bmd.vtx1.vertexArrays.entries()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var _c = __read(_b.value, 2), attr = _c[0], vertexArray = _c[1];
                vat[attr] = { compCnt: vertexArray.compCnt, compType: vertexArray.compType, compShift: vertexArray.compShift };
                vtxArrays[attr] = { buffer: vertexArray.buffer, offs: 0 };
            }
        }
        catch (e_29_1) { e_29 = { error: e_29_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
            }
            finally { if (e_29) throw e_29.error; }
        }
        var shapes = [];
        var shapeIdx = shapeTableOffs;
        for (var i = 0; i < shapeCount; i++) {
            var displayFlags = view.getUint8(shapeIdx + 0x00);
            util_14.assert(view.getUint8(shapeIdx + 0x01) == 0xFF);
            var packetCount = view.getUint16(shapeIdx + 0x02);
            var attribOffs = view.getUint16(shapeIdx + 0x04);
            var firstMatrix = view.getUint16(shapeIdx + 0x06);
            var firstPacket = view.getUint16(shapeIdx + 0x08);
            var vcd = [];
            var attribIdx = attribTableOffs + attribOffs;
            while (true) {
                var vtxAttrib = view.getUint32(attribIdx + 0x00);
                if (vtxAttrib === 255 /* NULL */)
                    break;
                var indexDataType = view.getUint32(attribIdx + 0x04);
                vcd[vtxAttrib] = { type: indexDataType };
                attribIdx += 0x08;
            }
            var vtxLoader = gx_displaylist_1.compileVtxLoader(vat, vcd);
            // Now parse out the packets.
            var packetIdx = packetTableOffs + (firstPacket * 0x08);
            var packets = [];
            var loadedDatas = [];
            util_14.assert(packetCount === 1);
            var totalTriangleCount = 0;
            for (var j = 0; j < packetCount; j++) {
                var packetSize = view.getUint32(packetIdx + 0x00);
                var packetStart = primDataOffs + view.getUint32(packetIdx + 0x04);
                var packetMatrixDataOffs = matrixDataOffs + (firstMatrix + j) * 0x08;
                var matrixCount = view.getUint16(packetMatrixDataOffs + 0x02);
                var matrixFirstIndex = view.getUint32(packetMatrixDataOffs + 0x04);
                var packetMatrixTableOffs = matrixTableOffs + matrixFirstIndex * 0x02;
                var packetMatrixTableSize = matrixCount;
                var matrixTable = buffer.createTypedArray(Uint16Array, packetMatrixTableOffs, packetMatrixTableSize, 1 /* BIG_ENDIAN */);
                var srcOffs = packetStart;
                var subBuffer = buffer.subarray(srcOffs, packetSize);
                var loadedSubData = vtxLoader.runVertices(vtxArrays, subBuffer);
                loadedDatas.push(loadedSubData);
                var firstTriangle = 0; // totalTriangleCount;
                var numTriangles = loadedSubData.totalTriangleCount;
                totalTriangleCount += numTriangles;
                packets.push({ matrixTable: matrixTable, firstTriangle: firstTriangle, numTriangles: numTriangles });
                packetIdx += 0x08;
            }
            var boundingSphereRadius = view.getFloat32(shapeIdx + 0x0C);
            var bboxMinX = view.getFloat32(shapeIdx + 0x10);
            var bboxMinY = view.getFloat32(shapeIdx + 0x14);
            var bboxMinZ = view.getFloat32(shapeIdx + 0x18);
            var bboxMaxX = view.getFloat32(shapeIdx + 0x1C);
            var bboxMaxY = view.getFloat32(shapeIdx + 0x20);
            var bboxMaxZ = view.getFloat32(shapeIdx + 0x24);
            var bbox = new Camera_4.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
            // Coalesce shape data.
            // TODO(jstpierre): coalesceLoadedData is basically completely busted.
            util_14.assert(loadedDatas.length === 1);
            var loadedVertexData = loadedDatas[0];
            var loadedVertexLayout = vtxLoader.loadedVertexLayout;
            // Now we should have a complete shape. Onto the next!
            shapes.push({ displayFlags: displayFlags, loadedVertexData: loadedVertexData, loadedVertexLayout: loadedVertexLayout, packets: packets, bbox: bbox });
            shapeIdx += 0x28;
        }
        return { vat: vat, shapes: shapes };
        var e_29, _d;
    }
    function createTexMtx(m, scaleS, scaleT, rotation, translationS, translationT, centerS, centerT, centerQ) {
        // TODO(jstpierre): Remove these.
        gl_matrix_6.mat4.fromTranslation(c, [centerS, centerT, centerQ]);
        gl_matrix_6.mat4.fromTranslation(ci, [-centerS, -centerT, -centerQ]);
        gl_matrix_6.mat4.fromTranslation(m, [translationS, translationT, 0]);
        gl_matrix_6.mat4.fromScaling(t, [scaleS, scaleT, 1]);
        gl_matrix_6.mat4.rotateZ(t, t, rotation * Math.PI);
        gl_matrix_6.mat4.mul(t, t, ci);
        gl_matrix_6.mat4.mul(t, c, t);
        gl_matrix_6.mat4.mul(m, m, t);
        return m;
    }
    function readColor32(view, srcOffs) {
        var r = view.getUint8(srcOffs + 0x00) / 255;
        var g = view.getUint8(srcOffs + 0x01) / 255;
        var b = view.getUint8(srcOffs + 0x02) / 255;
        var a = view.getUint8(srcOffs + 0x03) / 255;
        return new GX_Material.Color(r, g, b, a);
    }
    function readColorShort(view, srcOffs) {
        var r = view.getInt16(srcOffs + 0x00) / 255;
        var g = view.getInt16(srcOffs + 0x02) / 255;
        var b = view.getInt16(srcOffs + 0x04) / 255;
        var a = view.getInt16(srcOffs + 0x06) / 255;
        return new GX_Material.Color(r, g, b, a);
    }
    function readMAT3Chunk(buffer) {
        var view = buffer.createDataView();
        var materialCount = view.getUint16(0x08);
        var remapTableOffs = view.getUint32(0x10);
        var remapTable = [];
        for (var i = 0; i < materialCount; i++)
            remapTable[i] = view.getUint16(remapTableOffs + i * 0x02);
        var nameTableOffs = view.getUint32(0x14);
        var nameTable = readStringTable(buffer, nameTableOffs);
        var indirectTableOffset = view.getUint32(0x18);
        var cullModeTableOffs = view.getUint32(0x1C);
        var materialColorTableOffs = view.getUint32(0x20);
        var colorChanCountTableOffs = view.getUint32(0x24);
        var colorChanTableOffs = view.getUint32(0x28);
        var ambientColorTableOffs = view.getUint32(0x2C);
        var texGenTableOffs = view.getUint32(0x38);
        var postTexGenTableOffs = view.getUint32(0x3C);
        var textureTableOffs = view.getUint32(0x48);
        var texMtxTableOffs = view.getUint32(0x40);
        var postTexMtxTableOffs = view.getUint32(0x44);
        var tevOrderTableOffs = view.getUint32(0x4C);
        var colorRegisterTableOffs = view.getUint32(0x50);
        var colorConstantTableOffs = view.getUint32(0x54);
        var tevStageTableOffs = view.getUint32(0x5C);
        var alphaTestTableOffs = view.getUint32(0x6C);
        var blendModeTableOffs = view.getUint32(0x70);
        var depthModeTableOffs = view.getUint32(0x74);
        var materialEntries = [];
        var materialEntryTableOffs = view.getUint32(0x0C);
        for (var i = 0; i < materialCount; i++) {
            var index = i;
            var name_8 = nameTable[i];
            var materialEntryIdx = materialEntryTableOffs + (0x014C * remapTable[i]);
            var flags = view.getUint8(materialEntryIdx + 0x00);
            var cullModeIndex = view.getUint8(materialEntryIdx + 0x01);
            var colorChanCountIndex = view.getUint8(materialEntryIdx + 0x02);
            var texGenCountIndex = view.getUint8(materialEntryIdx + 0x03);
            var tevCountIndex = view.getUint8(materialEntryIdx + 0x04);
            // unk
            var depthModeIndex = view.getUint8(materialEntryIdx + 0x06);
            // unk
            var colorMatRegs = [null, null];
            for (var j = 0; j < 2; j++) {
                var matColorIndex = view.getUint16(materialEntryIdx + 0x08 + j * 0x02);
                var matColorOffs = materialColorTableOffs + matColorIndex * 0x04;
                var matColorReg = readColor32(view, matColorOffs);
                colorMatRegs[j] = matColorReg;
            }
            var colorAmbRegs = [null, null];
            for (var j = 0; j < 2; j++) {
                var ambColorIndex = view.getUint16(materialEntryIdx + 0x14 + j * 0x02);
                var ambColorOffs = ambientColorTableOffs + ambColorIndex * 0x04;
                var ambColorReg = readColor32(view, ambColorOffs);
                colorAmbRegs[j] = ambColorReg;
            }
            var lightChannelCount = view.getUint8(colorChanCountTableOffs + colorChanCountIndex);
            var lightChannels = [];
            for (var j = 0; j < lightChannelCount; j++) {
                var colorChannelIndex = view.getInt16(materialEntryIdx + 0x0C + ((j * 2 + 0) * 0x02));
                var colorChannel = readColorChannel(colorChanTableOffs, colorChannelIndex);
                var alphaChannelIndex = view.getInt16(materialEntryIdx + 0x0C + ((j * 2 + 1) * 0x02));
                var alphaChannel = readColorChannel(colorChanTableOffs, alphaChannelIndex);
                lightChannels.push({ colorChannel: colorChannel, alphaChannel: alphaChannel });
            }
            var texGens = [];
            for (var j = 0; j < 8; j++) {
                var texGenIndex = view.getInt16(materialEntryIdx + 0x28 + j * 0x02);
                if (texGenIndex < 0)
                    continue;
                var index_1 = j;
                var type = view.getUint8(texGenTableOffs + texGenIndex * 0x04 + 0x00);
                var source = view.getUint8(texGenTableOffs + texGenIndex * 0x04 + 0x01);
                var matrixCheck = view.getUint8(texGenTableOffs + texGenIndex * 0x04 + 0x02);
                util_14.assert(view.getUint8(texGenTableOffs + texGenIndex * 0x04 + 0x03) === 0xFF);
                var postMatrix = 125 /* PTIDENTITY */;
                var postTexGenIndex = view.getInt16(materialEntryIdx + 0x38 + j * 0x02);
                if (postTexGenTableOffs > 0 && postTexGenIndex >= 0) {
                    postMatrix = view.getUint8(postTexGenTableOffs + texGenIndex * 0x04 + 0x02);
                    util_14.assert(view.getUint8(postTexGenTableOffs + postTexGenIndex * 0x04 + 0x03) === 0xFF);
                }
                // BTK can apply texture animations to materials that have the matrix set to IDENTITY.
                // For this reason, we always assign a texture matrix. In theory, the file should
                // have an identity texture matrix in the texMatrices section, so it should render correctly.
                var matrix = 30 /* TEXMTX0 */ + j * 3;
                // If we ever find a counter-example for this, I'll have to rethink the scheme, but I
                // *believe* that texture matrices should always be paired with TexGens in order.
                util_14.assert(matrixCheck === 60 /* IDENTITY */ || matrixCheck === matrix);
                var normalize = false;
                var texGen = { index: index_1, type: type, source: source, matrix: matrix, normalize: normalize, postMatrix: postMatrix };
                texGens[j] = texGen;
            }
            var texMatrices = [];
            for (var j = 0; j < 10; j++) {
                texMatrices[j] = null;
                var texMtxIndex = view.getInt16(materialEntryIdx + 0x48 + j * 0x02);
                if (texMtxIndex < 0)
                    continue;
                texMatrices[j] = readTexMatrix(texMtxTableOffs, j, texMtxIndex);
            }
            // Since texture matrices are assigned in order, we should never actually have more than 8 of these.
            util_14.assert(texMatrices[8] === null);
            util_14.assert(texMatrices[9] === null);
            var postTexMatrices = [];
            for (var j = 0; j < 20; j++) {
                postTexMatrices[j] = null;
                var postTexMtxIndex = view.getInt16(materialEntryIdx + 0x5C + j * 0x02);
                if (postTexMtxIndex < 0)
                    continue;
                postTexMatrices[j] = readTexMatrix(postTexMtxTableOffs, j, postTexMtxIndex);
            }
            var colorConstants = [];
            for (var j = 0; j < 4; j++) {
                var colorIndex = view.getUint16(materialEntryIdx + 0x94 + j * 0x02);
                var color = readColor32(view, colorConstantTableOffs + colorIndex * 0x04);
                colorConstants.push(color);
            }
            var colorRegisters = [];
            for (var j = 0; j < 4; j++) {
                var colorIndex = view.getUint16(materialEntryIdx + 0xDC + j * 0x02);
                var color = readColorShort(view, colorRegisterTableOffs + colorIndex * 0x08);
                colorRegisters.push(color);
            }
            // BMD stores CPREV at the end. We store CPREV at the beginning.
            colorRegisters.unshift(colorRegisters.pop());
            var textureIndexTableIdx = materialEntryIdx + 0x84;
            var textureIndexes = [];
            for (var j = 0; j < 8; j++) {
                var textureTableIndex = view.getInt16(textureIndexTableIdx);
                if (textureTableIndex >= 0) {
                    var textureIndex = view.getUint16(textureTableOffs + textureTableIndex * 0x02);
                    textureIndexes.push(textureIndex);
                }
                else {
                    textureIndexes.push(-1);
                }
                textureIndexTableIdx += 0x02;
            }
            var indirectEntryOffs = indirectTableOffset + i * 0x138;
            var indirectStageCount = view.getUint8(indirectEntryOffs + 0x00);
            util_14.assert(indirectStageCount <= 4);
            var indTexStages = [];
            for (var j = 0; j < indirectStageCount; j++) {
                var index_2 = j;
                // SetIndTexOrder
                var indTexOrderOffs = indirectEntryOffs + 0x04 + j * 0x04;
                var texCoordId = view.getUint8(indTexOrderOffs + 0x00);
                var texture = view.getUint8(indTexOrderOffs + 0x01);
                // SetIndTexCoordScale
                var indTexScaleOffs = indirectEntryOffs + 0x04 + (0x04 * 4) + (0x1C * 3) + j * 0x04;
                var scaleS = view.getUint8(indTexScaleOffs + 0x00);
                var scaleT = view.getUint8(indTexScaleOffs + 0x01);
                indTexStages.push({ index: index_2, texCoordId: texCoordId, texture: texture, scaleS: scaleS, scaleT: scaleT });
            }
            // SetIndTexMatrix
            var indTexMatrices = [];
            for (var j = 0; j < 3; j++) {
                var indTexMatrixOffs = indirectEntryOffs + 0x04 + (0x04 * 4) + j * 0x1C;
                var p00 = view.getFloat32(indTexMatrixOffs + 0x00);
                var p01 = view.getFloat32(indTexMatrixOffs + 0x04);
                var p02 = view.getFloat32(indTexMatrixOffs + 0x08);
                var p10 = view.getFloat32(indTexMatrixOffs + 0x0C);
                var p11 = view.getFloat32(indTexMatrixOffs + 0x10);
                var p12 = view.getFloat32(indTexMatrixOffs + 0x14);
                var scale = Math.pow(2, view.getInt8(indTexMatrixOffs + 0x18));
                var m = new Float32Array([
                    p00 * scale, p01 * scale, p02 * scale,
                    p10 * scale, p11 * scale, p12 * scale,
                ]);
                indTexMatrices.push(m);
            }
            var tevStages = [];
            for (var j = 0; j < 16; j++) {
                // TevStage
                var tevStageIndex = view.getInt16(materialEntryIdx + 0xE4 + j * 0x02);
                if (tevStageIndex < 0)
                    continue;
                var index_3 = j;
                var tevStageOffs = tevStageTableOffs + tevStageIndex * 0x14;
                // const unknown0 = view.getUint8(tevStageOffs + 0x00);
                var colorInA = view.getUint8(tevStageOffs + 0x01);
                var colorInB = view.getUint8(tevStageOffs + 0x02);
                var colorInC = view.getUint8(tevStageOffs + 0x03);
                var colorInD = view.getUint8(tevStageOffs + 0x04);
                var colorOp = view.getUint8(tevStageOffs + 0x05);
                var colorBias = view.getUint8(tevStageOffs + 0x06);
                var colorScale = view.getUint8(tevStageOffs + 0x07);
                var colorClamp = !!view.getUint8(tevStageOffs + 0x08);
                var colorRegId = view.getUint8(tevStageOffs + 0x09);
                var alphaInA = view.getUint8(tevStageOffs + 0x0A);
                var alphaInB = view.getUint8(tevStageOffs + 0x0B);
                var alphaInC = view.getUint8(tevStageOffs + 0x0C);
                var alphaInD = view.getUint8(tevStageOffs + 0x0D);
                var alphaOp = view.getUint8(tevStageOffs + 0x0E);
                var alphaBias = view.getUint8(tevStageOffs + 0x0F);
                var alphaScale = view.getUint8(tevStageOffs + 0x10);
                var alphaClamp = !!view.getUint8(tevStageOffs + 0x11);
                var alphaRegId = view.getUint8(tevStageOffs + 0x12);
                // const unknown1 = view.getUint8(tevStageOffs + 0x13);
                // TevOrder
                var tevOrderIndex = view.getUint16(materialEntryIdx + 0xBC + j * 0x02);
                var tevOrderOffs = tevOrderTableOffs + tevOrderIndex * 0x04;
                var texCoordId = view.getUint8(tevOrderOffs + 0x00);
                var texMap = view.getUint8(tevOrderOffs + 0x01);
                var channelId = GX_Material.getRasColorChannelID(view.getUint8(tevOrderOffs + 0x02));
                util_14.assert(view.getUint8(tevOrderOffs + 0x03) === 0xFF);
                // KonstSel
                var konstColorSel = view.getUint8(materialEntryIdx + 0x9C + j);
                var konstAlphaSel = view.getUint8(materialEntryIdx + 0xAC + j);
                // SetTevIndirect
                var indTexStageOffs = indirectEntryOffs + 0x04 + (0x04 * 4) + (0x1C * 3) + (0x04 * 4) + j * 0x0C;
                var indTexStage = view.getUint8(indTexStageOffs + 0x00);
                var indTexFormat = view.getUint8(indTexStageOffs + 0x01);
                var indTexBiasSel = view.getUint8(indTexStageOffs + 0x02);
                var indTexMatrix = view.getUint8(indTexStageOffs + 0x03);
                util_14.assert(indTexMatrix <= 11 /* T2 */);
                var indTexWrapS = view.getUint8(indTexStageOffs + 0x04);
                var indTexWrapT = view.getUint8(indTexStageOffs + 0x05);
                var indTexAddPrev = !!view.getUint8(indTexStageOffs + 0x06);
                var indTexUseOrigLOD = !!view.getUint8(indTexStageOffs + 0x07);
                // bumpAlpha
                var tevStage = {
                    index: index_3,
                    colorInA: colorInA, colorInB: colorInB, colorInC: colorInC, colorInD: colorInD, colorOp: colorOp, colorBias: colorBias, colorScale: colorScale, colorClamp: colorClamp, colorRegId: colorRegId,
                    alphaInA: alphaInA, alphaInB: alphaInB, alphaInC: alphaInC, alphaInD: alphaInD, alphaOp: alphaOp, alphaBias: alphaBias, alphaScale: alphaScale, alphaClamp: alphaClamp, alphaRegId: alphaRegId,
                    texCoordId: texCoordId, texMap: texMap, channelId: channelId,
                    konstColorSel: konstColorSel, konstAlphaSel: konstAlphaSel,
                    indTexStage: indTexStage,
                    indTexFormat: indTexFormat,
                    indTexBiasSel: indTexBiasSel,
                    indTexMatrix: indTexMatrix,
                    indTexWrapS: indTexWrapS,
                    indTexWrapT: indTexWrapT,
                    indTexAddPrev: indTexAddPrev,
                    indTexUseOrigLOD: indTexUseOrigLOD,
                };
                tevStages.push(tevStage);
            }
            // SetAlphaCompare
            var alphaTestIndex = view.getUint16(materialEntryIdx + 0x146);
            var blendModeIndex = view.getUint16(materialEntryIdx + 0x148);
            var alphaTestOffs = alphaTestTableOffs + alphaTestIndex * 0x08;
            var compareA = view.getUint8(alphaTestOffs + 0x00);
            var referenceA = view.getUint8(alphaTestOffs + 0x01) / 0xFF;
            var op = view.getUint8(alphaTestOffs + 0x02);
            var compareB = view.getUint8(alphaTestOffs + 0x03);
            var referenceB = view.getUint8(alphaTestOffs + 0x04) / 0xFF;
            var alphaTest = { compareA: compareA, referenceA: referenceA, op: op, compareB: compareB, referenceB: referenceB };
            // SetBlendMode
            var blendModeOffs = blendModeTableOffs + blendModeIndex * 0x04;
            var blendType = view.getUint8(blendModeOffs + 0x00);
            var blendSrc = view.getUint8(blendModeOffs + 0x01);
            var blendDst = view.getUint8(blendModeOffs + 0x02);
            var blendLogicOp = view.getUint8(blendModeOffs + 0x03);
            var blendMode = { type: blendType, srcFactor: blendSrc, dstFactor: blendDst, logicOp: blendLogicOp };
            var cullMode = view.getUint32(cullModeTableOffs + cullModeIndex * 0x04);
            var depthModeOffs = depthModeTableOffs + depthModeIndex * 4;
            var depthTest = !!view.getUint8(depthModeOffs + 0x00);
            var depthFunc = view.getUint8(depthModeOffs + 0x01);
            var depthWrite = !!view.getUint8(depthModeOffs + 0x02);
            var ropInfo = { blendMode: blendMode, depthTest: depthTest, depthFunc: depthFunc, depthWrite: depthWrite };
            var translucent = !(flags & 0x03);
            var gxMaterial = {
                index: index, name: name_8,
                cullMode: cullMode,
                lightChannels: lightChannels,
                texGens: texGens,
                colorRegisters: colorRegisters,
                colorConstants: colorConstants,
                tevStages: tevStages,
                indTexStages: indTexStages,
                alphaTest: alphaTest,
                ropInfo: ropInfo,
            };
            materialEntries.push({
                index: index, name: name_8,
                translucent: translucent,
                textureIndexes: textureIndexes,
                texMatrices: texMatrices,
                postTexMatrices: postTexMatrices,
                gxMaterial: gxMaterial,
                colorMatRegs: colorMatRegs,
                colorAmbRegs: colorAmbRegs,
                indTexMatrices: indTexMatrices,
            });
        }
        function readColorChannel(tableOffs, colorChanIndex) {
            var colorChanOffs = colorChanTableOffs + colorChanIndex * 0x08;
            var lightingEnabled = !!view.getUint8(colorChanOffs + 0x00);
            util_14.assert(view.getUint8(colorChanOffs + 0x00) < 2);
            var matColorSource = view.getUint8(colorChanOffs + 0x01);
            var litMask = view.getUint8(colorChanOffs + 0x02);
            var diffuseFunction = view.getUint8(colorChanOffs + 0x03);
            var attenuationFunction = view.getUint8(colorChanOffs + 0x04);
            var ambColorSource = view.getUint8(colorChanOffs + 0x05);
            var colorChan = { lightingEnabled: lightingEnabled, matColorSource: matColorSource, ambColorSource: ambColorSource };
            return colorChan;
        }
        function readTexMatrix(tableOffs, j, texMtxIndex) {
            if (tableOffs === 0)
                return null;
            var texMtxOffs = tableOffs + texMtxIndex * 0x64;
            var projection = view.getUint8(texMtxOffs + 0x00);
            var type = view.getUint8(texMtxOffs + 0x01);
            util_14.assert(view.getUint16(texMtxOffs + 0x02) === 0xFFFF);
            var centerS = view.getFloat32(texMtxOffs + 0x04);
            var centerT = view.getFloat32(texMtxOffs + 0x08);
            var centerQ = view.getFloat32(texMtxOffs + 0x0C);
            var scaleS = view.getFloat32(texMtxOffs + 0x10);
            var scaleT = view.getFloat32(texMtxOffs + 0x14);
            var rotation = view.getInt16(texMtxOffs + 0x18) / 0x7FFF;
            util_14.assert(view.getUint16(texMtxOffs + 0x1A) === 0xFFFF);
            var translationS = view.getFloat32(texMtxOffs + 0x1C);
            var translationT = view.getFloat32(texMtxOffs + 0x20);
            // A second matrix?
            var p00 = view.getFloat32(texMtxOffs + 0x24);
            var p01 = view.getFloat32(texMtxOffs + 0x28);
            var p02 = view.getFloat32(texMtxOffs + 0x2C);
            var p03 = view.getFloat32(texMtxOffs + 0x30);
            var p10 = view.getFloat32(texMtxOffs + 0x34);
            var p11 = view.getFloat32(texMtxOffs + 0x38);
            var p12 = view.getFloat32(texMtxOffs + 0x3C);
            var p13 = view.getFloat32(texMtxOffs + 0x40);
            var p20 = view.getFloat32(texMtxOffs + 0x44);
            var p21 = view.getFloat32(texMtxOffs + 0x48);
            var p22 = view.getFloat32(texMtxOffs + 0x4C);
            var p23 = view.getFloat32(texMtxOffs + 0x50);
            var p30 = view.getFloat32(texMtxOffs + 0x54);
            var p31 = view.getFloat32(texMtxOffs + 0x58);
            var p32 = view.getFloat32(texMtxOffs + 0x5C);
            var p33 = view.getFloat32(texMtxOffs + 0x60);
            var effectMatrix = gl_matrix_6.mat4.fromValues(p00, p10, p20, p30, p01, p11, p21, p31, p02, p12, p22, p32, p03, p13, p23, p33);
            var matrix = gl_matrix_6.mat4.create();
            createTexMtx(matrix, scaleS, scaleT, rotation, translationS, translationT, centerS, centerT, centerQ);
            var texMtx = { type: type, projection: projection, effectMatrix: effectMatrix, matrix: matrix };
            return texMtx;
        }
        return { materialEntries: materialEntries };
    }
    function readBTI_Texture(buffer, name) {
        var view = buffer.createDataView();
        var format = view.getUint8(0x00);
        var width = view.getUint16(0x02);
        var height = view.getUint16(0x04);
        var wrapS = view.getUint8(0x06);
        var wrapT = view.getUint8(0x07);
        var paletteFormat = view.getUint8(0x09);
        var paletteNumEntries = view.getUint16(0x0A);
        var paletteOffs = view.getUint32(0x0C);
        var minFilter = view.getUint8(0x14);
        var magFilter = view.getUint8(0x15);
        var minLOD = view.getInt8(0x16) * 1 / 8;
        var maxLOD = view.getInt8(0x17) * 1 / 8;
        var mipCount = view.getUint8(0x18);
        var lodBias = view.getInt16(0x1A) * 1 / 100;
        var dataOffs = view.getUint32(0x1C);
        util_14.assert(minLOD === 0);
        var data = null;
        if (dataOffs !== 0)
            data = buffer.slice(dataOffs);
        return { name: name, format: format, width: width, height: height, wrapS: wrapS, wrapT: wrapT, minFilter: minFilter, magFilter: magFilter, minLOD: minLOD, maxLOD: maxLOD, mipCount: mipCount, lodBias: lodBias, data: data };
    }
    function readTEX1Chunk(buffer) {
        var view = buffer.createDataView();
        var textureCount = view.getUint16(0x08);
        var textureHeaderOffs = view.getUint32(0x0C);
        var nameTableOffs = view.getUint32(0x10);
        var nameTable = readStringTable(buffer, nameTableOffs);
        var samplers = [];
        var textureDatas = [];
        var _loop_8 = function (i) {
            var textureIdx = textureHeaderOffs + i * 0x20;
            var name_9 = nameTable[i];
            var btiTexture = readBTI_Texture(buffer.slice(textureIdx), name_9);
            var textureDataIndex = -1;
            // Try to find existing texture data.
            if (btiTexture.data !== null) {
                textureDataIndex = textureDatas.findIndex(function (tex) { return tex.data && tex.data.byteOffset === btiTexture.data.byteOffset; });
            }
            if (textureDataIndex < 0) {
                var textureData = {
                    name: btiTexture.name,
                    width: btiTexture.width,
                    height: btiTexture.height,
                    format: btiTexture.format,
                    mipCount: btiTexture.mipCount,
                    data: btiTexture.data,
                };
                textureDatas.push(textureData);
                textureDataIndex = textureDatas.length - 1;
            }
            // Sampler.
            var sampler = {
                index: i,
                name: btiTexture.name,
                wrapS: btiTexture.wrapS,
                wrapT: btiTexture.wrapT,
                minFilter: btiTexture.minFilter,
                magFilter: btiTexture.magFilter,
                minLOD: btiTexture.minLOD,
                maxLOD: btiTexture.maxLOD,
                lodBias: btiTexture.lodBias,
                textureDataIndex: textureDataIndex,
            };
            samplers.push(sampler);
        };
        for (var i = 0; i < textureCount; i++) {
            _loop_8(i);
        }
        return { textureDatas: textureDatas, samplers: samplers };
    }
    function applyLoopMode(t, loopMode) {
        switch (loopMode) {
            case 0 /* ONCE */:
                return Math.min(t, 1);
            case 2 /* REPEAT */:
                return t % 1;
            case 3 /* MIRRORED_ONCE */:
                return 1 - Math.abs((Math.min(t, 2) - 1));
            case 4 /* MIRRORED_REPEAT */:
                return 1 - Math.abs((t % 2) - 1);
        }
    }
    function getAnimFrame(anim, frame) {
        var lastFrame = anim.duration - 1;
        var normTime = frame / lastFrame;
        var animFrame = applyLoopMode(normTime, anim.loopMode) * lastFrame;
        return animFrame;
    }
    function cubicEval(cf0, cf1, cf2, cf3, t) {
        return (((cf0 * t + cf1) * t + cf2) * t + cf3);
    }
    function lerp(k0, k1, t) {
        return k0.value + (k1.value - k0.value) * t;
    }
    function hermiteInterpolate(k0, k1, t) {
        var length = k1.time - k0.time;
        var p0 = k0.value;
        var p1 = k1.value;
        var s0 = k0.tangentOut * length;
        var s1 = k1.tangentIn * length;
        var cf0 = (p0 * 2) + (p1 * -2) + (s0 * 1) + (s1 * 1);
        var cf1 = (p0 * -3) + (p1 * 3) + (s0 * -2) + (s1 * -1);
        var cf2 = (p0 * 0) + (p1 * 0) + (s0 * 1) + (s1 * 0);
        var cf3 = (p0 * 1) + (p1 * 0) + (s0 * 0) + (s1 * 0);
        return cubicEval(cf0, cf1, cf2, cf3, t);
    }
    function sampleAnimationData(track, frame) {
        var frames = track.frames;
        if (frames.length === 1)
            return frames[0].value;
        // Find the first frame.
        var idx1 = frames.findIndex(function (key) { return (frame < key.time); });
        if (idx1 < 0)
            return frames[frames.length - 1].value;
        var idx0 = idx1 - 1;
        var k0 = frames[idx0];
        var k1 = frames[idx1];
        // HACK(jstpierre): Nintendo sometimes uses weird "reset" tangents
        // which aren't supposed to be visible. They are visible for us because
        // "frame" can have a non-zero fractional component. In this case, pick
        // a value completely.
        if ((k1.time - k0.time) === 1)
            return k0.value;
        var t = (frame - k0.time) / (k1.time - k0.time);
        return hermiteInterpolate(k0, k1, t);
    }
    function translateAnimationTrack(data, scale, count, index, tangent) {
        // Special exception.
        if (count === 1) {
            var value = data[index];
            var frames_1 = [{ time: 0, value: value * scale, tangentIn: 0, tangentOut: 0 }];
            return { frames: frames_1 };
        }
        else {
            var frames_2 = [];
            if (tangent === 0 /* IN */) {
                for (var i = index; i < index + 3 * count; i += 3) {
                    var time = data[i + 0], value = data[i + 1] * scale, tangentIn = data[i + 2] * scale, tangentOut = tangentIn;
                    frames_2.push({ time: time, value: value, tangentIn: tangentIn, tangentOut: tangentOut });
                }
            }
            else if (tangent === 1 /* IN_OUT */) {
                for (var i = index; i < index + 4 * count; i += 4) {
                    var time = data[i + 0], value = data[i + 1] * scale, tangentIn = data[i + 2] * scale, tangentOut = data[i + 3] * scale;
                    frames_2.push({ time: time, value: value, tangentIn: tangentIn, tangentOut: tangentOut });
                }
            }
            return { frames: frames_2 };
        }
    }
    function readTTK1Chunk(buffer) {
        var view = buffer.createDataView();
        var loopMode = view.getUint8(0x08);
        var rotationDecimal = view.getUint8(0x09);
        var duration = view.getUint16(0x0A);
        var animationCount = view.getUint16(0x0C) / 3;
        var sCount = view.getUint16(0x0E);
        var rCount = view.getUint16(0x10);
        var tCount = view.getUint16(0x12);
        var animationTableOffs = view.getUint32(0x14);
        var remapTableOffs = view.getUint32(0x18);
        var materialNameTableOffs = view.getUint32(0x1C);
        var texMtxIndexTableOffs = view.getUint32(0x20);
        var textureCenterTableOffs = view.getUint32(0x24);
        var sTableOffs = view.getUint32(0x28);
        var rTableOffs = view.getUint32(0x2C);
        var tTableOffs = view.getUint32(0x30);
        var rotationScale = Math.pow(2, rotationDecimal) / 32767;
        var sTable = buffer.createTypedArray(Float32Array, sTableOffs, sCount, 1 /* BIG_ENDIAN */);
        var rTable = buffer.createTypedArray(Int16Array, rTableOffs, rCount, 1 /* BIG_ENDIAN */);
        var tTable = buffer.createTypedArray(Float32Array, tTableOffs, tCount, 1 /* BIG_ENDIAN */);
        var materialNameTable = readStringTable(buffer, materialNameTableOffs);
        var animationTableIdx = animationTableOffs;
        function readAnimationTrack(data, scale) {
            var count = view.getUint16(animationTableIdx + 0x00);
            var index = view.getUint16(animationTableIdx + 0x02);
            var tangent = view.getUint16(animationTableIdx + 0x04);
            animationTableIdx += 0x06;
            return translateAnimationTrack(data, scale, count, index, tangent);
        }
        var uvAnimationEntries = [];
        for (var i = 0; i < animationCount; i++) {
            var materialName = materialNameTable[i];
            var remapIndex = view.getUint16(remapTableOffs + i * 0x02);
            var texGenIndex = view.getUint8(texMtxIndexTableOffs + i);
            var centerS = view.getFloat32(textureCenterTableOffs + i * 0x0C + 0x00);
            var centerT = view.getFloat32(textureCenterTableOffs + i * 0x0C + 0x04);
            var centerQ = view.getFloat32(textureCenterTableOffs + i * 0x0C + 0x08);
            var scaleS = readAnimationTrack(sTable, 1);
            var rotationS = readAnimationTrack(rTable, rotationScale);
            var translationS = readAnimationTrack(tTable, 1);
            var scaleT = readAnimationTrack(sTable, 1);
            var rotationT = readAnimationTrack(rTable, rotationScale);
            var translationT = readAnimationTrack(tTable, 1);
            var scaleQ = readAnimationTrack(sTable, 1);
            var rotationQ = readAnimationTrack(rTable, rotationScale);
            var translationQ = readAnimationTrack(tTable, 1);
            uvAnimationEntries.push({
                materialName: materialName, remapIndex: remapIndex, texGenIndex: texGenIndex,
                centerS: centerS, centerT: centerT, centerQ: centerQ,
                scaleS: scaleS, rotationS: rotationS, translationS: translationS,
                scaleT: scaleT, rotationT: rotationT, translationT: translationT,
                scaleQ: scaleQ, rotationQ: rotationQ, translationQ: translationQ,
            });
        }
        return { duration: duration, loopMode: loopMode, uvAnimationEntries: uvAnimationEntries };
    }
    function readTRK1Chunk(buffer) {
        var view = buffer.createDataView();
        var loopMode = view.getUint8(0x08);
        var duration = view.getUint16(0x0A);
        var registerColorAnimationTableCount = view.getUint16(0x0C);
        var konstantColorAnimationTableCount = view.getUint16(0x0E);
        var registerRCount = view.getUint16(0x10);
        var registerGCount = view.getUint16(0x12);
        var registerBCount = view.getUint16(0x14);
        var registerACount = view.getUint16(0x16);
        var konstantRCount = view.getUint16(0x18);
        var konstantGCount = view.getUint16(0x1A);
        var konstantBCount = view.getUint16(0x1C);
        var konstantACount = view.getUint16(0x1E);
        var registerColorAnimationTableOffs = view.getUint32(0x20);
        var konstantColorAnimationTableOffs = view.getUint32(0x24);
        var registerRemapTableOffs = view.getUint32(0x28);
        var konstantRemapTableOffs = view.getUint32(0x2C);
        var registerNameTableOffs = view.getUint32(0x30);
        var konstantNameTableOffs = view.getUint32(0x34);
        var registerROffs = view.getUint32(0x38);
        var registerGOffs = view.getUint32(0x3C);
        var registerBOffs = view.getUint32(0x40);
        var registerAOffs = view.getUint32(0x44);
        var konstantROffs = view.getUint32(0x48);
        var konstantGOffs = view.getUint32(0x4C);
        var konstantBOffs = view.getUint32(0x50);
        var konstantAOffs = view.getUint32(0x54);
        var registerNameTable = readStringTable(buffer, registerNameTableOffs);
        var konstantNameTable = readStringTable(buffer, konstantNameTableOffs);
        var animationTableIdx;
        function readAnimationTrack(data) {
            var count = view.getUint16(animationTableIdx + 0x00);
            var index = view.getUint16(animationTableIdx + 0x02);
            var tangent = view.getUint16(animationTableIdx + 0x04);
            animationTableIdx += 0x06;
            return translateAnimationTrack(data, 1 / 0xFF, count, index, tangent);
        }
        var animationEntries = [];
        var registerRTable = buffer.createTypedArray(Int16Array, registerROffs, registerRCount, 1 /* BIG_ENDIAN */);
        var registerGTable = buffer.createTypedArray(Int16Array, registerGOffs, registerGCount, 1 /* BIG_ENDIAN */);
        var registerBTable = buffer.createTypedArray(Int16Array, registerBOffs, registerBCount, 1 /* BIG_ENDIAN */);
        var registerATable = buffer.createTypedArray(Int16Array, registerAOffs, registerACount, 1 /* BIG_ENDIAN */);
        animationTableIdx = registerColorAnimationTableOffs;
        for (var i = 0; i < registerColorAnimationTableCount; i++) {
            var materialName = registerNameTable[i];
            var remapIndex = view.getUint16(registerRemapTableOffs + i * 0x02);
            var r = readAnimationTrack(registerRTable);
            var g = readAnimationTrack(registerGTable);
            var b = readAnimationTrack(registerBTable);
            var a = readAnimationTrack(registerATable);
            var colorId = view.getUint8(animationTableIdx);
            var colorOverride = render_3.ColorOverride.C0 + colorId;
            animationTableIdx += 0x04;
            animationEntries.push({ materialName: materialName, remapIndex: remapIndex, colorOverride: colorOverride, r: r, g: g, b: b, a: a });
        }
        var konstantRTable = buffer.createTypedArray(Int16Array, konstantROffs, konstantRCount, 1 /* BIG_ENDIAN */);
        var konstantGTable = buffer.createTypedArray(Int16Array, konstantGOffs, konstantGCount, 1 /* BIG_ENDIAN */);
        var konstantBTable = buffer.createTypedArray(Int16Array, konstantBOffs, konstantBCount, 1 /* BIG_ENDIAN */);
        var konstantATable = buffer.createTypedArray(Int16Array, konstantAOffs, konstantACount, 1 /* BIG_ENDIAN */);
        animationTableIdx = konstantColorAnimationTableOffs;
        for (var i = 0; i < konstantColorAnimationTableCount; i++) {
            var materialName = konstantNameTable[i];
            var remapIndex = view.getUint16(konstantRemapTableOffs + i * 0x02);
            var r = readAnimationTrack(konstantRTable);
            var g = readAnimationTrack(konstantGTable);
            var b = readAnimationTrack(konstantBTable);
            var a = readAnimationTrack(konstantATable);
            var colorId = view.getUint8(animationTableIdx);
            var colorOverride = render_3.ColorOverride.K0 + colorId;
            animationTableIdx += 0x04;
            animationEntries.push({ materialName: materialName, remapIndex: remapIndex, colorOverride: colorOverride, r: r, g: g, b: b, a: a });
        }
        return { duration: duration, loopMode: loopMode, animationEntries: animationEntries };
    }
    function readANK1Chunk(buffer) {
        var view = buffer.createDataView();
        var loopMode = view.getUint8(0x08);
        var rotationDecimal = view.getUint8(0x09);
        var duration = view.getUint16(0x0A);
        var jointAnimationTableCount = view.getUint16(0x0C);
        var sCount = view.getUint16(0x0E);
        var rCount = view.getUint16(0x10);
        var tCount = view.getUint16(0x12);
        var jointAnimationTableOffs = view.getUint32(0x14);
        var sTableOffs = view.getUint32(0x18);
        var rTableOffs = view.getUint32(0x1C);
        var tTableOffs = view.getUint32(0x20);
        var rotationScale = Math.pow(2, rotationDecimal) / 32767;
        var sTable = buffer.createTypedArray(Float32Array, sTableOffs, sCount, 1 /* BIG_ENDIAN */);
        var rTable = buffer.createTypedArray(Int16Array, rTableOffs, rCount, 1 /* BIG_ENDIAN */);
        var tTable = buffer.createTypedArray(Float32Array, tTableOffs, tCount, 1 /* BIG_ENDIAN */);
        var animationTableIdx = jointAnimationTableOffs;
        function readAnimationTrack(data, scale) {
            var count = view.getUint16(animationTableIdx + 0x00);
            var index = view.getUint16(animationTableIdx + 0x02);
            var tangent = view.getUint16(animationTableIdx + 0x04);
            animationTableIdx += 0x06;
            return translateAnimationTrack(data, scale, count, index, tangent);
        }
        var jointAnimationEntries = [];
        for (var i = 0; i < jointAnimationTableCount; i++) {
            var scaleX = readAnimationTrack(sTable, 1);
            var rotationX = readAnimationTrack(rTable, rotationScale);
            var translationX = readAnimationTrack(tTable, 1);
            var scaleY = readAnimationTrack(sTable, 1);
            var rotationY = readAnimationTrack(rTable, rotationScale);
            var translationY = readAnimationTrack(tTable, 1);
            var scaleZ = readAnimationTrack(sTable, 1);
            var rotationZ = readAnimationTrack(rTable, rotationScale);
            var translationZ = readAnimationTrack(tTable, 1);
            jointAnimationEntries.push({
                index: i,
                scaleX: scaleX, rotationX: rotationX, translationX: translationX,
                scaleY: scaleY, rotationY: rotationY, translationY: translationY,
                scaleZ: scaleZ, rotationZ: rotationZ, translationZ: translationZ,
            });
        }
        return { loopMode: loopMode, duration: duration, jointAnimationEntries: jointAnimationEntries };
    }
    var gl_matrix_6, util_14, gx_displaylist_1, GX_Material, render_3, Camera_4, HierarchyType, DRW1JointKind, quatScratch, t, c, ci, J3DFileReaderHelper, BMD, BMT, BTI, BTK, BRK, BCK;
    return {
        setters: [
            function (gl_matrix_6_1) {
                gl_matrix_6 = gl_matrix_6_1;
            },
            function (util_14_1) {
                util_14 = util_14_1;
            },
            function (gx_displaylist_1_1) {
                gx_displaylist_1 = gx_displaylist_1_1;
            },
            function (GX_Material_3) {
                GX_Material = GX_Material_3;
            },
            function (render_3_1) {
                render_3 = render_3_1;
            },
            function (Camera_4_1) {
                Camera_4 = Camera_4_1;
            }
        ],
        execute: function () {
            //#region INF1
            (function (HierarchyType) {
                HierarchyType[HierarchyType["End"] = 0] = "End";
                HierarchyType[HierarchyType["Open"] = 1] = "Open";
                HierarchyType[HierarchyType["Close"] = 2] = "Close";
                HierarchyType[HierarchyType["Joint"] = 16] = "Joint";
                HierarchyType[HierarchyType["Material"] = 17] = "Material";
                HierarchyType[HierarchyType["Shape"] = 18] = "Shape";
            })(HierarchyType || (HierarchyType = {}));
            exports_30("HierarchyType", HierarchyType);
            //#endregion
            //#region DRW1
            (function (DRW1JointKind) {
                DRW1JointKind[DRW1JointKind["NormalJoint"] = 0] = "NormalJoint";
                DRW1JointKind[DRW1JointKind["WeightedJoint"] = 1] = "WeightedJoint";
            })(DRW1JointKind || (DRW1JointKind = {}));
            exports_30("DRW1JointKind", DRW1JointKind);
            quatScratch = gl_matrix_6.quat.create();
            // temp, center, center inverse
            t = gl_matrix_6.mat4.create(), c = gl_matrix_6.mat4.create(), ci = gl_matrix_6.mat4.create();
            J3DFileReaderHelper = /** @class */ (function () {
                function J3DFileReaderHelper(buffer) {
                    this.buffer = buffer;
                    this.offs = 0x20;
                    this.view = this.buffer.createDataView();
                    this.magic = util_14.readString(this.buffer, 0, 8);
                    this.size = this.view.getUint32(0x08);
                    this.numChunks = this.view.getUint32(0x0C);
                    this.offs = 0x20;
                }
                J3DFileReaderHelper.prototype.maybeNextChunk = function (maybeChunkId) {
                    var chunkStart = this.offs;
                    var chunkId = util_14.readString(this.buffer, chunkStart + 0x00, 4);
                    var chunkSize = this.view.getUint32(chunkStart + 0x04);
                    if (chunkId === maybeChunkId) {
                        this.offs += chunkSize;
                        return this.buffer.subarray(chunkStart, chunkSize);
                    }
                    else {
                        return null;
                    }
                };
                J3DFileReaderHelper.prototype.nextChunk = function (expectedChunkId) {
                    var chunkStart = this.offs;
                    var chunkId = util_14.readString(this.buffer, chunkStart + 0x00, 4);
                    var chunkSize = this.view.getUint32(chunkStart + 0x04);
                    util_14.assert(chunkId === expectedChunkId);
                    this.offs += chunkSize;
                    return this.buffer.subarray(chunkStart, chunkSize);
                };
                return J3DFileReaderHelper;
            }());
            //#endregion
            //#region BMD
            BMD = /** @class */ (function () {
                function BMD() {
                }
                BMD.parse = function (buffer) {
                    var bmd = new BMD();
                    var j3d = new J3DFileReaderHelper(buffer);
                    util_14.assert(j3d.magic === 'J3D2bmd3' || j3d.magic === 'J3D2bdl4');
                    bmd.inf1 = readINF1Chunk(j3d.nextChunk('INF1'));
                    bmd.vtx1 = readVTX1Chunk(j3d.nextChunk('VTX1'));
                    bmd.evp1 = readEVP1Chunk(j3d.nextChunk('EVP1'));
                    bmd.drw1 = readDRW1Chunk(j3d.nextChunk('DRW1'));
                    bmd.jnt1 = readJNT1Chunk(j3d.nextChunk('JNT1'));
                    bmd.shp1 = readSHP1Chunk(j3d.nextChunk('SHP1'), bmd);
                    bmd.mat3 = readMAT3Chunk(j3d.nextChunk('MAT3'));
                    var mdl3 = j3d.maybeNextChunk('MDL3');
                    bmd.tex1 = readTEX1Chunk(j3d.nextChunk('TEX1'));
                    return bmd;
                };
                return BMD;
            }());
            exports_30("BMD", BMD);
            //#endregion
            //#region BMT
            BMT = /** @class */ (function () {
                function BMT() {
                }
                BMT.parse = function (buffer) {
                    var bmt = new BMT();
                    var j3d = new J3DFileReaderHelper(buffer);
                    util_14.assert(j3d.magic === 'J3D2bmt3');
                    var mat3Chunk = j3d.maybeNextChunk('MAT3');
                    if (mat3Chunk !== null)
                        bmt.mat3 = readMAT3Chunk(mat3Chunk);
                    else
                        bmt.mat3 = null;
                    bmt.tex1 = readTEX1Chunk(j3d.nextChunk('TEX1'));
                    return bmt;
                };
                return BMT;
            }());
            exports_30("BMT", BMT);
            //#endregion
            //#region BTI
            BTI = /** @class */ (function () {
                function BTI() {
                }
                BTI.parse = function (buffer, name) {
                    if (name === void 0) { name = null; }
                    var bti = new BTI();
                    bti.texture = readBTI_Texture(buffer, name);
                    return bti;
                };
                return BTI;
            }());
            exports_30("BTI", BTI);
            //#endregion
            //#region BTK
            BTK = /** @class */ (function () {
                function BTK() {
                }
                BTK.parse = function (buffer) {
                    var btk = new BTK();
                    var j3d = new J3DFileReaderHelper(buffer);
                    util_14.assert(j3d.magic === 'J3D1btk1');
                    btk.ttk1 = readTTK1Chunk(j3d.nextChunk('TTK1'));
                    return btk;
                };
                BTK.prototype.calcAnimatedTexMtx = function (dst, materialName, texMtxIndex, frame) {
                    var animationEntry = this.findAnimationEntry(materialName, texMtxIndex);
                    if (!animationEntry)
                        return false;
                    var animFrame = getAnimFrame(this.ttk1, frame);
                    var centerS = animationEntry.centerS;
                    var centerT = animationEntry.centerT;
                    var centerQ = animationEntry.centerQ;
                    var scaleS = sampleAnimationData(animationEntry.scaleS, animFrame);
                    var scaleT = sampleAnimationData(animationEntry.scaleT, animFrame);
                    var rotation = sampleAnimationData(animationEntry.rotationQ, animFrame);
                    var translationS = sampleAnimationData(animationEntry.translationS, animFrame);
                    var translationT = sampleAnimationData(animationEntry.translationT, animFrame);
                    createTexMtx(dst, scaleS, scaleT, rotation, translationS, translationT, centerS, centerT, centerQ);
                    return true;
                };
                BTK.prototype.findAnimationEntry = function (materialName, texGenIndex) {
                    return this.ttk1.uvAnimationEntries.find(function (e) { return e.materialName === materialName && e.texGenIndex === texGenIndex; });
                };
                return BTK;
            }());
            exports_30("BTK", BTK);
            //#endregion
            //#region BRK
            BRK = /** @class */ (function () {
                function BRK() {
                }
                BRK.parse = function (buffer) {
                    var brk = new BRK();
                    var j3d = new J3DFileReaderHelper(buffer);
                    util_14.assert(j3d.magic === 'J3D1brk1');
                    brk.trk1 = readTRK1Chunk(j3d.nextChunk('TRK1'));
                    return brk;
                };
                BRK.prototype.calcColorOverride = function (dst, materialName, colorOverride, frame) {
                    var animationEntry = this.trk1.animationEntries.find(function (e) { return e.materialName === materialName && e.colorOverride === colorOverride; });
                    if (!animationEntry)
                        return false;
                    var animFrame = getAnimFrame(this.trk1, frame);
                    dst.r = sampleAnimationData(animationEntry.r, animFrame);
                    dst.g = sampleAnimationData(animationEntry.g, animFrame);
                    dst.b = sampleAnimationData(animationEntry.b, animFrame);
                    dst.a = sampleAnimationData(animationEntry.a, animFrame);
                    return true;
                };
                return BRK;
            }());
            exports_30("BRK", BRK);
            //#endregion
            //#region BCK
            BCK = /** @class */ (function () {
                function BCK() {
                }
                BCK.parse = function (buffer) {
                    var bck = new BCK();
                    var j3d = new J3DFileReaderHelper(buffer);
                    util_14.assert(j3d.magic === 'J3D1bck1');
                    bck.ank1 = readANK1Chunk(j3d.nextChunk('ANK1'));
                    return bck;
                };
                BCK.prototype.calcJointMatrix = function (dst, jointIndex, frame) {
                    var animFrame = getAnimFrame(this.ank1, frame);
                    var entry = this.ank1.jointAnimationEntries[jointIndex];
                    var scaleX = sampleAnimationData(entry.scaleX, animFrame);
                    var rotationX = sampleAnimationData(entry.rotationX, animFrame) * 180;
                    var translationX = sampleAnimationData(entry.translationX, animFrame);
                    var scaleY = sampleAnimationData(entry.scaleY, animFrame);
                    var rotationY = sampleAnimationData(entry.rotationY, animFrame) * 180;
                    var translationY = sampleAnimationData(entry.translationY, animFrame);
                    var scaleZ = sampleAnimationData(entry.scaleZ, animFrame);
                    var rotationZ = sampleAnimationData(entry.rotationZ, animFrame) * 180;
                    var translationZ = sampleAnimationData(entry.translationZ, animFrame);
                    createJointMatrix(dst, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ, translationX, translationY, translationZ);
                };
                return BCK;
            }());
            exports_30("BCK", BCK);
        }
    };
});
// Nintendo RARC file format.
System.register("j3d/rarc", ["util"], function (exports_31, context_31) {
    "use strict";
    var __moduleName = context_31 && context_31.id;
    function parse(buffer) {
        var view = buffer.createDataView();
        util_15.assert(util_15.readString(buffer, 0x00, 0x04) === 'RARC');
        var size = view.getUint32(0x04);
        var dataOffs = view.getUint32(0x0C) + 0x20;
        var dirCount = view.getUint32(0x20);
        var dirTableOffs = view.getUint32(0x24) + 0x20;
        var fileEntryCount = view.getUint32(0x28);
        var fileEntryTableOffs = view.getUint32(0x2C) + 0x20;
        var strTableOffs = view.getUint32(0x34) + 0x20;
        var dirTableIdx = dirTableOffs;
        var dirEntries = [];
        var allFiles = [];
        for (var i = 0; i < dirCount; i++) {
            var type = util_15.readString(buffer, dirTableIdx + 0x00, 0x04, false);
            var nameOffs = view.getUint32(dirTableIdx + 0x04);
            var name_10 = util_15.readString(buffer, strTableOffs + nameOffs, -1, true);
            var nameHash = view.getUint16(dirTableIdx + 0x08);
            var fileEntryCount_1 = view.getUint16(dirTableIdx + 0x0A);
            var fileEntryFirstIndex = view.getUint32(dirTableIdx + 0x0C);
            var files = [];
            var subdirIndexes = [];
            // Go through and parse the file table.
            var fileEntryIdx = fileEntryTableOffs + (fileEntryFirstIndex * 0x14);
            for (var i_2 = 0; i_2 < fileEntryCount_1; i_2++) {
                var id = view.getUint16(fileEntryIdx + 0x00);
                var nameHash_1 = view.getUint16(fileEntryIdx + 0x02);
                var flags = view.getUint8(fileEntryIdx + 0x04);
                var nameOffs_1 = view.getUint16(fileEntryIdx + 0x06);
                var name_11 = util_15.readString(buffer, strTableOffs + nameOffs_1, -1, true);
                var entryDataOffs = view.getUint32(fileEntryIdx + 0x08);
                var entryDataSize = view.getUint32(fileEntryIdx + 0x0C);
                fileEntryIdx += 0x14;
                if (name_11 === '.' || name_11 === '..')
                    continue;
                var isDirectory = !!(flags & 0x02);
                if (isDirectory) {
                    var subdirEntryIndex = entryDataOffs;
                    subdirIndexes.push(subdirEntryIndex);
                }
                else {
                    var offs = dataOffs + entryDataOffs;
                    var fileBuffer = buffer.slice(offs, offs + entryDataSize);
                    var file = { name: name_11, buffer: fileBuffer };
                    files.push(file);
                    allFiles.push(file);
                }
            }
            dirEntries.push({ name: name_10, type: type, files: files, subdirIndexes: subdirIndexes });
            dirTableIdx += 0x10;
        }
        var dirs = [];
        function translateDirEntry(i) {
            if (dirs[i] !== undefined)
                return dirs[i];
            var dirEntry = dirEntries[i];
            var name = dirEntry.name, type = dirEntry.type, files = dirEntry.files;
            var subdirs = dirEntry.subdirIndexes.map(function (i) { return translateDirEntry(i); });
            var dir = { name: name, type: type, files: files, subdirs: subdirs };
            dirs[i] = dir;
            return dir;
        }
        var root = translateDirEntry(0);
        util_15.assert(root.type === 'ROOT');
        var rarc = new RARC();
        rarc.files = allFiles;
        rarc.root = root;
        return rarc;
    }
    exports_31("parse", parse);
    var util_15, RARC;
    return {
        setters: [
            function (util_15_1) {
                util_15 = util_15_1;
            }
        ],
        execute: function () {
            RARC = /** @class */ (function () {
                function RARC() {
                }
                RARC.prototype.findDirParts = function (parts) {
                    var dir = this.root;
                    var _loop_9 = function (part) {
                        dir = dir.subdirs.find(function (subdir) { return subdir.name === part; });
                        if (dir === undefined)
                            return { value: null };
                    };
                    try {
                        for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
                            var part = parts_1_1.value;
                            var state_1 = _loop_9(part);
                            if (typeof state_1 === "object")
                                return state_1.value;
                        }
                    }
                    catch (e_30_1) { e_30 = { error: e_30_1 }; }
                    finally {
                        try {
                            if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
                        }
                        finally { if (e_30) throw e_30.error; }
                    }
                    return dir;
                    var e_30, _a;
                };
                RARC.prototype.findDir = function (path) {
                    return this.findDirParts(path.split('/'));
                };
                RARC.prototype.findFile = function (path) {
                    var parts = path.split('/');
                    var filename = parts.pop();
                    var dir = this.findDirParts(parts);
                    if (dir === null)
                        return null;
                    var file = dir.files.find(function (file) { return file.name === filename; });
                    if (!file)
                        return null;
                    return file;
                };
                return RARC;
            }());
            exports_31("RARC", RARC);
        }
    };
});
System.register("j3d/ztp_scenes", ["Progressable", "util", "compression/Yaz0", "ui", "j3d/j3d", "j3d/rarc", "j3d/render", "render", "gx/gx_material"], function (exports_32, context_32) {
    "use strict";
    var __moduleName = context_32 && context_32.id;
    function createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, bmtFile) {
        var bmd = j3d_2.BMD.parse(bmdFile.buffer);
        var bmt = bmtFile ? j3d_2.BMT.parse(bmtFile.buffer) : null;
        textureHolder.addJ3DTextures(gl, bmd, bmt);
        var sceneLoader = new render_4.SceneLoader(textureHolder, bmd, bmt);
        var scene = sceneLoader.createScene(gl);
        scene.setBTK(btkFile ? j3d_2.BTK.parse(btkFile.buffer) : null);
        scene.setBRK(brkFile ? j3d_2.BRK.parse(brkFile.buffer) : null);
        scene.setBCK(bckFile ? j3d_2.BCK.parse(bckFile.buffer) : null);
        return scene;
    }
    function createScenesFromRARC(gl, textureHolder, rarcName, rarc) {
        var bmdFiles = rarc.files.filter(function (f) { return f.name.endsWith('.bmd') || f.name.endsWith('.bdl'); });
        var scenes = bmdFiles.map(function (bmdFile) {
            var basename = bmdFile.name.split('.')[0];
            var btkFile = rarc.files.find(function (f) { return f.name === basename + ".btk"; });
            var brkFile = rarc.files.find(function (f) { return f.name === basename + ".brk"; });
            var bckFile = rarc.files.find(function (f) { return f.name === basename + ".bck"; });
            var bmtFile = rarc.files.find(function (f) { return f.name === basename + ".bmt"; });
            var scene = createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, bmtFile);
            scene.name = rarcName + "/" + basename;
            return scene;
        });
        return scenes.filter(function (s) { return !!s; });
    }
    var Progressable_2, util_16, Yaz0, UI, j3d_2, RARC, render_4, render_5, gx_material_1, ZTPTextureHolder, TwilightPrincessRenderer, TwilightPrincessSceneDesc, id, name, sceneDescs, sceneGroup;
    return {
        setters: [
            function (Progressable_2_1) {
                Progressable_2 = Progressable_2_1;
            },
            function (util_16_1) {
                util_16 = util_16_1;
            },
            function (Yaz0_1) {
                Yaz0 = Yaz0_1;
            },
            function (UI_1) {
                UI = UI_1;
            },
            function (j3d_2_1) {
                j3d_2 = j3d_2_1;
            },
            function (RARC_1) {
                RARC = RARC_1;
            },
            function (render_4_1) {
                render_4 = render_4_1;
            },
            function (render_5_1) {
                render_5 = render_5_1;
            },
            function (gx_material_1_1) {
                gx_material_1 = gx_material_1_1;
            }
        ],
        execute: function () {
            ZTPTextureHolder = /** @class */ (function (_super) {
                __extends(ZTPTextureHolder, _super);
                function ZTPTextureHolder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ZTPTextureHolder.prototype.tryTextureNameVariants = function (name) {
                    var extraTextureName = "ExtraTex/" + name.toLowerCase().replace('.tga', '');
                    return [name, extraTextureName];
                };
                ZTPTextureHolder.prototype.addExtraTextures = function (gl, extraTextures) {
                    this.addTextures(gl, extraTextures.map(function (texture) {
                        var name = "ExtraTex/" + texture.name.toLowerCase();
                        return __assign({}, texture, { name: name });
                    }));
                };
                return ZTPTextureHolder;
            }(render_4.J3DTextureHolder));
            TwilightPrincessRenderer = /** @class */ (function () {
                function TwilightPrincessRenderer(textureHolder, stageRarc, roomRarcs, skyboxScenes, roomScenes) {
                    var _this = this;
                    this.textureHolder = textureHolder;
                    this.stageRarc = stageRarc;
                    this.roomRarcs = roomRarcs;
                    this.skyboxScenes = skyboxScenes;
                    this.roomScenes = roomScenes;
                    this.textures = [];
                    this.mainColorTarget = new render_5.ColorTarget();
                    this.opaqueScenes = [];
                    this.indTexScenes = [];
                    this.transparentScenes = [];
                    this.windowScenes = [];
                    this.textures = textureHolder.viewerTextures;
                    this.roomScenes.forEach(function (scene) {
                        if (scene.name.endsWith('model')) {
                            _this.opaqueScenes.push(scene);
                        }
                        else if (scene.name.endsWith('model1')) {
                            _this.indTexScenes.push(scene);
                        }
                        else if (scene.name.endsWith('model2')) {
                            _this.transparentScenes.push(scene);
                        }
                        else if (scene.name.endsWith('model3')) {
                            _this.windowScenes.push(scene);
                        }
                        else if (scene.name.endsWith('model4')) {
                            _this.transparentScenes.push(scene);
                        }
                        else {
                            throw "whoops";
                        }
                    });
                }
                TwilightPrincessRenderer.prototype.createPanels = function () {
                    var layers = new UI.LayerPanel();
                    layers.setLayers(this.roomScenes);
                    return [layers];
                };
                TwilightPrincessRenderer.prototype.render = function (state) {
                    var gl = state.gl;
                    // Draw skybox + opaque to main RT.
                    this.mainColorTarget.setParameters(gl, state.onscreenColorTarget.width, state.onscreenColorTarget.height);
                    state.useRenderTarget(this.mainColorTarget);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    this.skyboxScenes.forEach(function (scene) {
                        scene.render(state);
                    });
                    state.useFlags(render_5.depthClearFlags);
                    gl.clear(gl.DEPTH_BUFFER_BIT);
                    this.opaqueScenes.forEach(function (scene) {
                        scene.render(state);
                    });
                    // Copy to main render target.
                    state.useRenderTarget(state.onscreenColorTarget);
                    state.blitColorTarget(this.mainColorTarget);
                    // IndTex.
                    if (this.indTexScenes.length) {
                        var textureOverride = { glTexture: this.mainColorTarget.resolvedColorTexture, width: gx_material_1.EFB_WIDTH, height: gx_material_1.EFB_HEIGHT, flipY: true };
                        this.textureHolder.setTextureOverride("fbtex_dummy", textureOverride);
                    }
                    this.indTexScenes.forEach(function (indirectScene) {
                        indirectScene.render(state);
                    });
                    // Transparent.
                    this.transparentScenes.forEach(function (scene) {
                        scene.render(state);
                    });
                    // Window & Doorway fades. Separate so that the renderer can override color registers separately.
                    // We don't do anything about this yet...
                    this.windowScenes.forEach(function (scene) {
                        scene.render(state);
                    });
                };
                TwilightPrincessRenderer.prototype.destroy = function (gl) {
                    this.textureHolder.destroy(gl);
                    this.skyboxScenes.forEach(function (scene) { return scene.destroy(gl); });
                    this.roomScenes.forEach(function (scene) { return scene.destroy(gl); });
                };
                return TwilightPrincessRenderer;
            }());
            TwilightPrincessSceneDesc = /** @class */ (function () {
                function TwilightPrincessSceneDesc(name, folder, roomPaths) {
                    this.name = name;
                    this.folder = folder;
                    this.roomPaths = roomPaths;
                    this.id = this.folder;
                }
                TwilightPrincessSceneDesc.prototype.createScene = function (gl) {
                    var _this = this;
                    var basePath = "data/j3d/ztp/" + this.folder;
                    var paths = __spread(["STG_00.arc"], this.roomPaths).map(function (path) { return basePath + "/" + path; });
                    var textureHolder = new ZTPTextureHolder();
                    return Progressable_2.default.all(paths.map(function (path) { return _this.fetchRarc(path); })).then(function (rarcs) {
                        var stageRarc = rarcs.shift();
                        var texcFolder = stageRarc.findDir("texc");
                        var extraTextureFiles = texcFolder !== null ? texcFolder.files : [];
                        var extraTextures = extraTextureFiles.map(function (file) {
                            var name = file.name.split('.')[0];
                            return j3d_2.BTI.parse(file.buffer, name).texture;
                        });
                        textureHolder.addExtraTextures(gl, extraTextures);
                        var skyboxScenes = ["vrbox_sora", "vrbox_kasumim"].map(function (basename) {
                            var bmdFile = stageRarc.findFile("bmdp/" + basename + ".bmd");
                            if (!bmdFile)
                                return null;
                            var btkFile = stageRarc.findFile("btk/" + basename + ".btk");
                            var brkFile = stageRarc.findFile("brk/" + basename + ".brk");
                            var bckFile = stageRarc.findFile("bck/" + basename + ".bck");
                            var scene = createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, null);
                            scene.setIsSkybox(true);
                            return scene;
                        }).filter(function (s) { return !!s; });
                        var roomRarcs = rarcs;
                        var roomScenes_ = roomRarcs.map(function (rarc, i) {
                            var rarcBasename = _this.roomPaths[i].split('.')[0];
                            return createScenesFromRARC(gl, textureHolder, rarcBasename, rarc);
                        });
                        var roomScenes = [];
                        roomScenes_.forEach(function (scenes) { return roomScenes.push.apply(roomScenes, scenes); });
                        return new TwilightPrincessRenderer(textureHolder, stageRarc, roomRarcs, skyboxScenes, roomScenes);
                    });
                };
                TwilightPrincessSceneDesc.prototype.fetchRarc = function (path) {
                    return util_16.fetch(path).then(function (buffer) {
                        return Yaz0.decompress(buffer);
                    }).then(function (buffer) {
                        return RARC.parse(buffer);
                    });
                };
                return TwilightPrincessSceneDesc;
            }());
            id = "ztp";
            name = "The Legend of Zelda: Twilight Princess";
            sceneDescs = [
                new TwilightPrincessSceneDesc("Forest Temple", "D_MN05", ["R02_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R07_00.arc", "R09_00.arc", "R10_00.arc", "R11_00.arc", "R12_00.arc", "R19_00.arc", "R22_00.arc", "R00_00.arc", "R01_00.arc"]),
                new TwilightPrincessSceneDesc("Goron Mines", "D_MN04", ["R11_00.arc", "R12_00.arc", "R13_00.arc", "R14_00.arc", "R16_00.arc", "R17_00.arc", "R01_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc", "R09_00.arc"]),
                new TwilightPrincessSceneDesc("Lakebed Temple", "D_MN01", ["R00_00.arc", "R01_00.arc", "R02_00.arc", "R03_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc", "R08_00.arc", "R09_00.arc", "R10_00.arc", "R11_00.arc", "R12_00.arc", "R13_00.arc"]),
                new TwilightPrincessSceneDesc("Arbiter's Grounds", "D_MN10", ["R01_00.arc", "R02_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc", "R08_00.arc", "R09_00.arc", "R10_00.arc", "R11_00.arc", "R12_00.arc", "R13_00.arc", "R14_00.arc", "R15_00.arc", "R16_00.arc", "R00_00.arc"]),
                new TwilightPrincessSceneDesc("Snowpeak Ruins", "D_MN11", ["R00_00.arc", "R01_00.arc", "R02_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc", "R08_00.arc", "R09_00.arc", "R11_00.arc", "R13_00.arc"]),
                new TwilightPrincessSceneDesc("Temple of Time", "D_MN06", ["R08_00.arc", "R00_00.arc", "R01_00.arc", "R02_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc"]),
                new TwilightPrincessSceneDesc("City in the Sky", "D_MN07", ["R00_00.arc", "R01_00.arc", "R02_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc", "R08_00.arc", "R10_00.arc", "R11_00.arc", "R12_00.arc", "R13_00.arc", "R14_00.arc", "R15_00.arc", "R16_00.arc"]),
                new TwilightPrincessSceneDesc("Palace of Twilight", "D_MN08", ["R00_00.arc", "R01_00.arc", "R02_00.arc", "R04_00.arc", "R05_00.arc", "R07_00.arc", "R08_00.arc", "R09_00.arc", "R10_00.arc", "R11_00.arc"]),
                new TwilightPrincessSceneDesc("Hyrule Castle", "D_MN09", ["R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R08_00.arc", "R09_00.arc", "R11_00.arc", "R12_00.arc", "R13_00.arc", "R14_00.arc", "R15_00.arc", "R01_00.arc", "R02_00.arc"]),
                new TwilightPrincessSceneDesc("Hyrule Field", "F_SP102", ["R00_00.arc"]),
                new TwilightPrincessSceneDesc("Fishing Pond", "F_SP127", ["R00_00.arc"]),
            ];
            exports_32("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
System.register("j3d/scenes", ["util", "ui", "j3d/j3d", "compression/Yaz0", "j3d/rarc", "j3d/render"], function (exports_33, context_33) {
    "use strict";
    var __moduleName = context_33 && context_33.id;
    function createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, bmtFile) {
        var bmd = j3d_3.BMD.parse(bmdFile.buffer);
        var bmt = bmtFile ? j3d_3.BMT.parse(bmtFile.buffer) : null;
        textureHolder.addJ3DTextures(gl, bmd, bmt);
        var sceneLoader = new render_6.SceneLoader(textureHolder, bmd, bmt);
        var scene = sceneLoader.createScene(gl);
        scene.setBTK(btkFile ? j3d_3.BTK.parse(btkFile.buffer) : null);
        scene.setBRK(brkFile ? j3d_3.BRK.parse(brkFile.buffer) : null);
        scene.setBCK(bckFile ? j3d_3.BCK.parse(bckFile.buffer) : null);
        return scene;
    }
    exports_33("createScene", createScene);
    function boolSort(a, b) {
        if (a && !b)
            return -1;
        else if (b && !a)
            return 1;
        else
            return 0;
    }
    function createScenesFromBuffer(gl, textureHolder, buffer) {
        return Promise.resolve(buffer).then(function (buffer) {
            if (util_17.readString(buffer, 0, 4) === 'Yaz0')
                return Yaz0.decompress(buffer);
            else
                return buffer;
        }).then(function (buffer) {
            if (util_17.readString(buffer, 0, 4) === 'RARC') {
                var rarc_1 = RARC.parse(buffer);
                var bmdFiles = rarc_1.files.filter(function (f) { return f.name.endsWith('.bmd') || f.name.endsWith('.bdl'); });
                var scenes = bmdFiles.map(function (bmdFile) {
                    // Find the corresponding btk.
                    var basename = bmdFile.name.split('.')[0];
                    var btkFile = rarc_1.files.find(function (f) { return f.name === basename + ".btk"; });
                    var brkFile = rarc_1.files.find(function (f) { return f.name === basename + ".brk"; });
                    var bckFile = rarc_1.files.find(function (f) { return f.name === basename + ".bck"; });
                    var bmtFile = rarc_1.files.find(function (f) { return f.name === basename + ".bmt"; });
                    var scene;
                    try {
                        scene = createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, bmtFile);
                    }
                    catch (e) {
                        console.warn("File " + basename + " failed to parse:", e);
                        return null;
                    }
                    scene.name = basename;
                    if (basename.includes('_sky'))
                        scene.setIsSkybox(true);
                    return scene;
                });
                scenes = scenes.filter(function (scene) { return !!scene; });
                // Sort skyboxen before non-skyboxen.
                scenes = scenes.sort(function (a, b) {
                    return boolSort(a.isSkybox, b.isSkybox);
                });
                return scenes;
            }
            if (['J3D2bmd3', 'J3D2bdl4'].includes(util_17.readString(buffer, 0, 8))) {
                var bmd = j3d_3.BMD.parse(buffer);
                textureHolder.addJ3DTextures(gl, bmd);
                var sceneLoader = new render_6.SceneLoader(textureHolder, bmd);
                var scene = sceneLoader.createScene(gl);
                return [scene];
            }
            return null;
        });
    }
    exports_33("createScenesFromBuffer", createScenesFromBuffer);
    function createMultiSceneFromBuffer(gl, buffer) {
        var textureHolder = new render_6.J3DTextureHolder();
        return createScenesFromBuffer(gl, textureHolder, buffer).then(function (scenes) {
            return new MultiScene(textureHolder, scenes);
        });
    }
    exports_33("createMultiSceneFromBuffer", createMultiSceneFromBuffer);
    var util_17, UI, j3d_3, Yaz0, RARC, render_6, MultiScene;
    return {
        setters: [
            function (util_17_1) {
                util_17 = util_17_1;
            },
            function (UI_2) {
                UI = UI_2;
            },
            function (j3d_3_1) {
                j3d_3 = j3d_3_1;
            },
            function (Yaz0_2) {
                Yaz0 = Yaz0_2;
            },
            function (RARC_2) {
                RARC = RARC_2;
            },
            function (render_6_1) {
                render_6 = render_6_1;
            }
        ],
        execute: function () {
            MultiScene = /** @class */ (function () {
                function MultiScene(textureHolder, scenes) {
                    this.textureHolder = textureHolder;
                    this.setScenes(scenes);
                }
                MultiScene.prototype.createPanels = function () {
                    var layersPanel = new UI.LayerPanel();
                    layersPanel.setLayers(this.scenes);
                    return [layersPanel];
                };
                MultiScene.prototype.render = function (renderState) {
                    this.scenes.forEach(function (scene) {
                        scene.render(renderState);
                    });
                };
                MultiScene.prototype.destroy = function (gl) {
                    this.textureHolder.destroy(gl);
                    this.scenes.forEach(function (scene) { return scene.destroy(gl); });
                };
                MultiScene.prototype.setScenes = function (scenes) {
                    this.scenes = scenes;
                    this.textures = [];
                    try {
                        for (var _a = __values(this.scenes), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var scene = _b.value;
                            this.textures = this.textures.concat(scene.textures);
                        }
                    }
                    catch (e_31_1) { e_31 = { error: e_31_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_31) throw e_31.error; }
                    }
                    var e_31, _c;
                };
                return MultiScene;
            }());
            exports_33("MultiScene", MultiScene);
        }
    };
});
System.register("j3d/mkdd_scenes", ["j3d/scenes", "util", "gl-matrix", "j3d/rarc", "j3d/render", "j3d/j3d"], function (exports_34, context_34) {
    "use strict";
    var __moduleName = context_34 && context_34.id;
    function parseBOL(buffer) {
        var view = buffer.createDataView();
        util_18.assert(util_18.readString(buffer, 0x00, 0x04) == '0015');
        var objectTableCount = view.getUint16(0x1E);
        var objectTableOffs = view.getUint32(0x54);
        var objects = [];
        var objectTableIdx = objectTableOffs;
        for (var i = 0; i < objectTableCount; i++) {
            var translationX = view.getFloat32(objectTableIdx + 0x00);
            var translationY = view.getFloat32(objectTableIdx + 0x04);
            var translationZ = view.getFloat32(objectTableIdx + 0x08);
            var scaleX = view.getFloat32(objectTableIdx + 0x0C);
            var scaleY = view.getFloat32(objectTableIdx + 0x10);
            var scaleZ = view.getFloat32(objectTableIdx + 0x14);
            var rotFaceX = view.getInt32(objectTableIdx + 0x18);
            var rotFaceZ = view.getInt32(objectTableIdx + 0x1C);
            var rotFaceN = view.getInt32(objectTableIdx + 0x20);
            var id_1 = view.getUint16(objectTableIdx + 0x24);
            var routeId = view.getInt16(objectTableIdx + 0x26);
            var modelMatrix = gl_matrix_7.mat4.create();
            var q = gl_matrix_7.quat.create();
            var rotationY = Math.atan2(rotFaceZ, rotFaceX);
            gl_matrix_7.quat.fromEuler(q, 0, -(rotationY * 180 / Math.PI) + 90, 0);
            gl_matrix_7.mat4.fromRotationTranslationScale(modelMatrix, q, [translationX, translationY, translationZ], [scaleX, scaleY, scaleZ]);
            objects.push({ id: id_1, routeId: routeId, modelMatrix: modelMatrix });
            objectTableIdx += 0x40;
        }
        return { objects: objects };
    }
    var scenes_1, util_18, gl_matrix_7, RARC, render_7, j3d_4, id, name, MKDDSceneDesc, sceneDescs, sceneGroup;
    return {
        setters: [
            function (scenes_1_1) {
                scenes_1 = scenes_1_1;
            },
            function (util_18_1) {
                util_18 = util_18_1;
            },
            function (gl_matrix_7_1) {
                gl_matrix_7 = gl_matrix_7_1;
            },
            function (RARC_3) {
                RARC = RARC_3;
            },
            function (render_7_1) {
                render_7 = render_7_1;
            },
            function (j3d_4_1) {
                j3d_4 = j3d_4_1;
            }
        ],
        execute: function () {
            id = "mkdd";
            name = "Mario Kart: Double Dash!!";
            MKDDSceneDesc = /** @class */ (function () {
                function MKDDSceneDesc(name, path) {
                    this.name = name;
                    this.path = path;
                    this.id = this.path;
                }
                MKDDSceneDesc.prototype.spawnBMD = function (gl, textureHolder, rarc, basename, modelMatrix) {
                    if (modelMatrix === void 0) { modelMatrix = null; }
                    var bmdFile = rarc.findFile(basename + ".bmd");
                    util_18.assertExists(bmdFile);
                    var btkFile = rarc.findFile(basename + ".btk");
                    var brkFile = rarc.findFile(basename + ".brk");
                    var bmtFile = rarc.findFile(basename + ".bmt");
                    var scene = scenes_1.createScene(gl, textureHolder, bmdFile, btkFile, brkFile, null, bmtFile);
                    scene.name = basename;
                    if (modelMatrix !== null)
                        gl_matrix_7.mat4.copy(scene.modelMatrix, modelMatrix);
                    return scene;
                };
                MKDDSceneDesc.prototype.createScene = function (gl) {
                    var _this = this;
                    var path = "data/j3d/mkdd/Course/" + this.path;
                    return util_18.fetch(path).then(function (buffer) {
                        var rarc = RARC.parse(buffer);
                        // Find course name.
                        var bolFile = rarc.files.find(function (f) { return f.name.endsWith('_course.bol'); });
                        var courseName = bolFile.name.replace('_course.bol', '');
                        var textureHolder = new render_7.J3DTextureHolder();
                        var scenes = [];
                        if (rarc.findFile(courseName + "_sky.bmd"))
                            scenes.push(_this.spawnBMD(gl, textureHolder, rarc, courseName + "_sky"));
                        scenes.push(_this.spawnBMD(gl, textureHolder, rarc, courseName + "_course"));
                        var spawnObject = function (obj, basename, animName) {
                            if (animName === void 0) { animName = null; }
                            var scene = _this.spawnBMD(gl, textureHolder, rarc, basename, obj.modelMatrix);
                            var bckFile;
                            if (animName !== null) {
                                bckFile = rarc.findFile(animName);
                                util_18.assertExists(bckFile);
                            }
                            else {
                                bckFile = rarc.findFile(basename + "_wait.bck");
                            }
                            if (bckFile !== null) {
                                var bck = j3d_4.BCK.parse(bckFile.buffer);
                                scene.setBCK(bck);
                            }
                            scenes.push(scene);
                            return scene;
                        };
                        var bol = parseBOL(bolFile.buffer);
                        console.log(courseName, rarc, bol);
                        try {
                            for (var _a = __values(bol.objects), _b = _a.next(); !_b.done; _b = _a.next()) {
                                var obj = _b.value;
                                switch (obj.id) {
                                    case 0x0001:
                                    case 0x0009:
                                        // Item box.
                                        break;
                                    case 0x0D49:
                                        // Sea.
                                        spawnObject(obj, "objects/sea1_spc");
                                        spawnObject(obj, "objects/sea2_tex");
                                        spawnObject(obj, "objects/sea3_dark");
                                        spawnObject(obj, "objects/sea4_nami");
                                        spawnObject(obj, "objects/sea5_sand");
                                        break;
                                    case 0x0D4A:
                                        spawnObject(obj, "objects/poihana1");
                                        break;
                                    case 0x0D4D:
                                        spawnObject(obj, "objects/peachtree1");
                                        break;
                                    case 0x0D4E:
                                        spawnObject(obj, "objects/peachfountain");
                                        break;
                                    case 0x0D4F:
                                        spawnObject(obj, "objects/marel_a");
                                        break;
                                    case 0x0E75:
                                        spawnObject(obj, "objects/mariotree1");
                                        break;
                                    case 0x0E77:
                                        spawnObject(obj, "objects/marioflower1", "objects/marioflower1.bck");
                                        break;
                                    case 0x0E78:
                                        // Chain chomp. Looks awful, don't spawn.
                                        // spawnObject(obj, `objects/wanwan1`); break;
                                        break;
                                    case 0x0E7E:
                                        spawnObject(obj, 'objects/skyship1');
                                        break;
                                    case 0x0E7F:
                                        spawnObject(obj, "objects/kuribo1");
                                        break;
                                    case 0x119A:
                                        // Butterflies.
                                        break;
                                    default:
                                        console.warn("Unknown object ID " + obj.id.toString(16));
                                        continue;
                                }
                            }
                        }
                        catch (e_32_1) { e_32 = { error: e_32_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                            }
                            finally { if (e_32) throw e_32.error; }
                        }
                        return new scenes_1.MultiScene(textureHolder, scenes);
                        var e_32, _c;
                    });
                };
                return MKDDSceneDesc;
            }());
            sceneDescs = [
                new MKDDSceneDesc("Luigi Circuit", 'Luigi.arc'),
                new MKDDSceneDesc("Peach Beach", 'Peach.arc'),
                new MKDDSceneDesc("Baby Park", 'BabyLuigi.arc'),
                new MKDDSceneDesc("Dry Dry Desert", 'Desert.arc'),
                new MKDDSceneDesc("Mushroom Bridge", 'Nokonoko.arc'),
                new MKDDSceneDesc("Mario Circuit", 'Mario.arc'),
                new MKDDSceneDesc("Daisy Cruiser", 'Daisy.arc'),
                new MKDDSceneDesc("Waluigi Stadium", 'Waluigi.arc'),
                new MKDDSceneDesc("Sherbet Land", 'Snow.arc'),
                new MKDDSceneDesc("Mushroom City", 'Patapata.arc'),
                new MKDDSceneDesc("Yoshi Circuit", 'Yoshi.arc'),
                new MKDDSceneDesc("DK Mountain", 'Donkey.arc'),
                new MKDDSceneDesc("Wario Colosseum", 'Wario.arc'),
                new MKDDSceneDesc("Dino Dino Jungle", 'Diddy.arc'),
                new MKDDSceneDesc("Bowser's Castle", 'Koopa.arc'),
                new MKDDSceneDesc("Rainbow Road", 'Rainbow.arc'),
            ];
            exports_34("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
System.register("j3d/zww_scenes", ["gl-matrix", "Progressable", "util", "render", "compression/Yaz0", "ui", "gx/gx_material", "j3d/j3d", "j3d/rarc", "j3d/render", "Program", "Color"], function (exports_35, context_35) {
    "use strict";
    var __moduleName = context_35 && context_35.id;
    function getColorsFromDZS(buffer, roomIdx, timeOfDay) {
        var view = buffer.createDataView();
        var chunkCount = view.getUint32(0x00);
        var chunkOffsets = new Map();
        var chunkTableIdx = 0x04;
        for (var i = 0; i < chunkCount; i++) {
            var type = util_19.readString(buffer, chunkTableIdx + 0x00, 0x04);
            var offs = view.getUint32(chunkTableIdx + 0x08);
            chunkOffsets.set(type, offs);
            chunkTableIdx += 0x0C;
        }
        var coloIdx = view.getUint8(chunkOffsets.get('EnvR') + (roomIdx * 0x08));
        var coloOffs = chunkOffsets.get('Colo') + (coloIdx * 0x0C);
        var whichPale = timeOfDay;
        var paleIdx = view.getUint8(coloOffs + whichPale);
        var paleOffs = chunkOffsets.get('Pale') + (paleIdx * 0x2C);
        var virtIdx = view.getUint8(paleOffs + 0x21);
        var virtOffs = chunkOffsets.get('Virt') + (virtIdx * 0x24);
        var ambR = view.getUint8(paleOffs + 0x06) / 0xFF;
        var ambG = view.getUint8(paleOffs + 0x07) / 0xFF;
        var ambB = view.getUint8(paleOffs + 0x08) / 0xFF;
        var amb = new GX_Material.Color(ambR, ambG, ambB, 1);
        var lightR = view.getUint8(paleOffs + 0x09) / 0xFF;
        var lightG = view.getUint8(paleOffs + 0x0A) / 0xFF;
        var lightB = view.getUint8(paleOffs + 0x0B) / 0xFF;
        var light = new GX_Material.Color(lightR, lightG, lightB, 1);
        var waveR = view.getUint8(paleOffs + 0x0C) / 0xFF;
        var waveG = view.getUint8(paleOffs + 0x0D) / 0xFF;
        var waveB = view.getUint8(paleOffs + 0x0E) / 0xFF;
        var wave = new GX_Material.Color(waveR, waveG, waveB, 1);
        var oceanR = view.getUint8(paleOffs + 0x0F) / 0xFF;
        var oceanG = view.getUint8(paleOffs + 0x10) / 0xFF;
        var oceanB = view.getUint8(paleOffs + 0x11) / 0xFF;
        var ocean = new GX_Material.Color(oceanR, oceanG, oceanB, 1);
        var splashR = view.getUint8(paleOffs + 0x12) / 0xFF;
        var splashG = view.getUint8(paleOffs + 0x13) / 0xFF;
        var splashB = view.getUint8(paleOffs + 0x14) / 0xFF;
        var splash = new GX_Material.Color(splashR, splashG, splashB, 1);
        var splash2R = view.getUint8(paleOffs + 0x15) / 0xFF;
        var splash2G = view.getUint8(paleOffs + 0x16) / 0xFF;
        var splash2B = view.getUint8(paleOffs + 0x17) / 0xFF;
        var splash2 = new GX_Material.Color(splash2R, splash2G, splash2B, 1);
        var doorsR = view.getUint8(paleOffs + 0x18) / 0xFF;
        var doorsG = view.getUint8(paleOffs + 0x19) / 0xFF;
        var doorsB = view.getUint8(paleOffs + 0x1A) / 0xFF;
        var doors = new GX_Material.Color(doorsR, doorsG, doorsB, 1);
        var vr_back_cloudR = view.getUint8(virtOffs + 0x10) / 0xFF;
        var vr_back_cloudG = view.getUint8(virtOffs + 0x11) / 0xFF;
        var vr_back_cloudB = view.getUint8(virtOffs + 0x12) / 0xFF;
        var vr_back_cloudA = view.getUint8(virtOffs + 0x13) / 0xFF;
        var vr_back_cloud = new GX_Material.Color(vr_back_cloudR, vr_back_cloudG, vr_back_cloudB, vr_back_cloudA);
        var vr_skyR = view.getUint8(virtOffs + 0x18) / 0xFF;
        var vr_skyG = view.getUint8(virtOffs + 0x19) / 0xFF;
        var vr_skyB = view.getUint8(virtOffs + 0x1A) / 0xFF;
        var vr_sky = new GX_Material.Color(vr_skyR, vr_skyG, vr_skyB, 1);
        var vr_uso_umiR = view.getUint8(virtOffs + 0x1B) / 0xFF;
        var vr_uso_umiG = view.getUint8(virtOffs + 0x1C) / 0xFF;
        var vr_uso_umiB = view.getUint8(virtOffs + 0x1D) / 0xFF;
        var vr_uso_umi = new GX_Material.Color(vr_uso_umiR, vr_uso_umiG, vr_uso_umiB, 1);
        var vr_kasumi_maeG = view.getUint8(virtOffs + 0x1F) / 0xFF;
        var vr_kasumi_maeR = view.getUint8(virtOffs + 0x1E) / 0xFF;
        var vr_kasumi_maeB = view.getUint8(virtOffs + 0x20) / 0xFF;
        var vr_kasumi_mae = new GX_Material.Color(vr_kasumi_maeR, vr_kasumi_maeG, vr_kasumi_maeB, 1);
        return { amb: amb, light: light, wave: wave, ocean: ocean, splash: splash, splash2: splash2, doors: doors, vr_back_cloud: vr_back_cloud, vr_sky: vr_sky, vr_uso_umi: vr_uso_umi, vr_kasumi_mae: vr_kasumi_mae };
    }
    function createScene(gl, textureHolder, rarc, name, isSkybox) {
        if (isSkybox === void 0) { isSkybox = false; }
        var bdlFile = rarc.findFile("bdl/" + name + ".bdl");
        if (!bdlFile)
            return null;
        var btkFile = rarc.findFile("btk/" + name + ".btk");
        var brkFile = rarc.findFile("brk/" + name + ".brk");
        var bckFile = rarc.findFile("bck/" + name + ".bck");
        var bdl = j3d_5.BMD.parse(bdlFile.buffer);
        var sceneLoader = new render_8.SceneLoader(textureHolder, bdl, null);
        textureHolder.addJ3DTextures(gl, bdl);
        var scene = sceneLoader.createScene(gl);
        scene.setBTK(btkFile !== null ? j3d_5.BTK.parse(btkFile.buffer) : null);
        scene.setBRK(brkFile !== null ? j3d_5.BRK.parse(brkFile.buffer) : null);
        scene.setBCK(bckFile !== null ? j3d_5.BCK.parse(bckFile.buffer) : null);
        scene.setIsSkybox(isSkybox);
        return scene;
    }
    var gl_matrix_8, Progressable_3, util_19, render_9, Yaz0, UI, GX_Material, j3d_5, RARC, render_8, Program_4, Color_2, CameraPos, TIME_OF_DAY_ICON, WindWakerRoomRenderer, PlaneColorProgram, SeaPlane, WindWakerRenderer, WindWakerSceneDesc, SeaSceneDesc, sceneDescs, id, name, sceneGroup;
    return {
        setters: [
            function (gl_matrix_8_1) {
                gl_matrix_8 = gl_matrix_8_1;
            },
            function (Progressable_3_1) {
                Progressable_3 = Progressable_3_1;
            },
            function (util_19_1) {
                util_19 = util_19_1;
            },
            function (render_9_1) {
                render_9 = render_9_1;
            },
            function (Yaz0_3) {
                Yaz0 = Yaz0_3;
            },
            function (UI_3) {
                UI = UI_3;
            },
            function (GX_Material_4) {
                GX_Material = GX_Material_4;
            },
            function (j3d_5_1) {
                j3d_5 = j3d_5_1;
            },
            function (RARC_4) {
                RARC = RARC_4;
            },
            function (render_8_1) {
                render_8 = render_8_1;
            },
            function (Program_4_1) {
                Program_4 = Program_4_1;
            },
            function (Color_2_1) {
                Color_2 = Color_2_1;
            }
        ],
        execute: function () {
            CameraPos = /** @class */ (function () {
                function CameraPos(x, y, z, lx, ly, lz) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.lx = lx;
                    this.ly = ly;
                    this.lz = lz;
                }
                CameraPos.prototype.set = function (m) {
                    gl_matrix_8.mat4.lookAt(m, [this.x, this.y, this.z], [this.lx, this.ly, this.lz], [0, 1, 0]);
                };
                return CameraPos;
            }());
            TIME_OF_DAY_ICON = "<svg viewBox=\"0 0 100 100\" height=\"20\" fill=\"white\"><path d=\"M50,93.4C74,93.4,93.4,74,93.4,50C93.4,26,74,6.6,50,6.6C26,6.6,6.6,26,6.6,50C6.6,74,26,93.4,50,93.4z M37.6,22.8  c-0.6,2.4-0.9,5-0.9,7.6c0,18.2,14.7,32.9,32.9,32.9c2.6,0,5.1-0.3,7.6-0.9c-4.7,10.3-15.1,17.4-27.1,17.4  c-16.5,0-29.9-13.4-29.9-29.9C20.3,37.9,27.4,27.5,37.6,22.8z\"/></svg>";
            WindWakerRoomRenderer = /** @class */ (function () {
                function WindWakerRoomRenderer(gl, textureHolder, roomIdx, roomRarc) {
                    this.textureHolder = textureHolder;
                    this.roomIdx = roomIdx;
                    this.roomRarc = roomRarc;
                    this.model = createScene(gl, textureHolder, roomRarc, "model");
                    // Ocean.
                    this.model1 = createScene(gl, textureHolder, roomRarc, "model1");
                    // Windows / doors.
                    this.model3 = createScene(gl, textureHolder, roomRarc, "model3");
                    this.textures = this.textureHolder.viewerTextures;
                }
                WindWakerRoomRenderer.prototype.setModelMatrix = function (modelMatrix) {
                    gl_matrix_8.mat4.copy(this.model.modelMatrix, modelMatrix);
                    if (this.model1)
                        gl_matrix_8.mat4.copy(this.model1.modelMatrix, modelMatrix);
                    if (this.model3)
                        gl_matrix_8.mat4.copy(this.model3.modelMatrix, modelMatrix);
                };
                WindWakerRoomRenderer.prototype.setColors = function (colors) {
                    if (colors !== undefined) {
                        this.model.setColorOverride(render_8.ColorOverride.K0, colors.light);
                        this.model.setColorOverride(render_8.ColorOverride.C0, colors.amb);
                        if (this.model1) {
                            this.model1.setColorOverride(render_8.ColorOverride.K0, colors.ocean);
                            this.model1.setColorOverride(render_8.ColorOverride.C0, colors.wave);
                            this.model1.setColorOverride(render_8.ColorOverride.C1, colors.splash);
                            this.model1.setColorOverride(render_8.ColorOverride.K1, colors.splash2);
                        }
                        if (this.model3)
                            this.model3.setColorOverride(render_8.ColorOverride.C0, colors.doors);
                    }
                    else {
                        this.model.setColorOverride(render_8.ColorOverride.K0, undefined);
                        this.model.setColorOverride(render_8.ColorOverride.C0, undefined);
                        if (this.model1) {
                            this.model1.setColorOverride(render_8.ColorOverride.K0, undefined);
                            this.model1.setColorOverride(render_8.ColorOverride.C0, undefined);
                            this.model1.setColorOverride(render_8.ColorOverride.C1, undefined);
                            this.model1.setColorOverride(render_8.ColorOverride.K1, undefined);
                        }
                        if (this.model3)
                            this.model3.setColorOverride(render_8.ColorOverride.C0, undefined);
                    }
                };
                WindWakerRoomRenderer.prototype.render = function (state) {
                    this.model.render(state);
                    if (this.model1)
                        this.model1.render(state);
                    if (this.model3)
                        this.model3.render(state);
                };
                WindWakerRoomRenderer.prototype.destroy = function (gl) {
                    this.model.destroy(gl);
                    if (this.model1)
                        this.model1.destroy(gl);
                    if (this.model3)
                        this.model3.destroy(gl);
                };
                return WindWakerRoomRenderer;
            }());
            PlaneColorProgram = /** @class */ (function (_super) {
                __extends(PlaneColorProgram, _super);
                function PlaneColorProgram() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.vert = "\nprecision mediump float;\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nlayout(location = " + PlaneColorProgram.a_Position + ") in vec3 a_Position;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_Position, 1.0);\n}\n";
                    _this.frag = "\nprecision mediump float;\nuniform vec4 u_PlaneColor;\n\nvoid main() {\n    gl_FragColor = u_PlaneColor;\n}\n";
                    return _this;
                }
                PlaneColorProgram.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.u_PlaneColor = gl.getUniformLocation(prog, "u_PlaneColor");
                };
                PlaneColorProgram.a_Position = 0;
                return PlaneColorProgram;
            }(Program_4.default));
            SeaPlane = /** @class */ (function () {
                function SeaPlane(gl) {
                    this.modelMatrix = gl_matrix_8.mat4.create();
                    this.color = new Float32Array(4);
                    this.program = new PlaneColorProgram();
                    this.createBuffers(gl);
                    gl_matrix_8.mat4.fromScaling(this.modelMatrix, [200000, 1, 200000]);
                }
                SeaPlane.prototype.setColor = function (color) {
                    this.color[0] = color.r;
                    this.color[1] = color.g;
                    this.color[2] = color.b;
                    this.color[3] = color.a;
                };
                SeaPlane.prototype.render = function (state) {
                    var gl = state.gl;
                    state.useProgram(this.program);
                    state.bindModelView(false, this.modelMatrix);
                    gl.uniform4fv(this.program.u_PlaneColor, this.color);
                    gl.bindVertexArray(this.vao);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    gl.bindVertexArray(null);
                };
                SeaPlane.prototype.destroy = function (gl) {
                    gl.deleteVertexArray(this.vao);
                    gl.deleteBuffer(this.posBuffer);
                };
                SeaPlane.prototype.createBuffers = function (gl) {
                    this.vao = gl.createVertexArray();
                    gl.bindVertexArray(this.vao);
                    var posData = new Float32Array(4 * 3);
                    posData[0] = -1;
                    posData[1] = 0;
                    posData[2] = -1;
                    posData[3] = 1;
                    posData[4] = 0;
                    posData[5] = -1;
                    posData[6] = -1;
                    posData[7] = 0;
                    posData[8] = 1;
                    posData[9] = 1;
                    posData[10] = 0;
                    posData[11] = 1;
                    this.posBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, posData, gl.STATIC_DRAW);
                    var posAttribLocation = PlaneColorProgram.a_Position;
                    gl.vertexAttribPointer(posAttribLocation, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(posAttribLocation);
                    gl.bindVertexArray(null);
                };
                return SeaPlane;
            }());
            WindWakerRenderer = /** @class */ (function () {
                function WindWakerRenderer(gl, textureHolder, stageRarc, cameraPos) {
                    this.textureHolder = textureHolder;
                    this.stageRarc = stageRarc;
                    this.cameraPos = cameraPos;
                    this.roomRenderers = [];
                    this.textures = textureHolder.viewerTextures;
                    this.seaPlane = new SeaPlane(gl);
                    this.vr_sky = createScene(gl, this.textureHolder, stageRarc, "vr_sky", true);
                    this.vr_uso_umi = createScene(gl, this.textureHolder, stageRarc, "vr_uso_umi", true);
                    this.vr_kasumi_mae = createScene(gl, this.textureHolder, stageRarc, "vr_kasumi_mae", true);
                    this.vr_back_cloud = createScene(gl, this.textureHolder, stageRarc, "vr_back_cloud", true);
                }
                WindWakerRenderer.prototype.setTimeOfDay = function (index) {
                    var dzsFile = this.stageRarc.findFile("dzs/stage.dzs");
                    var timeOfDay = index - 1;
                    var colors = timeOfDay === -1 ? undefined : getColorsFromDZS(dzsFile.buffer, 0, timeOfDay);
                    if (colors !== undefined) {
                        this.seaPlane.setColor(colors.ocean);
                        this.vr_sky.setColorOverride(render_8.ColorOverride.K0, colors.vr_sky);
                        this.vr_uso_umi.setColorOverride(render_8.ColorOverride.K0, colors.vr_uso_umi);
                        this.vr_kasumi_mae.setColorOverride(render_8.ColorOverride.C0, colors.vr_kasumi_mae);
                        this.vr_back_cloud.setColorOverride(render_8.ColorOverride.K0, colors.vr_back_cloud);
                        this.vr_back_cloud.setAlphaOverride(render_8.ColorOverride.K0, colors.vr_back_cloud.a);
                    }
                    else {
                        this.vr_sky.setColorOverride(render_8.ColorOverride.K0, undefined);
                        this.vr_uso_umi.setColorOverride(render_8.ColorOverride.K0, undefined);
                        this.vr_kasumi_mae.setColorOverride(render_8.ColorOverride.C0, undefined);
                        this.vr_back_cloud.setColorOverride(render_8.ColorOverride.K0, undefined);
                        this.vr_back_cloud.setAlphaOverride(render_8.ColorOverride.K0, undefined);
                    }
                    try {
                        for (var _a = __values(this.roomRenderers), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var roomRenderer = _b.value;
                            var roomColors = timeOfDay === -1 ? undefined : getColorsFromDZS(dzsFile.buffer, 0, timeOfDay);
                            roomRenderer.setColors(roomColors);
                        }
                    }
                    catch (e_33_1) { e_33 = { error: e_33_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_33) throw e_33.error; }
                    }
                    var e_33, _c;
                };
                WindWakerRenderer.prototype.createPanels = function () {
                    var _this = this;
                    var timeOfDayPanel = new UI.Panel();
                    timeOfDayPanel.setTitle(TIME_OF_DAY_ICON, "Time of Day");
                    var colorPresets = ['(no palette)', 'Dusk', 'Morning', 'Day', 'Afternoon', 'Evening', 'Night'];
                    var selector = new UI.SimpleSingleSelect();
                    selector.setStrings(colorPresets);
                    selector.onselectionchange = function (index) {
                        _this.setTimeOfDay(index);
                    };
                    var dzsFile = this.stageRarc.findFile("dzs/stage.dzs");
                    var flairs = colorPresets.slice(1).map(function (presetName, i) {
                        var elemIndex = i + 1;
                        var timeOfDay = i;
                        var stageColors = getColorsFromDZS(dzsFile.buffer, 0, timeOfDay);
                        return { index: elemIndex, background: Color_2.colorToCSS(stageColors.vr_sky) };
                    });
                    selector.setFlairs(flairs);
                    selector.selectItem(3); // Day
                    timeOfDayPanel.contents.appendChild(selector.elem);
                    return [timeOfDayPanel];
                };
                WindWakerRenderer.prototype.resetCamera = function (camera) {
                    var m = gl_matrix_8.mat4.create();
                    this.cameraPos.set(m);
                    gl_matrix_8.mat4.invert(camera.worldMatrix, m);
                    camera.worldMatrixUpdated();
                };
                WindWakerRenderer.prototype.render = function (state) {
                    var gl = state.gl;
                    // Render skybox.
                    this.vr_sky.render(state);
                    this.vr_kasumi_mae.render(state);
                    this.vr_uso_umi.render(state);
                    this.vr_back_cloud.render(state);
                    state.useFlags(render_9.depthClearFlags);
                    gl.clear(gl.DEPTH_BUFFER_BIT);
                    state.useFlags(render_9.RenderFlags.default);
                    // Render sea plane.
                    this.seaPlane.render(state);
                    for (var i = 0; i < this.roomRenderers.length; i++) {
                        var roomRenderer = this.roomRenderers[i];
                        roomRenderer.render(state);
                    }
                };
                WindWakerRenderer.prototype.destroy = function (gl) {
                    this.textureHolder.destroy(gl);
                    this.vr_sky.destroy(gl);
                    this.vr_kasumi_mae.destroy(gl);
                    this.vr_uso_umi.destroy(gl);
                    this.vr_back_cloud.destroy(gl);
                    try {
                        for (var _a = __values(this.roomRenderers), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var roomRenderer = _b.value;
                            roomRenderer.destroy(gl);
                        }
                    }
                    catch (e_34_1) { e_34 = { error: e_34_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_34) throw e_34.error; }
                    }
                    var e_34, _c;
                };
                return WindWakerRenderer;
            }());
            WindWakerSceneDesc = /** @class */ (function () {
                function WindWakerSceneDesc(path, name, cameraPos) {
                    this.path = path;
                    this.name = name;
                    this.cameraPos = cameraPos;
                    this.id = path;
                }
                WindWakerSceneDesc.prototype.createScene = function (gl) {
                    var _this = this;
                    var roomIdx = parseInt(this.path.match(/Room(\d+)/)[1], 10);
                    return Progressable_3.default.all([
                        this.fetchRarc("data/j3d/ww/sea/Stage.arc"),
                        this.fetchRarc(this.path),
                    ]).then(function (_a) {
                        var _b = __read(_a, 2), stageRarc = _b[0], roomRarc = _b[1];
                        var textureHolder = new render_8.J3DTextureHolder();
                        var renderer = new WindWakerRenderer(gl, textureHolder, stageRarc, _this.cameraPos);
                        renderer.roomRenderers.push(new WindWakerRoomRenderer(gl, textureHolder, roomIdx, roomRarc));
                        return renderer;
                    });
                };
                WindWakerSceneDesc.prototype.fetchRarc = function (path) {
                    return util_19.fetch(path).then(function (buffer) {
                        if (util_19.readString(buffer, 0, 4) === 'Yaz0')
                            return Yaz0.decompress(buffer);
                        else
                            return buffer;
                    }).then(function (buffer) {
                        return RARC.parse(buffer);
                    });
                };
                return WindWakerSceneDesc;
            }());
            SeaSceneDesc = /** @class */ (function () {
                function SeaSceneDesc(name, cameraPos) {
                    this.name = name;
                    this.cameraPos = cameraPos;
                    this.id = 'sea';
                }
                SeaSceneDesc.prototype.createScene = function (gl) {
                    var _this = this;
                    var rarcs = [];
                    rarcs.push(this.fetchRarc("data/j3d/ww/sea/Stage.arc"));
                    for (var i = 1; i <= 49; i++) {
                        // Tower of the Gods is not spawned by default, and has no map model.
                        if (i === 26)
                            continue;
                        rarcs.push(this.fetchRarc("data/j3d/ww/sea/Room" + i + ".arc"));
                    }
                    return Progressable_3.default.all(rarcs).then(function (_a) {
                        var _b = __read(_a), stageRarc = _b[0], roomRarcs = _b.slice(1);
                        var textureHolder = new render_8.J3DTextureHolder();
                        var renderer = new WindWakerRenderer(gl, textureHolder, stageRarc.rarc, _this.cameraPos);
                        var modelMatrix = gl_matrix_8.mat4.create();
                        var scale = 0.4;
                        var gridSize = 100000 * scale;
                        try {
                            for (var roomRarcs_1 = __values(roomRarcs), roomRarcs_1_1 = roomRarcs_1.next(); !roomRarcs_1_1.done; roomRarcs_1_1 = roomRarcs_1.next()) {
                                var roomRarc = roomRarcs_1_1.value;
                                var roomIdx = parseInt(roomRarc.path.match(/Room(\d+)/)[1], 10);
                                var roomRenderer = new WindWakerRoomRenderer(gl, textureHolder, roomIdx, roomRarc.rarc);
                                var gridX = (roomIdx % 7) | 0;
                                var gridY = (roomIdx / 7) | 0;
                                var tx = (gridX - 3.5) * gridSize;
                                var tz = (gridY - 3.5) * gridSize;
                                gl_matrix_8.mat4.fromTranslation(modelMatrix, [tx, 0, tz]);
                                gl_matrix_8.mat4.scale(modelMatrix, modelMatrix, [scale, scale, scale]);
                                roomRenderer.setModelMatrix(modelMatrix);
                                renderer.roomRenderers.push(roomRenderer);
                            }
                        }
                        catch (e_35_1) { e_35 = { error: e_35_1 }; }
                        finally {
                            try {
                                if (roomRarcs_1_1 && !roomRarcs_1_1.done && (_c = roomRarcs_1.return)) _c.call(roomRarcs_1);
                            }
                            finally { if (e_35) throw e_35.error; }
                        }
                        return renderer;
                        var e_35, _c;
                    });
                };
                SeaSceneDesc.prototype.fetchRarc = function (path) {
                    return util_19.fetch(path).then(function (buffer) {
                        if (util_19.readString(buffer, 0, 4) === 'Yaz0')
                            return Yaz0.decompress(buffer);
                        else
                            return buffer;
                    }).then(function (buffer) {
                        var rarc = RARC.parse(buffer);
                        return { path: path, rarc: rarc };
                    });
                };
                return SeaSceneDesc;
            }());
            sceneDescs = [
                new WindWakerSceneDesc("data/j3d/ww/sea/Room11.arc", "Windfall Island", new CameraPos(-148, 1760, 7560, -1000, 1000, -5000)),
                new WindWakerSceneDesc("data/j3d/ww/sea/Room13.arc", "Dragon Roost Island", new CameraPos(-8000, 1760, 280, 0, 500, -1000)),
                new WindWakerSceneDesc("data/j3d/ww/sea/Room41.arc", "Forest Haven", new CameraPos(20000, 1760, -5500, 16000, 1000, 0)),
                new WindWakerSceneDesc("data/j3d/ww/sea/Room44.arc", "Outset Island", new CameraPos(6000, 6000, 6000, 0, 0, 20000)),
                new SeaSceneDesc("The Great Sea", new CameraPos(0, 0, 0, 0, 0, 0)),
            ];
            id = "zww";
            name = "The Legend of Zelda: The Wind Waker";
            exports_35("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
System.register("j3d/sms_scenes", ["util", "render", "compression/Yaz0", "j3d/rarc", "j3d/render", "j3d/scenes", "gx/gx_material", "gl-matrix"], function (exports_36, context_36) {
    "use strict";
    var __moduleName = context_36 && context_36.id;
    function unpack(buffer, sig) {
        var view = buffer.createDataView();
        var result = [];
        var offs = 0;
        var allowExtra = false;
        for (var i = 0; i < sig.length; i++) {
            switch (sig[i]) {
                case 'B':
                    result.push(view.getUint8(offs));
                    offs += 0x01;
                    break;
                case 'I':
                    result.push(view.getUint32(offs));
                    offs += 0x04;
                    break;
                case 'i':
                    result.push(view.getInt32(offs));
                    offs += 0x04;
                    break;
                case 'f':
                    result.push(view.getFloat32(offs));
                    offs += 0x04;
                    break;
                case 's':
                    var size = view.getUint16(offs);
                    offs += 0x02;
                    result.push(util_20.readString(buffer, offs, size, false));
                    offs += size;
                    break;
                case '.':
                    allowExtra = true;
                    break;
                case ' ':
                    break;
                default:
                    util_20.assert(false);
            }
        }
        if (!allowExtra) {
            util_20.assert(buffer.byteLength === offs);
        }
        return __spread([offs], result);
    }
    function readSceneBin(buffer) {
        var offs = 0x00;
        var view_ = buffer.createDataView();
        var size = view_.getUint32(offs + 0x00);
        var view = buffer.createDataView(0x00, size);
        offs += 0x04;
        var klassHash = view.getUint16(offs + 0x00);
        var klassSize = view.getUint16(offs + 0x02);
        offs += 0x04;
        var klass = util_20.readString(buffer, offs, klassSize, false);
        offs += klassSize;
        var nameHash = view.getUint16(offs + 0x00);
        var nameSize = view.getUint16(offs + 0x02);
        offs += 0x04;
        var name = sjisDecoder.decode(buffer.copyToBuffer(offs, nameSize));
        offs += nameSize;
        function readChildren(numChildren) {
            var children = [];
            while (numChildren--) {
                var child = readSceneBin(buffer.slice(offs));
                children.push(child);
                offs += child.size;
            }
            return children;
        }
        var params = buffer.slice(offs, size);
        switch (klass) {
            case 'GroupObj':
            case 'LightAry':
            case 'Strategy':
            case 'AmbAry':
                {
                    var _a = __read(unpack(params, 'I.'), 2), paramsSize = _a[0], numChildren = _a[1];
                    offs += paramsSize;
                    var children = readChildren(numChildren);
                    return { type: 'Group', klass: klass, name: name, size: size, children: children };
                }
            case 'IdxGroup':
            case 'MarScene':
                {
                    var _b = __read(unpack(params, 'II.'), 3), paramsSize = _b[0], flags = _b[1], numChildren = _b[2];
                    offs += paramsSize;
                    var children = readChildren(numChildren);
                    return { type: 'Group', klass: klass, name: name, size: size, children: children };
                }
            case 'AmbColor':
                {
                    var _c = __read(unpack(params, 'BBBB'), 4), r = _c[0], g = _c[1], b = _c[2], a = _c[3];
                    return { type: 'AmbColor', klass: klass, name: name, size: size, r: r, g: g, b: b, a: a };
                }
            case 'Light':
                {
                    var _d = __read(unpack(params, 'fffBBBBf'), 8), x = _d[0], y = _d[1], z = _d[2], r = _d[3], g = _d[4], b = _d[5], a = _d[6], intensity = _d[7];
                    return { type: 'Light', klass: klass, name: name, size: size, x: x, y: y, z: z, r: r, g: g, b: b, a: a, intensity: intensity };
                }
            // Models
            case 'BananaTree':
            case 'Coin':
            case 'CoinRed':
            case 'Fence':
            case 'FenceInner':
            case 'FenceRevolve':
            case 'FenceWaterH':
            case 'FenceWaterV':
            case 'FerrisWheel':
            case 'IceBlock':
            case 'Manhole':
            case 'MapObjBase':
            case 'MapStaticObj':
            case 'Merrygoround':
            case 'MonumentShine':
            case 'Palm':
            case 'PalmNatume':
            case 'PalmOugi':
            case 'PinnaDoor':
            case 'ShellCup':
            case 'WoodBarrel':
            case 'WoodBlock':
            case 'Viking':
                {
                    // XXX(jstpierre): MapObjBase AirportPole seemingly has extra junk after it?
                    var _e = __read(unpack(params, 'ffffff fffsi s.'), 13), paramsSize = _e[0], x = _e[1], y = _e[2], z = _e[3], rotationX = _e[4], rotationY = _e[5], rotationZ = _e[6], scaleX = _e[7], scaleY = _e[8], scaleZ = _e[9], manager = _e[10], flags = _e[11], model = _e[12];
                    return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
                }
            // Extra unk junk
            case 'CoinBlue':
                {
                    var _f = __read(unpack(params, 'ffffff fffsi s i'), 13), paramsSize = _f[0], x = _f[1], y = _f[2], z = _f[3], rotationX = _f[4], rotationY = _f[5], rotationZ = _f[6], scaleX = _f[7], scaleY = _f[8], scaleZ = _f[9], manager = _f[10], flags = _f[11], model = _f[12];
                    return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
                }
            case 'NozzleBox':
                {
                    var _g = __read(unpack(params, 'ffffff fffsi s ssff'), 13), paramsSize = _g[0], x = _g[1], y = _g[2], z = _g[3], rotationX = _g[4], rotationY = _g[5], rotationZ = _g[6], scaleX = _g[7], scaleY = _g[8], scaleZ = _g[9], manager = _g[10], flags = _g[11], model = _g[12];
                    return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
                }
            case 'Shine':
                {
                    var _h = __read(unpack(params, 'ffffff fffsi s sii'), 13), paramsSize = _h[0], x = _h[1], y = _h[2], z = _h[3], rotationX = _h[4], rotationY = _h[5], rotationZ = _h[6], scaleX = _h[7], scaleY = _h[8], scaleZ = _h[9], manager = _h[10], flags = _h[11], model = _h[12];
                    return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
                }
            case 'FruitsBoat':
                {
                    var _j = __read(unpack(params, 'ffffff fffsi s s'), 13), paramsSize = _j[0], x = _j[1], y = _j[2], z = _j[3], rotationX = _j[4], rotationY = _j[5], rotationZ = _j[6], scaleX = _j[7], scaleY = _j[8], scaleZ = _j[9], manager = _j[10], flags = _j[11], model = _j[12];
                    return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
                }
            case 'Billboard':
            case 'BrickBlock':
            case 'DolWeathercock':
            case 'WoodBox':
                {
                    var _k = __read(unpack(params, 'ffffff fffsI s IffI'), 13), paramsSize = _k[0], x = _k[1], y = _k[2], z = _k[3], rotationX = _k[4], rotationY = _k[5], rotationZ = _k[6], scaleX = _k[7], scaleY = _k[8], scaleZ = _k[9], manager = _k[10], flags = _k[11], model = _k[12];
                    return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
                }
            case 'MapObjWaterSpray':
                {
                    var _l = __read(unpack(params, 'ffffff fffsI s IIIIII'), 13), paramsSize = _l[0], x = _l[1], y = _l[2], z = _l[3], rotationX = _l[4], rotationY = _l[5], rotationZ = _l[6], scaleX = _l[7], scaleY = _l[8], scaleZ = _l[9], manager = _l[10], flags = _l[11], model = _l[12];
                    return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
                }
            default:
                var warnUnknown = true;
                // Managers are internal.
                if (klass.endsWith('Manager') || klass.endsWith('Mgr'))
                    warnUnknown = false;
                // Cube maps...
                if (klass.startsWith('Cube'))
                    warnUnknown = false;
                if (warnUnknown)
                    console.warn("Unknown object class " + klassHash + " " + klass + ", size " + size);
                return { type: 'Unknown', klass: klass, name: name, size: size };
        }
    }
    var util_20, render_10, Yaz0, RARC, render_11, scenes_2, gx_material_2, gl_matrix_9, sjisDecoder, SunshineRenderer, SunshineSceneDesc, id, name, sceneDescs, sceneGroup;
    return {
        setters: [
            function (util_20_1) {
                util_20 = util_20_1;
            },
            function (render_10_1) {
                render_10 = render_10_1;
            },
            function (Yaz0_4) {
                Yaz0 = Yaz0_4;
            },
            function (RARC_5) {
                RARC = RARC_5;
            },
            function (render_11_1) {
                render_11 = render_11_1;
            },
            function (scenes_2_1) {
                scenes_2 = scenes_2_1;
            },
            function (gx_material_2_1) {
                gx_material_2 = gx_material_2_1;
            },
            function (gl_matrix_9_1) {
                gl_matrix_9 = gl_matrix_9_1;
            }
        ],
        execute: function () {
            sjisDecoder = new TextDecoder('sjis');
            SunshineRenderer = /** @class */ (function () {
                function SunshineRenderer(textureHolder, skyScene, mapScene, seaScene, seaIndirectScene, extraScenes, rarc) {
                    if (rarc === void 0) { rarc = null; }
                    this.textureHolder = textureHolder;
                    this.skyScene = skyScene;
                    this.mapScene = mapScene;
                    this.seaScene = seaScene;
                    this.seaIndirectScene = seaIndirectScene;
                    this.extraScenes = extraScenes;
                    this.rarc = rarc;
                    this.textures = [];
                    this.mainColorTarget = new render_10.ColorTarget();
                    this.textures = textureHolder.viewerTextures;
                }
                SunshineRenderer.prototype.render = function (state) {
                    var gl = state.gl;
                    this.mainColorTarget.setParameters(gl, state.onscreenColorTarget.width, state.onscreenColorTarget.height);
                    state.useRenderTarget(this.mainColorTarget);
                    gl.clearColor(0, 0, 0.125, 1);
                    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
                    if (this.skyScene) {
                        this.skyScene.render(state);
                        state.useFlags(render_10.depthClearFlags);
                        gl.clear(gl.DEPTH_BUFFER_BIT);
                    }
                    if (this.mapScene)
                        this.mapScene.render(state);
                    if (this.seaScene)
                        this.seaScene.render(state);
                    try {
                        for (var _a = __values(this.extraScenes), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var scene = _b.value;
                            scene.render(state);
                        }
                    }
                    catch (e_36_1) { e_36 = { error: e_36_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_36) throw e_36.error; }
                    }
                    // Copy to main render target.
                    state.useRenderTarget(state.onscreenColorTarget);
                    state.blitColorTarget(this.mainColorTarget);
                    if (this.seaIndirectScene) {
                        var indirectScene = this.seaIndirectScene;
                        var textureOverride = { glTexture: this.mainColorTarget.resolvedColorTexture, width: gx_material_2.EFB_WIDTH, height: gx_material_2.EFB_HEIGHT, flipY: true };
                        this.textureHolder.setTextureOverride("indirectdummy", textureOverride);
                        indirectScene.render(state);
                    }
                    var e_36, _c;
                };
                SunshineRenderer.prototype.destroy = function (gl) {
                    this.textureHolder.destroy(gl);
                    if (this.skyScene)
                        this.skyScene.destroy(gl);
                    if (this.mapScene)
                        this.mapScene.destroy(gl);
                    if (this.seaScene)
                        this.seaScene.destroy(gl);
                    this.extraScenes.forEach(function (scene) { return scene.destroy(gl); });
                };
                return SunshineRenderer;
            }());
            exports_36("SunshineRenderer", SunshineRenderer);
            SunshineSceneDesc = /** @class */ (function () {
                function SunshineSceneDesc(path, name) {
                    this.path = path;
                    this.name = name;
                    this.name = name;
                    this.path = path;
                    this.id = this.name;
                }
                SunshineSceneDesc.createSunshineSceneForBasename = function (gl, textureHolder, rarc, basename, isSkybox) {
                    var bmdFile = rarc.findFile(basename + ".bmd");
                    if (!bmdFile)
                        return null;
                    var btkFile = rarc.findFile(basename + ".btk");
                    var brkFile = rarc.findFile(basename + ".brk");
                    var bckFile = rarc.findFile(basename + ".bck");
                    var bmtFile = rarc.findFile(basename + ".bmt");
                    var scene = scenes_2.createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, bmtFile);
                    scene.name = basename;
                    scene.setIsSkybox(isSkybox);
                    return scene;
                };
                SunshineSceneDesc.prototype.createScene = function (gl) {
                    var _this = this;
                    return util_20.fetch(this.path).then(function (result) {
                        return Yaz0.decompress(result);
                    }).then(function (buffer) {
                        var rarc = RARC.parse(buffer);
                        var sceneBin = rarc.findFile('map/scene.bin');
                        var sceneBinObj = readSceneBin(sceneBin.buffer);
                        console.log(sceneBinObj);
                        var textureHolder = new render_11.J3DTextureHolder();
                        var skyScene = SunshineSceneDesc.createSunshineSceneForBasename(gl, textureHolder, rarc, 'map/map/sky', true);
                        var mapScene = SunshineSceneDesc.createSunshineSceneForBasename(gl, textureHolder, rarc, 'map/map/map', false);
                        var seaScene = SunshineSceneDesc.createSunshineSceneForBasename(gl, textureHolder, rarc, 'map/map/sea', false);
                        var seaIndirectScene = SunshineSceneDesc.createSunshineSceneForBasename(gl, textureHolder, rarc, 'map/map/seaindirect', false);
                        var extraScenes = _this.createSceneBinObjects(gl, textureHolder, rarc, sceneBinObj);
                        return new SunshineRenderer(textureHolder, skyScene, mapScene, seaScene, seaIndirectScene, extraScenes, rarc);
                    });
                };
                SunshineSceneDesc.prototype.createSceneBinObjects = function (gl, textureHolder, rarc, obj) {
                    var _this = this;
                    function flatten(L) {
                        var R = [];
                        try {
                            for (var L_1 = __values(L), L_1_1 = L_1.next(); !L_1_1.done; L_1_1 = L_1.next()) {
                                var Ts = L_1_1.value;
                                R.push.apply(R, Ts);
                            }
                        }
                        catch (e_37_1) { e_37 = { error: e_37_1 }; }
                        finally {
                            try {
                                if (L_1_1 && !L_1_1.done && (_a = L_1.return)) _a.call(L_1);
                            }
                            finally { if (e_37) throw e_37.error; }
                        }
                        return R;
                        var e_37, _a;
                    }
                    switch (obj.type) {
                        case 'Group':
                            var childTs = obj.children.map(function (c) { return _this.createSceneBinObjects(gl, textureHolder, rarc, c); });
                            var flattened = flatten(childTs).filter(function (o) { return !!o; });
                            return flattened;
                        case 'Model':
                            return [this.createSceneForSceneBinModel(gl, textureHolder, rarc, obj)];
                        default:
                            // Don't care.
                            return undefined;
                    }
                };
                SunshineSceneDesc.prototype.createSceneForSceneBinModel = function (gl, textureHolder, rarc, obj) {
                    ;
                    function bmtm(bmd, bmt) {
                        var bmdFile = rarc.findFile(bmd);
                        var bmtFile = rarc.findFile(bmt);
                        return scenes_2.createScene(gl, textureHolder, bmdFile, null, null, null, bmtFile);
                    }
                    function bckm(bmdFilename, bckFilename, loopMode) {
                        if (loopMode === void 0) { loopMode = 2 /* REPEAT */; }
                        var bmdFile = rarc.findFile(bmdFilename);
                        var bckFile = rarc.findFile(bckFilename);
                        var scene = scenes_2.createScene(gl, textureHolder, bmdFile, null, null, bckFile, null);
                        scene.bck.ank1.loopMode = loopMode;
                        return scene;
                    }
                    var modelLookup = [
                        { k: 'BananaTree', m: 'BananaTree', p: 'mapobj/bananatree' },
                        { k: 'BrickBlock', m: 'BrickBlock', p: 'mapobj/brickblock' },
                        { k: 'Coin', m: 'coin', p: 'mapobj/coin' },
                        { k: 'Coin', m: 'invisible_coin', p: 'mapobj/coin' },
                        { k: 'Coin', m: 'invisible_coin', p: 'mapobj/coin' },
                        { k: 'CoinRed', m: 'coin_red', p: 'mapobj/coin_red' },
                        { k: 'CoinBlue', m: 'coin_blue', p: 'mapobj/coin_blue' },
                        { k: 'DolWeathercock', m: 'dptWeathercock', p: 'mapobj/dptweathercock' },
                        { k: 'Fence', m: 'fence_normal', p: 'mapobj/fence_normal' },
                        { k: 'Fence', m: 'fence3x3', p: 'mapobj/fence_half' },
                        { k: 'FenceRevolve', m: 'fence_revolve', p: 'mapobj/fence_revolve_outer' },
                        { k: 'FenceInner', m: 'fenceInnerGreen', p: 'mapobj/fenceinnergreen' },
                        { k: 'FenceWaterH', m: 'FenceWaterH', p: 'mapobj/fencewaterh' },
                        { k: 'FenceWaterV', m: 'FenceWaterV', p: 'mapobj/fencewaterv' },
                        { k: 'FerrisWheel', m: 'FerrisWheel', p: 'mapobj/ferriswheel' },
                        { k: 'IceBlock', m: 'IceBlock', p: 'mapobj/iceblock' },
                        { k: 'Manhole', m: 'manhole', p: 'mapobj/manhole' },
                        { k: 'MapObjBase', m: 'DokanGate', p: 'mapobj/efdokangate' },
                        { k: 'MapObjBase', m: 'ArrowBoardLR', s: function () { return bmtm('mapobj/arrowboardlr.bmd', 'mapobj/arrowboard.bmt'); } },
                        { k: 'MapObjBase', m: 'ArrowBoardUp', s: function () { return bmtm('mapobj/arrowboardup.bmd', 'mapobj/arrowboard.bmt'); } },
                        { k: 'MapObjBase', m: 'ArrowBoardDown', s: function () { return bmtm('mapobj/arrowboarddown.bmd', 'mapobj/arrowboard.bmt'); } },
                        { k: 'MapObjBase', m: 'monte_chair', p: 'mapobj/monte_chair_model' },
                        { k: 'MapStaticObj', m: 'ReflectSky', s: function () { return bmtm('map/map/reflectsky.bmd', 'map/map/sky.bmt'); } },
                        // Disable SeaIndirect loading...
                        { k: 'MapStaticObj', m: 'SeaIndirect', s: function () { return null; } },
                        { k: 'Merrygoround', m: 'merry', p: 'mapobj/merry' },
                        { k: 'NozzleBox', m: 'NozzleBox', p: 'mapobj/nozzlebox' },
                        { k: 'Palm', m: 'palmNormal', p: 'mapobj/palmnormal' },
                        { k: 'Palm', m: 'palmLeaf', p: 'mapobj/palmleaf' },
                        { k: 'PalmNatume', m: 'palmNatume', p: 'mapobj/palmnatume' },
                        { k: 'PalmOugi', m: 'palmOugi', p: 'mapobj/palmougi' },
                        { k: 'PinnaDoor', m: 'PinnaDoor', p: 'mapobj/pinnadoor' },
                        { k: 'ShellCup', m: 'ShellCup', p: 'mapobj/shellcup' },
                        { k: 'Shine', m: 'shine', s: function () { return bckm('mapobj/shine.bmd', 'mapobj/shine_float.bck'); } },
                        { k: 'Viking', m: 'viking', p: 'mapobj/viking' },
                        { k: 'WoodBox', m: 'WoodBox', p: 'mapobj/kibako' },
                        { k: 'WoodBarrel', m: 'wood_barrel', s: function () { return bmtm('mapobj/barrel_normal.bmd', 'mapobj/barrel.bmt'); } },
                    ];
                    var modelEntry = modelLookup.find(function (lt) { return obj.klass === lt.k && obj.model === lt.m; });
                    if (modelEntry === undefined) {
                        // Load heuristics -- maybe should be explicit...
                        var prefix = void 0;
                        if (obj.klass === 'MapStaticObj') {
                            prefix = "map/map/" + obj.model.toLowerCase();
                        }
                        else if (obj.klass === 'MapObjBase') {
                            prefix = "mapobj/" + obj.model.toLowerCase();
                        }
                        if (prefix) {
                            var file = rarc.findFile(prefix + ".bmd");
                            if (file)
                                modelEntry = { k: obj.klass, m: obj.model, p: prefix };
                        }
                    }
                    if (modelEntry === undefined) {
                        console.warn("No model for " + obj.klass + " " + obj.model);
                        return null;
                    }
                    var scene = null;
                    if (modelEntry.p !== undefined) {
                        scene = SunshineSceneDesc.createSunshineSceneForBasename(gl, textureHolder, rarc, modelEntry.p, false);
                    }
                    else if (modelEntry.s !== undefined) {
                        scene = modelEntry.s();
                    }
                    if (scene === null)
                        return null;
                    var q = gl_matrix_9.quat.create();
                    gl_matrix_9.quat.fromEuler(q, obj.rotationX, obj.rotationY, obj.rotationZ);
                    gl_matrix_9.mat4.fromRotationTranslationScale(scene.modelMatrix, q, [obj.x, obj.y, obj.z], [obj.scaleX, obj.scaleY, obj.scaleZ]);
                    return scene;
                };
                return SunshineSceneDesc;
            }());
            exports_36("SunshineSceneDesc", SunshineSceneDesc);
            id = "sms";
            name = "Super Mario Sunshine";
            sceneDescs = [
                new SunshineSceneDesc("data/j3d/sms/dolpic0.szs", "Delfino Plaza"),
                new SunshineSceneDesc("data/j3d/sms/airport0.szs", "Delfino Airport"),
                new SunshineSceneDesc("data/j3d/sms/bianco0.szs", "Bianco Hills"),
                new SunshineSceneDesc("data/j3d/sms/ricco0.szs", "Ricco Harbor"),
                new SunshineSceneDesc("data/j3d/sms/mamma0.szs", "Gelato Beach"),
                new SunshineSceneDesc("data/j3d/sms/pinnaBeach0.szs", "Pinna Park Beach"),
                new SunshineSceneDesc("data/j3d/sms/pinnaParco0.szs", "Pinna Park"),
                new SunshineSceneDesc("data/j3d/sms/sirena0.szs", "Sirena Beach"),
                new SunshineSceneDesc("data/j3d/sms/delfino0.szs", "Delfino Hotel"),
                new SunshineSceneDesc("data/j3d/sms/mare0.szs", "Noki Bay"),
                new SunshineSceneDesc("data/j3d/sms/monte3.szs", "Pianta Village"),
            ];
            exports_36("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
System.register("j3d/smg_scenes", ["Progressable", "util", "render", "Program", "j3d/render", "j3d/scenes", "gx/gx_material"], function (exports_37, context_37) {
    "use strict";
    var __moduleName = context_37 && context_37.id;
    var Progressable_4, util_21, render_12, Program_5, render_13, scenes_3, gx_material_3, BloomPassBlurProgram, BloomPassBokehProgram, SMGRenderer, SMGSceneDesc, id, name, sceneDescs, sceneGroup;
    return {
        setters: [
            function (Progressable_4_1) {
                Progressable_4 = Progressable_4_1;
            },
            function (util_21_1) {
                util_21 = util_21_1;
            },
            function (render_12_1) {
                render_12 = render_12_1;
            },
            function (Program_5_1) {
                Program_5 = Program_5_1;
            },
            function (render_13_1) {
                render_13 = render_13_1;
            },
            function (scenes_3_1) {
                scenes_3 = scenes_3_1;
            },
            function (gx_material_3_1) {
                gx_material_3 = gx_material_3_1;
            }
        ],
        execute: function () {
            // Should I try to do this with GX? lol.
            BloomPassBlurProgram = /** @class */ (function (_super) {
                __extends(BloomPassBlurProgram, _super);
                function BloomPassBlurProgram() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.frag = "\nuniform sampler2D u_Texture;\nin vec2 v_TexCoord;\n\nvec3 TevOverflow(vec3 a) { return fract(a*(255.0/256.0))*(256.0/255.0); }\nvoid main() {\n    // Nintendo does this in two separate draws. We combine into one here...\n    vec3 c = vec3(0.0);\n    // Pass 1.\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00562, -1.0 *  0.00000)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00281, -1.0 * -0.00866)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00281, -1.0 * -0.00866)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00562, -1.0 *  0.00000)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00281, -1.0 *  0.00866)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00281, -1.0 *  0.00866)).rgb * 0.15686);\n    // Pass 2.\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00977, -1.0 * -0.00993)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00004, -1.0 * -0.02000)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00972, -1.0 * -0.01006)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00976, -1.0 *  0.00993)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00004, -1.0 *  0.02000)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00972, -1.0 *  0.01006)).rgb * 0.15686);\n    gl_FragColor = vec4(c.rgb, 1.0);\n}\n";
                    return _this;
                }
                return BloomPassBlurProgram;
            }(Program_5.FullscreenProgram));
            BloomPassBokehProgram = /** @class */ (function (_super) {
                __extends(BloomPassBokehProgram, _super);
                function BloomPassBokehProgram() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.frag = "\nuniform sampler2D u_Texture;\nin vec2 v_TexCoord;\n\nvec3 TevOverflow(vec3 a) { return fract(a*(255.0/256.0))*(256.0/255.0); }\nvoid main() {\n    vec3 f = vec3(0.0);\n    vec3 c;\n\n    // TODO(jstpierre): Double-check these passes. It seems weighted towards the top left. IS IT THE BLUR???\n\n    // Pass 1.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.02250, -1.0 *  0.00000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01949, -1.0 * -0.02000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01125, -1.0 * -0.03464)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00000, -1.0 * -0.04000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01125, -1.0 * -0.03464)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01948, -1.0 * -0.02001)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.02250, -1.0 *  0.00000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01949, -1.0 *  0.02000)).rgb) * 0.23529;\n    f += TevOverflow(c);\n    // Pass 2.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01125, -1.0 *  0.03464)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00000, -1.0 *  0.04000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01125, -1.0 *  0.03464)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01948, -1.0 *  0.02001)).rgb) * 0.23529;\n    f += TevOverflow(c);\n    // Pass 3.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.03937, -1.0 *  0.00000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.03410, -1.0 * -0.03499)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01970, -1.0 * -0.06061)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00000, -1.0 * -0.07000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01968, -1.0 * -0.06063)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.03409, -1.0 * -0.03502)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.03937, -1.0 *  0.00000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.03410, -1.0 *  0.03499)).rgb) * 0.23529;\n    f += TevOverflow(c);\n    // Pass 4.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01970, -1.0 *  0.06061)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00000, -1.0 *  0.07000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01968, -1.0 *  0.06063)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.03409, -1.0 *  0.03502)).rgb) * 0.23529;\n    f += TevOverflow(c);\n    // Pass 5.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.05063, -1.0 *  0.00000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.04385, -1.0 * -0.04499)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.02532, -1.0 * -0.07793)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00000, -1.0 * -0.09000)).rgb) * 0.23529;\n    f += TevOverflow(c);\n    // Pass 6.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.02532, -1.0 *  0.07793)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00000, -1.0 *  0.09000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.02531, -1.0 *  0.07795)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.04384, -1.0 *  0.04502)).rgb) * 0.23529;\n    f += TevOverflow(c);\n\n    f = clamp(f, 0.0, 1.0);\n\n    // Combine pass.\n    vec3 g;\n    g = (texture(u_Texture, v_TexCoord).rgb * 0.43137);\n    g += f * 0.43137;\n\n    gl_FragColor = vec4(g, 1.0);\n}\n";
                    return _this;
                }
                return BloomPassBokehProgram;
            }(Program_5.FullscreenProgram));
            SMGRenderer = /** @class */ (function () {
                function SMGRenderer(gl, textureHolder, mainScene, skyboxScene, bloomScene, indirectScene) {
                    this.textureHolder = textureHolder;
                    this.mainScene = mainScene;
                    this.skyboxScene = skyboxScene;
                    this.bloomScene = bloomScene;
                    this.indirectScene = indirectScene;
                    this.textures = [];
                    this.mainColorTarget = new render_12.ColorTarget();
                    // Bloom stuff.
                    this.bloomColorTarget1 = new render_12.ColorTarget();
                    this.bloomColorTarget2 = new render_12.ColorTarget();
                    this.bloomColorTarget3 = new render_12.ColorTarget();
                    this.bloomPassBlurProgram = new BloomPassBlurProgram();
                    this.bloomPassBokehProgram = new BloomPassBokehProgram();
                    this.textures = textureHolder.viewerTextures;
                    this.bloomCombineFlags = new render_12.RenderFlags();
                    this.bloomCombineFlags.blendMode = render_12.BlendMode.ADD;
                    this.bloomCombineFlags.blendSrc = render_12.BlendFactor.ONE;
                    this.bloomCombineFlags.blendDst = render_12.BlendFactor.ONE;
                }
                SMGRenderer.prototype.render = function (state) {
                    var gl = state.gl;
                    this.mainColorTarget.setParameters(gl, state.onscreenColorTarget.width, state.onscreenColorTarget.height);
                    state.useRenderTarget(this.mainColorTarget);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    this.skyboxScene.bindState(state);
                    this.skyboxScene.renderOpaque(state);
                    gl.clear(gl.DEPTH_BUFFER_BIT);
                    this.mainScene.bindState(state);
                    this.mainScene.renderOpaque(state);
                    this.mainScene.renderTransparent(state);
                    // Copy to main render target.
                    state.useRenderTarget(state.onscreenColorTarget);
                    state.blitColorTarget(this.mainColorTarget);
                    if (this.indirectScene) {
                        var textureOverride = { glTexture: this.mainColorTarget.resolvedColorTexture, width: gx_material_3.EFB_WIDTH, height: gx_material_3.EFB_HEIGHT, flipY: true };
                        this.textureHolder.setTextureOverride("IndDummy", textureOverride);
                        this.indirectScene.bindState(state);
                        this.indirectScene.renderOpaque(state);
                    }
                    if (this.bloomScene) {
                        var gl_1 = state.gl;
                        var bloomColorTargetScene = this.bloomColorTarget1;
                        bloomColorTargetScene.setParameters(gl_1, state.onscreenColorTarget.width, state.onscreenColorTarget.height);
                        state.useRenderTarget(bloomColorTargetScene);
                        gl_1.clearColor(0, 0, 0, 0);
                        gl_1.clear(gl_1.COLOR_BUFFER_BIT);
                        this.bloomScene.render(state);
                        // First downsample.
                        var bloomColorTargetDownsample = this.bloomColorTarget2;
                        var bloomWidth = state.onscreenColorTarget.width >> 2;
                        var bloomHeight = state.onscreenColorTarget.height >> 2;
                        bloomColorTargetDownsample.setParameters(gl_1, bloomWidth, bloomHeight);
                        state.useRenderTarget(bloomColorTargetDownsample, null);
                        state.blitColorTarget(bloomColorTargetScene);
                        // First pass is a blur.
                        var bloomColorTargetBlur = this.bloomColorTarget3;
                        bloomColorTargetDownsample.resolve(gl_1);
                        bloomColorTargetBlur.setParameters(gl_1, bloomColorTargetDownsample.width, bloomColorTargetDownsample.height);
                        state.useRenderTarget(bloomColorTargetBlur, null);
                        state.useProgram(this.bloomPassBlurProgram);
                        gl_1.bindTexture(gl_1.TEXTURE_2D, bloomColorTargetDownsample.resolvedColorTexture);
                        state.runFullscreen();
                        // TODO(jstpierre): Downsample blur / bokeh as well.
                        // Second pass is bokeh-ify.
                        // We can ditch the second render target now, so just reuse it.
                        var bloomColorTargetBokeh = this.bloomColorTarget2;
                        bloomColorTargetBlur.resolve(gl_1);
                        state.useRenderTarget(bloomColorTargetBokeh, null);
                        state.useProgram(this.bloomPassBokehProgram);
                        gl_1.clear(gl_1.COLOR_BUFFER_BIT);
                        gl_1.bindTexture(gl_1.TEXTURE_2D, bloomColorTargetBlur.resolvedColorTexture);
                        state.runFullscreen();
                        // Third pass combines.
                        state.useRenderTarget(state.onscreenColorTarget);
                        state.blitColorTarget(bloomColorTargetBokeh, this.bloomCombineFlags);
                    }
                };
                SMGRenderer.prototype.destroy = function (gl) {
                    this.textureHolder.destroy(gl);
                    this.mainScene.destroy(gl);
                    this.skyboxScene.destroy(gl);
                    this.bloomScene.destroy(gl);
                    this.indirectScene.destroy(gl);
                    this.bloomColorTarget1.destroy(gl);
                    this.bloomColorTarget2.destroy(gl);
                    this.bloomColorTarget3.destroy(gl);
                };
                return SMGRenderer;
            }());
            SMGSceneDesc = /** @class */ (function () {
                function SMGSceneDesc(name, mainScenePath, skyboxScenePath, bloomScenePath, indirectScenePath) {
                    if (skyboxScenePath === void 0) { skyboxScenePath = null; }
                    if (bloomScenePath === void 0) { bloomScenePath = null; }
                    if (indirectScenePath === void 0) { indirectScenePath = null; }
                    this.name = name;
                    this.mainScenePath = mainScenePath;
                    this.skyboxScenePath = skyboxScenePath;
                    this.bloomScenePath = bloomScenePath;
                    this.indirectScenePath = indirectScenePath;
                    this.id = mainScenePath;
                }
                SMGSceneDesc.prototype.createScene = function (gl) {
                    var textureHolder = new render_13.J3DTextureHolder();
                    return Progressable_4.default.all([
                        this.fetchScene(gl, textureHolder, this.mainScenePath, false),
                        this.fetchScene(gl, textureHolder, this.skyboxScenePath, true),
                        this.fetchScene(gl, textureHolder, this.bloomScenePath, false),
                        this.fetchScene(gl, textureHolder, this.indirectScenePath, false),
                    ]).then(function (scenes) {
                        var _a = __read(scenes, 4), mainScene = _a[0], skyboxScene = _a[1], bloomScene = _a[2], indirectScene = _a[3];
                        return new SMGRenderer(gl, textureHolder, mainScene, skyboxScene, bloomScene, indirectScene);
                    });
                };
                SMGSceneDesc.prototype.fetchScene = function (gl, textureHolder, filename, isSkybox) {
                    var _this = this;
                    if (filename === null)
                        return new Progressable_4.default(Promise.resolve(null));
                    var path = "data/j3d/smg/" + filename;
                    return util_21.fetch(path).then(function (buffer) { return _this.createSceneFromBuffer(gl, textureHolder, buffer, isSkybox); });
                };
                SMGSceneDesc.prototype.createSceneFromBuffer = function (gl, textureHolder, buffer, isSkybox) {
                    return scenes_3.createScenesFromBuffer(gl, textureHolder, buffer).then(function (scenes) {
                        util_21.assert(scenes.length === 1);
                        var scene = scenes[0];
                        scene.setFPS(60);
                        scene.setIsSkybox(isSkybox);
                        return scene;
                    });
                };
                return SMGSceneDesc;
            }());
            id = "smg";
            name = "Super Mario Galaxy";
            sceneDescs = [
                new SMGSceneDesc("Peach's Castle Garden", "PeachCastleGardenPlanet.arc", "GalaxySky.arc", "PeachCastleGardenPlanetBloom.arc", "PeachCastleGardenPlanetIndirect.arc"),
            ];
            exports_37("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
System.register("compression/CX", ["ArrayBufferSlice"], function (exports_38, context_38) {
    "use strict";
    var __moduleName = context_38 && context_38.id;
    // Nintendo's "CX" formats.
    // CX LZ format ("LZ10")
    // Header (4 bytes):
    //   Magic: "\x10" (1 byte)
    //   Uncompressed size (3 bytes, little endian)
    // Data:
    //   Flags (1 byte)
    //   For each bit in the flags byte, from MSB to LSB:
    //     If flag is 1:
    //       LZ77 (2 bytes, big endian):
    //         Length: bits 0-3
    //         Offset: bits 4-15
    //         Copy Length+3 bytes from Offset back in the output buffer.
    //     If flag is 0:
    //       Literal: copy one byte from src to dest.
    function decompressLZ_Normal(srcView) {
        var uncompressedSize = srcView.getUint32(0x00, true) >> 8;
        var dstBuffer = new Uint8Array(uncompressedSize);
        var srcOffs = 0x04;
        var dstOffs = 0x00;
        while (true) {
            var commandByte = srcView.getUint8(srcOffs++);
            var i = 8;
            while (i--) {
                if (commandByte & (1 << i)) {
                    var tmp = srcView.getUint16(srcOffs, false);
                    srcOffs += 2;
                    var windowOffset = (tmp & 0x0FFF) + 1;
                    var windowLength = (tmp >> 12) + 3;
                    var copyOffs = dstOffs - windowOffset;
                    uncompressedSize -= windowLength;
                    while (windowLength--)
                        dstBuffer[dstOffs++] = dstBuffer[copyOffs++];
                }
                else {
                    // Literal.
                    uncompressedSize--;
                    dstBuffer[dstOffs++] = srcView.getUint8(srcOffs++);
                }
                if (uncompressedSize <= 0)
                    return new ArrayBufferSlice_5.default(dstBuffer.buffer);
            }
        }
    }
    exports_38("decompressLZ_Normal", decompressLZ_Normal);
    // CX LZ Extended format ("LZ11")
    // Header (4 bytes):
    //   Magic: "\x11" (1 byte)
    //   Uncompressed size (3 bytes, little endian)
    // Data:
    //   Flags (1 byte)
    //   For each bit in the flags byte, from MSB to LSB:
    //     If flag is 1:
    //       Fancy LZ77. See below for more details. Flag switches on 4-7 of newly read byte.
    //     If flag is 0:
    //       Literal: copy one byte from src to dest.
    function decompressLZ_Extended(srcView) {
        var uncompressedSize = srcView.getUint32(0x00, true) >>> 8;
        var dstBuffer = new Uint8Array(uncompressedSize);
        var srcOffs = 0x04;
        var dstOffs = 0x00;
        while (true) {
            var commandByte = srcView.getUint8(srcOffs++);
            var i = 8;
            while (i--) {
                if (commandByte & (1 << i)) {
                    var indicator = srcView.getUint8(srcOffs) >>> 4;
                    var windowOffset = void 0;
                    var windowLength = void 0;
                    if (indicator > 1) {
                        // Two bytes. AB CD
                        var tmp = srcView.getUint16(srcOffs, false);
                        // Length: A + 1
                        // Offset: BCD + 1
                        windowLength = indicator + 1;
                        windowOffset = (tmp & 0x0FFF) + 1;
                        srcOffs += 2;
                    }
                    else if (indicator === 0) {
                        // Three bytes: AB CD EF
                        var tmp = (srcView.getUint16(srcOffs, false) << 8) | srcView.getUint8(srcOffs + 0x02);
                        // Length: BC + 0x11
                        // Offset: DEF + 1
                        windowLength = (tmp >>> 12) + 0x11;
                        windowOffset = (tmp & 0x0FFF) + 1;
                        srcOffs += 3;
                    }
                    else if (indicator === 1) {
                        // Four bytes. AB CD EF GH
                        var tmp = srcView.getUint32(srcOffs, false);
                        // Length: BCDE + 0x111
                        // Offset: FGH + 1
                        windowLength = ((tmp >>> 12) & 0xFFFF) + 0x111;
                        windowOffset = (tmp & 0x0FFF) + 1;
                        srcOffs += 4;
                    }
                    var copyOffs = dstOffs - windowOffset;
                    uncompressedSize -= windowLength;
                    while (windowLength--)
                        dstBuffer[dstOffs++] = dstBuffer[copyOffs++];
                }
                else {
                    // Literal.
                    uncompressedSize--;
                    dstBuffer[dstOffs++] = srcView.getUint8(srcOffs++);
                }
                if (uncompressedSize <= 0)
                    return new ArrayBufferSlice_5.default(dstBuffer.buffer);
            }
        }
    }
    exports_38("decompressLZ_Extended", decompressLZ_Extended);
    function decompress(srcBuffer) {
        var srcView = srcBuffer.createDataView();
        var magic = srcView.getUint8(0x00);
        var compressionType = magic & 0xF0;
        if (compressionType === CompressionType.LZ) {
            var extendedFormat = !!(magic & 0x0F);
            if (extendedFormat)
                return decompressLZ_Extended(srcView);
            else
                return decompressLZ_Normal(srcView);
        }
        else {
            throw new Error("Unsupported CX compression type");
        }
    }
    exports_38("decompress", decompress);
    var ArrayBufferSlice_5, CompressionType;
    return {
        setters: [
            function (ArrayBufferSlice_5_1) {
                ArrayBufferSlice_5 = ArrayBufferSlice_5_1;
            }
        ],
        execute: function () {
            (function (CompressionType) {
                CompressionType[CompressionType["LZ"] = 16] = "LZ";
            })(CompressionType || (CompressionType = {}));
        }
    };
});
// SM64DS's LZ10 wrapper, which is just a "LZ77" prefix for the file.
System.register("sm64ds/lz77", ["compression/CX", "util"], function (exports_39, context_39) {
    "use strict";
    var __moduleName = context_39 && context_39.id;
    function isLZ77(srcBuffer) {
        return (util_22.readString(srcBuffer, 0x00, 0x05) === 'LZ77\x10');
    }
    exports_39("isLZ77", isLZ77);
    function maybeDecompress(srcBuffer) {
        if (isLZ77(srcBuffer))
            return CX_1.decompress(srcBuffer.slice(4));
        else
            return srcBuffer;
    }
    exports_39("maybeDecompress", maybeDecompress);
    var CX_1, util_22;
    return {
        setters: [
            function (CX_1_1) {
                CX_1 = CX_1_1;
            },
            function (util_22_1) {
                util_22 = util_22_1;
            }
        ],
        execute: function () {
        }
    };
});
// Read DS texture formats.
System.register("sm64ds/nitro_tex", [], function (exports_40, context_40) {
    "use strict";
    var __moduleName = context_40 && context_40.id;
    function expand3to8(n) {
        return (n << (8 - 3)) | (n << (8 - 6)) | (n >>> (9 - 8));
    }
    function expand5to8(n) {
        return (n << (8 - 5)) | (n >>> (10 - 8));
    }
    function s3tcblend(a, b) {
        // return (a*3 + b*5) / 8;
        return (((a << 1) + a) + ((b << 2) + b)) >>> 3;
    }
    function bgr5(pixels, dstOffs, p) {
        pixels[dstOffs + 0] = expand5to8(p & 0x1F);
        pixels[dstOffs + 1] = expand5to8((p >>> 5) & 0x1F);
        pixels[dstOffs + 2] = expand5to8((p >>> 10) & 0x1F);
    }
    exports_40("bgr5", bgr5);
    function readTexture_A3I5(width, height, texData, palData) {
        var pixels = new Uint8Array(width * height * 4);
        var texView = texData.createDataView();
        var palView = palData.createDataView();
        var srcOffs = 0;
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var texBlock = texView.getUint8(srcOffs++);
                var palIdx = (texBlock & 0x1F) << 1;
                var alpha = texBlock >>> 5;
                var p = palView.getUint16(palIdx, true);
                var dstOffs = 4 * ((y * width) + x);
                bgr5(pixels, dstOffs, p);
                pixels[dstOffs + 3] = expand3to8(alpha);
            }
        }
        return pixels;
    }
    function readTexture_Palette16(width, height, texData, palData, color0) {
        var pixels = new Uint8Array(width * height * 4);
        var texView = texData.createDataView();
        var palView = palData.createDataView();
        var srcOffs = 0;
        for (var y = 0; y < height; y++) {
            for (var xx = 0; xx < width; xx += 4) {
                var texBlock = texView.getUint16(srcOffs, true);
                srcOffs += 2;
                for (var x = 0; x < 4; x++) {
                    var palIdx = texBlock & 0x0F;
                    var p = palView.getUint16(palIdx * 2, true);
                    var dstOffs = 4 * ((y * width) + xx + x);
                    bgr5(pixels, dstOffs, p);
                    pixels[dstOffs + 3] = palIdx === 0 ? (color0 ? 0x00 : 0xFF) : 0xFF;
                    texBlock >>= 4;
                }
            }
        }
        return pixels;
    }
    function readTexture_Palette256(width, height, texData, palData, color0) {
        var pixels = new Uint8Array(width * height * 4);
        var texView = texData.createDataView();
        var palView = palData.createDataView();
        var srcOffs = 0;
        for (var y = 0; y < height; y++) {
            for (var xx = 0; xx < width; xx++) {
                var palIdx = texView.getUint8(srcOffs++);
                var p = palView.getUint16(palIdx * 2, true);
                var dstOffs = 4 * ((y * width) + xx);
                bgr5(pixels, dstOffs, p);
                pixels[dstOffs + 3] = palIdx === 0 ? (color0 ? 0x00 : 0xFF) : 0xFF;
            }
        }
        return pixels;
    }
    function readTexture_CMPR_4x4(width, height, texData, palData) {
        function getPal16(offs) {
            return offs < palView.byteLength ? palView.getUint16(offs, true) : 0;
        }
        function buildColorTable(palBlock) {
            var palMode = palBlock >> 14;
            var palOffs = (palBlock & 0x3FFF) << 2;
            var colorTable = new Uint8Array(16);
            var p0 = getPal16(palOffs + 0x00);
            bgr5(colorTable, 0, p0);
            colorTable[3] = 0xFF;
            var p1 = getPal16(palOffs + 0x02);
            bgr5(colorTable, 4, p1);
            colorTable[7] = 0xFF;
            if (palMode === 0) {
                // PTY=0, A=0
                var p2 = getPal16(palOffs + 0x04);
                bgr5(colorTable, 8, p2);
                colorTable[11] = 0xFF;
                // Color4 is transparent black.
            }
            else if (palMode === 1) {
                // PTY=1, A=0
                // Color3 is a blend of Color1/Color2.
                colorTable[8] = (colorTable[0] + colorTable[4]) >>> 1;
                colorTable[9] = (colorTable[1] + colorTable[5]) >>> 1;
                colorTable[10] = (colorTable[2] + colorTable[6]) >>> 1;
                colorTable[11] = 0xFF;
                // Color4 is transparent black.
            }
            else if (palMode === 2) {
                // PTY=0, A=1
                var p2 = getPal16(palOffs + 0x04);
                bgr5(colorTable, 8, p2);
                colorTable[11] = 0xFF;
                var p3 = getPal16(palOffs + 0x06);
                bgr5(colorTable, 12, p3);
                colorTable[15] = 0xFF;
            }
            else {
                colorTable[8] = s3tcblend(colorTable[4], colorTable[0]);
                colorTable[9] = s3tcblend(colorTable[5], colorTable[1]);
                colorTable[10] = s3tcblend(colorTable[6], colorTable[2]);
                colorTable[11] = 0xFF;
                colorTable[12] = s3tcblend(colorTable[0], colorTable[4]);
                colorTable[13] = s3tcblend(colorTable[1], colorTable[5]);
                colorTable[14] = s3tcblend(colorTable[2], colorTable[6]);
                colorTable[15] = 0xFF;
            }
            return colorTable;
        }
        var pixels = new Uint8Array(width * height * 4);
        var texView = texData.createDataView();
        var palView = palData.createDataView();
        var palIdxStart = (width * height) / 4;
        var srcOffs = 0;
        for (var yy = 0; yy < height; yy += 4) {
            for (var xx = 0; xx < width; xx += 4) {
                var texBlock = texView.getUint32((srcOffs * 0x04), true);
                var palBlock = texView.getUint16(palIdxStart + (srcOffs * 0x02), true);
                var colorTable = buildColorTable(palBlock);
                for (var y = 0; y < 4; y++) {
                    for (var x = 0; x < 4; x++) {
                        var colorIdx = texBlock & 0x03;
                        var dstOffs = 4 * (((yy + y) * width) + xx + x);
                        pixels[dstOffs + 0] = colorTable[colorIdx * 4 + 0];
                        pixels[dstOffs + 1] = colorTable[colorIdx * 4 + 1];
                        pixels[dstOffs + 2] = colorTable[colorIdx * 4 + 2];
                        pixels[dstOffs + 3] = colorTable[colorIdx * 4 + 3];
                        texBlock >>= 2;
                    }
                }
                srcOffs++;
            }
        }
        return pixels;
    }
    function readTexture_A5I3(width, height, texData, palData) {
        var pixels = new Uint8Array(width * height * 4);
        var texView = texData.createDataView();
        var palView = palData.createDataView();
        var srcOffs = 0;
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var texBlock = texView.getUint8(srcOffs++);
                var palIdx = (texBlock & 0x03) << 1;
                var alpha = texBlock >>> 3;
                var p = palView.getUint16(palIdx, true);
                var dstOffs = 4 * ((y * width) + x);
                bgr5(pixels, dstOffs, p);
                pixels[dstOffs + 3] = expand5to8(alpha);
            }
        }
        return pixels;
    }
    function readTexture_Direct(width, height, texData) {
        var pixels = new Uint8Array(width * height * 4);
        var texView = texData.createDataView();
        var srcOffs = 0;
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var p = texView.getUint16(srcOffs, true);
                var dstOffs = 4 * ((y * width) + x);
                bgr5(pixels, dstOffs, p);
                pixels[dstOffs + 3] = 0xFF;
                srcOffs += 2;
            }
        }
        return pixels;
    }
    function readTexture(format, width, height, texData, palData, color0) {
        switch (format) {
            case Format.Tex_A3I5:
                return readTexture_A3I5(width, height, texData, palData);
            case Format.Tex_Palette16:
                return readTexture_Palette16(width, height, texData, palData, color0);
            case Format.Tex_Palette256:
                return readTexture_Palette256(width, height, texData, palData, color0);
            case Format.Tex_CMPR_4x4:
                return readTexture_CMPR_4x4(width, height, texData, palData);
            case Format.Tex_A5I3:
                return readTexture_A5I3(width, height, texData, palData);
            case Format.Tex_Direct:
                return readTexture_Direct(width, height, texData);
            default:
                throw new Error("Unsupported texture type! " + format);
        }
    }
    exports_40("readTexture", readTexture);
    var Format;
    return {
        setters: [],
        execute: function () {
            (function (Format) {
                Format[Format["Tex_None"] = 0] = "Tex_None";
                Format[Format["Tex_A3I5"] = 1] = "Tex_A3I5";
                Format[Format["Tex_Palette4"] = 2] = "Tex_Palette4";
                Format[Format["Tex_Palette16"] = 3] = "Tex_Palette16";
                Format[Format["Tex_Palette256"] = 4] = "Tex_Palette256";
                Format[Format["Tex_CMPR_4x4"] = 5] = "Tex_CMPR_4x4";
                Format[Format["Tex_A5I3"] = 6] = "Tex_A5I3";
                Format[Format["Tex_Direct"] = 7] = "Tex_Direct";
            })(Format || (Format = {}));
            exports_40("Format", Format);
        }
    };
});
// Read DS Geometry Engine commands.
System.register("sm64ds/nitro_gx", ["sm64ds/nitro_tex"], function (exports_41, context_41) {
    "use strict";
    var __moduleName = context_41 && context_41.id;
    function bgr5(pixel) {
        nitro_tex_1.bgr5(tmp, 0, pixel);
        var r = tmp[0], g = tmp[1], b = tmp[2];
        return { r: r, g: g, b: b };
    }
    exports_41("bgr5", bgr5);
    function cmd_MTX_RESTORE(ctx) {
        // XXX: We don't implement the matrix stack yet.
        ctx.readParam();
    }
    function cmd_COLOR(ctx) {
        var param = ctx.readParam();
        ctx.s_color = bgr5(param);
    }
    function cmd_NORMAL(ctx) {
        var param = ctx.readParam();
    }
    function cmd_TEXCOORD(ctx) {
        var param = ctx.readParam();
        var s = param & 0xFFFF;
        var t = param >> 16;
        // Sign extend.
        s = (s << 16 >> 16);
        t = (t << 16 >> 16);
        // Fixed point.
        s = s / 16.0;
        t = t / 16.0;
        ctx.s_texCoord = { s: s, t: t };
    }
    function cmd_VTX_16(ctx) {
        var param1 = ctx.readParam();
        var x = (param1 & 0xFFFF);
        var y = (param1 >> 16) & 0xFFFF;
        var param2 = ctx.readParam();
        var z = (param2 & 0xFFFF);
        // Sign extend.
        x = (x << 16 >> 16);
        y = (y << 16 >> 16);
        z = (z << 16 >> 16);
        // Fixed point.
        x = x / 4096.0;
        y = y / 4096.0;
        z = z / 4096.0;
        ctx.vtx(x, y, z);
    }
    function cmd_VTX_10(ctx) {
        var param = ctx.readParam();
        var x = (param & 0x03FF);
        var y = (param >> 10) & 0x03FF;
        var z = (param >> 20) & 0x03FF;
        // Sign extend.
        x = (x << 22 >> 22);
        y = (y << 22 >> 22);
        z = (z << 22 >> 22);
        // Fixed point.
        x = x / 64.0;
        y = y / 64.0;
        z = z / 64.0;
        ctx.vtx(x, y, z);
    }
    function cmd_VTX_XY(ctx) {
        var param = ctx.readParam();
        var x = (param & 0xFFFF);
        var y = (param >> 16) & 0xFFFF;
        // Sign extend.
        x = (x << 16 >> 16);
        y = (y << 16 >> 16);
        // Fixed point.
        x = x / 4096.0;
        y = y / 4096.0;
        ctx.vtx(x, y, ctx.s_vtx.z);
    }
    function cmd_VTX_XZ(ctx) {
        var param = ctx.readParam();
        var x = (param & 0xFFFF);
        var z = (param >> 16) & 0xFFFF;
        // Sign extend.
        x = (x << 16 >> 16);
        z = (z << 16 >> 16);
        // Fixed point.
        x = x / 4096.0;
        z = z / 4096.0;
        ctx.vtx(x, ctx.s_vtx.y, z);
    }
    function cmd_VTX_YZ(ctx) {
        var param = ctx.readParam();
        var y = (param & 0xFFFF);
        var z = (param >> 16) & 0xFFFF;
        // Sign extend.
        y = (y << 16 >> 16);
        z = (z << 16 >> 16);
        // Fixed point.
        y = y / 4096.0;
        z = z / 4096.0;
        ctx.vtx(ctx.s_vtx.x, y, z);
    }
    function cmd_VTX_DIFF(ctx) {
        var param = ctx.readParam();
        var x = (param & 0x03FF);
        var y = (param >> 10) & 0x03FF;
        var z = (param >> 20) & 0x03FF;
        // Sign extend.
        x = (x << 22 >> 22);
        y = (y << 22 >> 22);
        z = (z << 22 >> 22);
        // Fixed point.
        x = x / 4096.0;
        y = y / 4096.0;
        z = z / 4096.0;
        // Add on the difference...
        x += ctx.s_vtx.x;
        y += ctx.s_vtx.y;
        z += ctx.s_vtx.z;
        ctx.vtx(x, y, z);
    }
    function cmd_DIF_AMB(ctx) {
        var param = ctx.readParam();
        // TODO: lighting
    }
    function cmd_BEGIN_VTXS(ctx) {
        var param = ctx.readParam();
        var polyType = param & 0x03;
        ctx.s_polyType = polyType;
        ctx.vtxs = [];
    }
    function cmd_END_VTXS(ctx) {
        var nVerts = ctx.vtxs.length;
        var vtxBuffer = new Float32Array(nVerts * VERTEX_SIZE);
        for (var i = 0; i < nVerts; i++) {
            var v = ctx.vtxs[i];
            var vtxArray = new Float32Array(vtxBuffer.buffer, i * VERTEX_BYTES, VERTEX_SIZE);
            vtxArray[0] = v.pos.x;
            vtxArray[1] = v.pos.y;
            vtxArray[2] = v.pos.z;
            vtxArray[3] = v.color.r / 0xFF;
            vtxArray[4] = v.color.g / 0xFF;
            vtxArray[5] = v.color.b / 0xFF;
            vtxArray[6] = ctx.alpha / 0xFF;
            vtxArray[7] = v.uv.s;
            vtxArray[8] = v.uv.t;
        }
        var idxBuffer;
        if (ctx.s_polyType === PolyType.TRIANGLES) {
            idxBuffer = new Uint16Array(nVerts);
            for (var i = 0; i < nVerts; i++)
                idxBuffer[i] = i;
        }
        else if (ctx.s_polyType === PolyType.QUADS) {
            idxBuffer = new Uint16Array(nVerts / 4 * 6);
            var dst = 0;
            for (var i = 0; i < nVerts; i += 4) {
                idxBuffer[dst++] = i + 0;
                idxBuffer[dst++] = i + 1;
                idxBuffer[dst++] = i + 2;
                idxBuffer[dst++] = i + 2;
                idxBuffer[dst++] = i + 3;
                idxBuffer[dst++] = i + 0;
            }
        }
        else if (ctx.s_polyType === PolyType.TRIANGLE_STRIP) {
            idxBuffer = new Uint16Array((nVerts - 2) * 3);
            var dst = 0;
            for (var i = 0; i < nVerts - 2; i++) {
                if (i % 2 === 0) {
                    idxBuffer[dst++] = i + 0;
                    idxBuffer[dst++] = i + 1;
                    idxBuffer[dst++] = i + 2;
                }
                else {
                    idxBuffer[dst++] = i + 1;
                    idxBuffer[dst++] = i + 0;
                    idxBuffer[dst++] = i + 2;
                }
            }
        }
        else if (ctx.s_polyType === PolyType.QUAD_STRIP) {
            idxBuffer = new Uint16Array(((nVerts - 2) / 2) * 6);
            var dst = 0;
            for (var i = 0; i < nVerts; i += 2) {
                idxBuffer[dst++] = i + 0;
                idxBuffer[dst++] = i + 1;
                idxBuffer[dst++] = i + 3;
                idxBuffer[dst++] = i + 3;
                idxBuffer[dst++] = i + 2;
                idxBuffer[dst++] = i + 0;
            }
        }
        var packet = { vertData: vtxBuffer, idxData: idxBuffer, polyType: ctx.s_polyType };
        ctx.packets.push(packet);
    }
    function runCmd(ctx, cmd) {
        switch (cmd) {
            case 0: return;
            case CmdType.MTX_RESTORE: return cmd_MTX_RESTORE(ctx);
            case CmdType.COLOR: return cmd_COLOR(ctx);
            case CmdType.NORMAL: return cmd_NORMAL(ctx);
            case CmdType.TEXCOORD: return cmd_TEXCOORD(ctx);
            case CmdType.VTX_16: return cmd_VTX_16(ctx);
            case CmdType.VTX_10: return cmd_VTX_10(ctx);
            case CmdType.VTX_XY: return cmd_VTX_XY(ctx);
            case CmdType.VTX_XZ: return cmd_VTX_XZ(ctx);
            case CmdType.VTX_YZ: return cmd_VTX_YZ(ctx);
            case CmdType.VTX_DIFF: return cmd_VTX_DIFF(ctx);
            case CmdType.DIF_AMB: return cmd_DIF_AMB(ctx);
            case CmdType.BEGIN_VTXS: return cmd_BEGIN_VTXS(ctx);
            case CmdType.END_VTXS: return cmd_END_VTXS(ctx);
            default: console.warn("Missing command", cmd.toString(16));
        }
    }
    function readCmds(buffer, baseCtx) {
        var ctx = new ContextInternal(buffer, baseCtx);
        while (ctx.offs < buffer.byteLength) {
            // Commands are packed 4 at a time...
            var cmd0 = ctx.view.getUint8(ctx.offs++);
            var cmd1 = ctx.view.getUint8(ctx.offs++);
            var cmd2 = ctx.view.getUint8(ctx.offs++);
            var cmd3 = ctx.view.getUint8(ctx.offs++);
            runCmd(ctx, cmd0);
            runCmd(ctx, cmd1);
            runCmd(ctx, cmd2);
            runCmd(ctx, cmd3);
        }
        return ctx.packets;
    }
    exports_41("readCmds", readCmds);
    var nitro_tex_1, CmdType, PolyType, VERTEX_SIZE, VERTEX_BYTES, tmp, Context, ContextInternal;
    return {
        setters: [
            function (nitro_tex_1_1) {
                nitro_tex_1 = nitro_tex_1_1;
            }
        ],
        execute: function () {
            // tslint:disable:variable-name
            (function (CmdType) {
                CmdType[CmdType["MTX_RESTORE"] = 20] = "MTX_RESTORE";
                CmdType[CmdType["COLOR"] = 32] = "COLOR";
                CmdType[CmdType["NORMAL"] = 33] = "NORMAL";
                CmdType[CmdType["TEXCOORD"] = 34] = "TEXCOORD";
                CmdType[CmdType["VTX_16"] = 35] = "VTX_16";
                CmdType[CmdType["VTX_10"] = 36] = "VTX_10";
                CmdType[CmdType["VTX_XY"] = 37] = "VTX_XY";
                CmdType[CmdType["VTX_XZ"] = 38] = "VTX_XZ";
                CmdType[CmdType["VTX_YZ"] = 39] = "VTX_YZ";
                CmdType[CmdType["VTX_DIFF"] = 40] = "VTX_DIFF";
                CmdType[CmdType["DIF_AMB"] = 48] = "DIF_AMB";
                CmdType[CmdType["BEGIN_VTXS"] = 64] = "BEGIN_VTXS";
                CmdType[CmdType["END_VTXS"] = 65] = "END_VTXS";
            })(CmdType || (CmdType = {}));
            (function (PolyType) {
                PolyType[PolyType["TRIANGLES"] = 0] = "TRIANGLES";
                PolyType[PolyType["QUADS"] = 1] = "QUADS";
                PolyType[PolyType["TRIANGLE_STRIP"] = 2] = "TRIANGLE_STRIP";
                PolyType[PolyType["QUAD_STRIP"] = 3] = "QUAD_STRIP";
            })(PolyType || (PolyType = {}));
            // 3 pos + 4 color + 2 uv
            VERTEX_SIZE = 9;
            VERTEX_BYTES = VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT;
            tmp = new Uint8Array(3);
            Context = /** @class */ (function () {
                function Context() {
                }
                return Context;
            }());
            exports_41("Context", Context);
            ContextInternal = /** @class */ (function () {
                function ContextInternal(buffer, baseCtx) {
                    this.offs = 0;
                    this.alpha = baseCtx.alpha;
                    this.s_color = baseCtx.color;
                    this.view = buffer.createDataView();
                    this.s_texCoord = { s: 0, t: 0 };
                    this.packets = [];
                }
                ContextInternal.prototype.readParam = function () {
                    return this.view.getUint32((this.offs += 4) - 4, true);
                };
                ContextInternal.prototype.vtx = function (x, y, z) {
                    this.s_vtx = { x: x, y: y, z: z };
                    this.vtxs.push({ pos: this.s_vtx, nrm: this.s_nrm, color: this.s_color, uv: this.s_texCoord });
                };
                return ContextInternal;
            }());
        }
    };
});
System.register("sm64ds/nitro_bmd", ["gl-matrix", "sm64ds/nitro_gx", "sm64ds/nitro_tex", "util"], function (exports_42, context_42) {
    "use strict";
    var __moduleName = context_42 && context_42.id;
    function parseModel(bmd, buffer, idx) {
        var offs = bmd.modelOffsBase + idx * 0x40;
        var view = buffer.createDataView();
        var model = new Model();
        model.id = view.getUint32(offs + 0x00, true);
        model.name = util_23.readString(buffer, view.getUint32(offs + 0x04, true), 0xFF);
        model.parentID = view.getUint16(offs + 0x08, true);
        // Local transform.
        var xs = view.getUint32(offs + 0x10, true);
        var ys = view.getUint32(offs + 0x14, true);
        var zs = view.getUint32(offs + 0x18, true);
        var xr = view.getUint16(offs + 0x1C, true);
        var yr = view.getUint16(offs + 0x1E, true);
        var zr = view.getUint16(offs + 0x20, true);
        var xt = view.getUint16(offs + 0x24, true);
        var yt = view.getUint16(offs + 0x28, true);
        var zt = view.getUint16(offs + 0x2C, true);
        var flags = view.getUint32(offs + 0x3C, true);
        model.billboard = !!(flags & 0x01);
        // A "batch" is a combination of a material and a poly.
        var batchCount = view.getUint32(offs + 0x30, true);
        var batchMaterialOffs = view.getUint32(offs + 0x34, true);
        var batchPolyOffs = view.getUint32(offs + 0x38, true);
        model.batches = [];
        for (var i = 0; i < batchCount; i++) {
            var materialIdx = view.getUint8(batchMaterialOffs + i);
            var material = parseMaterial(bmd, buffer, materialIdx);
            var baseCtx = { color: material.diffuse, alpha: material.alpha };
            var polyIdx = view.getUint8(batchPolyOffs + i);
            var poly = parsePoly(bmd, buffer, polyIdx, baseCtx);
            model.batches.push({ material: material, poly: poly });
        }
        return model;
    }
    function parsePoly(bmd, buffer, idx, baseCtx) {
        var view = buffer.createDataView();
        var offs = view.getUint32((bmd.polyOffsBase + idx * 0x08) + 0x04, true);
        var gxCmdSize = view.getUint32(offs + 0x08, true);
        var gxCmdOffs = view.getUint32(offs + 0x0C, true);
        var gxCmdBuf = buffer.slice(gxCmdOffs, gxCmdOffs + gxCmdSize);
        var packets = NITRO_GX.readCmds(gxCmdBuf, baseCtx);
        return { packets: packets };
    }
    function parseMaterial(bmd, buffer, idx) {
        var view = buffer.createDataView();
        var offs = bmd.materialOffsBase + idx * 0x30;
        var material = new Material();
        material.name = util_23.readString(buffer, view.getUint32(offs + 0x00, true), 0xFF);
        material.texCoordMat = gl_matrix_10.mat2d.create();
        var textureIdx = view.getUint32(offs + 0x04, true);
        if (textureIdx !== 0xFFFFFFFF) {
            var paletteIdx = view.getUint32(offs + 0x08, true);
            var textureKey = new TextureKey(textureIdx, paletteIdx);
            material.texture = parseTexture(bmd, buffer, textureKey);
            material.texParams = material.texture.params | view.getUint32(offs + 0x20, true);
            if (material.texParams >> 30) {
                var scaleS = view.getInt32(offs + 0x0C, true) / 4096.0;
                var scaleT = view.getInt32(offs + 0x10, true) / 4096.0;
                var transS = view.getInt32(offs + 0x18, true) / 4096.0;
                var transT = view.getInt32(offs + 0x1C, true) / 4096.0;
                gl_matrix_10.mat2d.translate(material.texCoordMat, material.texCoordMat, [transS, transT, 0.0]);
                gl_matrix_10.mat2d.scale(material.texCoordMat, material.texCoordMat, [scaleS, scaleT, 1.0]);
            }
            var texScale = [1 / material.texture.width, 1 / material.texture.height, 1];
            gl_matrix_10.mat2d.scale(material.texCoordMat, material.texCoordMat, texScale);
        }
        else {
            material.texture = null;
            material.texParams = 0;
        }
        var polyAttribs = view.getUint32(offs + 0x24, true);
        var alpha = (polyAttribs >> 16) & 0x1F;
        alpha = (alpha << (8 - 5)) | (alpha >>> (10 - 8));
        var renderWhichFaces = (polyAttribs >> 6) & 0x03;
        material.renderWhichFaces = renderWhichFaces;
        // NITRO's Rendering Engine uses two passes. Opaque, then Transparent.
        // A transparent polygon is one that has an alpha of < 0xFF, or uses
        // A5I3 / A3I5 textures.
        material.isTranslucent = (alpha < 0xFF) || (material.texture && material.texture.isTranslucent);
        // Do transparent polys write to the depth buffer?
        var xl = (polyAttribs >>> 11) & 0x01;
        if (xl)
            material.depthWrite = true;
        else
            material.depthWrite = !material.isTranslucent;
        var difAmb = view.getUint32(offs + 0x28, true);
        if (difAmb & 0x8000)
            material.diffuse = NITRO_GX.bgr5(difAmb);
        else
            material.diffuse = { r: 0xFF, g: 0xFF, b: 0xFF };
        material.alpha = alpha;
        return material;
    }
    function parseTexture(bmd, buffer, key) {
        if (bmd.textureCache.has(key.toString()))
            return bmd.textureCache.get(key.toString());
        var view = buffer.createDataView();
        var texOffs = bmd.textureOffsBase + key.texIdx * 0x14;
        var texture = new Texture();
        texture.id = key.texIdx;
        texture.name = util_23.readString(buffer, view.getUint32(texOffs + 0x00, true), 0xFF);
        var texDataOffs = view.getUint32(texOffs + 0x04, true);
        var texDataSize = view.getUint32(texOffs + 0x08, true);
        var texData = buffer.slice(texDataOffs);
        texture.params = view.getUint32(texOffs + 0x10, true);
        texture.format = (texture.params >> 26) & 0x07;
        texture.width = 8 << ((texture.params >> 20) & 0x07);
        texture.height = 8 << ((texture.params >> 23) & 0x07);
        var color0 = !!((texture.params >> 29) & 0x01);
        var palData = null;
        if (key.palIdx !== 0xFFFFFFFF) {
            var palOffs = bmd.paletteOffsBase + key.palIdx * 0x10;
            texture.paletteName = util_23.readString(buffer, view.getUint32(palOffs + 0x00, true), 0xFF);
            var palDataOffs = view.getUint32(palOffs + 0x04, true);
            var palDataSize = view.getUint32(palOffs + 0x08, true);
            palData = buffer.slice(palDataOffs, palDataOffs + palDataSize);
        }
        texture.pixels = NITRO_Tex.readTexture(texture.format, texture.width, texture.height, texData, palData, color0);
        texture.isTranslucent = (texture.format === NITRO_Tex.Format.Tex_A5I3 ||
            texture.format === NITRO_Tex.Format.Tex_A3I5);
        bmd.textures.push(texture);
        bmd.textureCache.set(key.toString(), texture);
        return texture;
    }
    function parse(buffer) {
        var view = buffer.createDataView();
        var bmd = new BMD();
        bmd.scaleFactor = (1 << view.getUint32(0x00, true));
        bmd.modelCount = view.getUint32(0x04, true);
        bmd.modelOffsBase = view.getUint32(0x08, true);
        bmd.polyCount = view.getUint32(0x0C, true);
        bmd.polyOffsBase = view.getUint32(0x10, true);
        bmd.textureCount = view.getUint32(0x14, true);
        bmd.textureOffsBase = view.getUint32(0x18, true);
        bmd.paletteCount = view.getUint32(0x1C, true);
        bmd.paletteOffsBase = view.getUint32(0x20, true);
        bmd.materialCount = view.getUint32(0x24, true);
        bmd.materialOffsBase = view.getUint32(0x28, true);
        bmd.textureCache = new Map();
        bmd.textures = [];
        bmd.models = [];
        for (var i = 0; i < bmd.modelCount; i++)
            bmd.models.push(parseModel(bmd, buffer, i));
        return bmd;
    }
    exports_42("parse", parse);
    var gl_matrix_10, NITRO_GX, NITRO_Tex, util_23, Material, Model, TextureKey, Texture, BMD;
    return {
        setters: [
            function (gl_matrix_10_1) {
                gl_matrix_10 = gl_matrix_10_1;
            },
            function (NITRO_GX_1) {
                NITRO_GX = NITRO_GX_1;
            },
            function (NITRO_Tex_1) {
                NITRO_Tex = NITRO_Tex_1;
            },
            function (util_23_1) {
                util_23 = util_23_1;
            }
        ],
        execute: function () {
            Material = /** @class */ (function () {
                function Material() {
                }
                return Material;
            }());
            exports_42("Material", Material);
            Model = /** @class */ (function () {
                function Model() {
                }
                return Model;
            }());
            exports_42("Model", Model);
            TextureKey = /** @class */ (function () {
                function TextureKey(texIdx, palIdx) {
                    this.texIdx = texIdx;
                    this.palIdx = palIdx;
                }
                TextureKey.prototype.toString = function () {
                    return "TextureKey " + this.texIdx + " " + this.palIdx;
                };
                return TextureKey;
            }());
            Texture = /** @class */ (function () {
                function Texture() {
                }
                return Texture;
            }());
            exports_42("Texture", Texture);
            BMD = /** @class */ (function () {
                function BMD() {
                }
                return BMD;
            }());
            exports_42("BMD", BMD);
        }
    };
});
System.register("sm64ds/render", ["gl-matrix", "byml", "sm64ds/lz77", "sm64ds/nitro_bmd", "render", "Program", "RenderArena", "util", "Camera"], function (exports_43, context_43) {
    "use strict";
    var __moduleName = context_43 && context_43.id;
    function textureToCanvas(bmdTex) {
        var canvas = document.createElement("canvas");
        canvas.width = bmdTex.width;
        canvas.height = bmdTex.height;
        canvas.title = bmdTex.name + " (" + bmdTex.format + ")";
        var ctx = canvas.getContext("2d");
        var imgData = ctx.createImageData(canvas.width, canvas.height);
        imgData.data.set(bmdTex.pixels);
        ctx.putImageData(imgData, 0, 0);
        var surfaces = [canvas];
        return { name: bmdTex.name, surfaces: surfaces };
    }
    function collectTextures(scenes) {
        var textures = [];
        try {
            for (var scenes_4 = __values(scenes), scenes_4_1 = scenes_4.next(); !scenes_4_1.done; scenes_4_1 = scenes_4.next()) {
                var scene = scenes_4_1.value;
                if (scene)
                    textures.push.apply(textures, scene.textures);
            }
        }
        catch (e_38_1) { e_38 = { error: e_38_1 }; }
        finally {
            try {
                if (scenes_4_1 && !scenes_4_1.done && (_a = scenes_4.return)) _a.call(scenes_4);
            }
            finally { if (e_38) throw e_38.error; }
        }
        return textures;
        var e_38, _a;
    }
    var gl_matrix_11, BYML, LZ77, NITRO_BMD, render_14, Program_6, RenderArena_1, util_24, Camera_5, NITRO_Program, VERTEX_SIZE, VERTEX_BYTES, YSpinAnimation, scratchModelMatrix, scratchViewMatrix, BMDRenderer, SM64DSRenderer, SceneDesc;
    return {
        setters: [
            function (gl_matrix_11_1) {
                gl_matrix_11 = gl_matrix_11_1;
            },
            function (BYML_1) {
                BYML = BYML_1;
            },
            function (LZ77_1) {
                LZ77 = LZ77_1;
            },
            function (NITRO_BMD_1) {
                NITRO_BMD = NITRO_BMD_1;
            },
            function (render_14_1) {
                render_14 = render_14_1;
            },
            function (Program_6_1) {
                Program_6 = Program_6_1;
            },
            function (RenderArena_1_1) {
                RenderArena_1 = RenderArena_1_1;
            },
            function (util_24_1) {
                util_24 = util_24_1;
            },
            function (Camera_5_1) {
                Camera_5 = Camera_5_1;
            }
        ],
        execute: function () {
            NITRO_Program = /** @class */ (function (_super) {
                __extends(NITRO_Program, _super);
                function NITRO_Program() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.vert = "\nprecision mediump float;\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nuniform mat3 u_texCoordMat;\nlayout(location = " + NITRO_Program.a_position + ") in vec3 a_position;\nlayout(location = " + NITRO_Program.a_uv + ") in vec2 a_uv;\nlayout(location = " + NITRO_Program.a_color + ") in vec4 a_color;\nout vec4 v_color;\nout vec2 v_uv;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_position, 1.0);\n    v_color = a_color;\n    v_uv = (u_texCoordMat * vec3(a_uv, 1.0)).st;\n}\n";
                    _this.frag = "\nprecision mediump float;\nin vec2 v_uv;\nin vec4 v_color;\nuniform sampler2D u_texture;\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_uv);\n    gl_FragColor *= v_color;\n    if (gl_FragColor.a == 0.0)\n        discard;\n}\n";
                    return _this;
                }
                NITRO_Program.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.texCoordMatLocation = gl.getUniformLocation(prog, "u_texCoordMat");
                };
                NITRO_Program.a_position = 0;
                NITRO_Program.a_uv = 1;
                NITRO_Program.a_color = 2;
                return NITRO_Program;
            }(Program_6.default));
            // 3 pos + 4 color + 2 uv
            VERTEX_SIZE = 9;
            VERTEX_BYTES = VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT;
            YSpinAnimation = /** @class */ (function () {
                function YSpinAnimation(speed, phase) {
                    this.speed = speed;
                    this.phase = phase;
                }
                YSpinAnimation.prototype.updateModelMatrix = function (state, modelMatrix) {
                    var theta = this.phase + (state.time / 30 * this.speed);
                    gl_matrix_11.mat4.rotateY(modelMatrix, modelMatrix, theta);
                };
                return YSpinAnimation;
            }());
            scratchModelMatrix = gl_matrix_11.mat4.create();
            scratchViewMatrix = gl_matrix_11.mat4.create();
            BMDRenderer = /** @class */ (function () {
                function BMDRenderer(gl, bmd, crg1Level) {
                    this.animation = null;
                    this.opaqueCommands = [];
                    this.transparentCommands = [];
                    this.program = new NITRO_Program();
                    this.bmd = bmd;
                    this.crg1Level = crg1Level;
                    this.isSkybox = false;
                    this.arena = new RenderArena_1.default();
                    this.textures = bmd.textures.map(function (texture) {
                        return textureToCanvas(texture);
                    });
                    this.translateBMD(gl, this.bmd);
                    var scaleFactor = this.bmd.scaleFactor;
                    this.localMatrix = gl_matrix_11.mat4.create();
                    gl_matrix_11.mat4.fromScaling(this.localMatrix, [scaleFactor, scaleFactor, scaleFactor]);
                }
                BMDRenderer.prototype.translatePacket = function (gl, packet) {
                    var vertBuffer = this.arena.createBuffer(gl);
                    gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, packet.vertData, gl.STATIC_DRAW);
                    var idxBuffer = this.arena.createBuffer(gl);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, packet.idxData, gl.STATIC_DRAW);
                    var vao = this.arena.createVertexArray(gl);
                    gl.bindVertexArray(vao);
                    gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
                    gl.vertexAttribPointer(NITRO_Program.a_position, 3, gl.FLOAT, false, VERTEX_BYTES, 0);
                    gl.vertexAttribPointer(NITRO_Program.a_color, 4, gl.FLOAT, false, VERTEX_BYTES, 3 * Float32Array.BYTES_PER_ELEMENT);
                    gl.vertexAttribPointer(NITRO_Program.a_uv, 2, gl.FLOAT, false, VERTEX_BYTES, 7 * Float32Array.BYTES_PER_ELEMENT);
                    gl.enableVertexAttribArray(NITRO_Program.a_position);
                    gl.enableVertexAttribArray(NITRO_Program.a_color);
                    gl.enableVertexAttribArray(NITRO_Program.a_uv);
                    gl.bindVertexArray(null);
                    return function (renderState) {
                        gl.bindVertexArray(vao);
                        gl.drawElements(gl.TRIANGLES, packet.idxData.length, gl.UNSIGNED_SHORT, 0);
                        gl.bindVertexArray(null);
                    };
                };
                BMDRenderer.prototype.translatePoly = function (gl, poly) {
                    var _this = this;
                    var funcs = poly.packets.map(function (packet) { return _this.translatePacket(gl, packet); });
                    return function (state) {
                        funcs.forEach(function (f) { f(state); });
                    };
                };
                BMDRenderer.prototype.translateCullMode = function (renderWhichFaces) {
                    switch (renderWhichFaces) {
                        case 0x00: // Render Nothing
                            return render_14.CullMode.FRONT_AND_BACK;
                        case 0x01: // Render Back
                            return render_14.CullMode.FRONT;
                        case 0x02: // Render Front
                            return render_14.CullMode.BACK;
                        case 0x03: // Render Front and Back
                            return render_14.CullMode.NONE;
                        default:
                            throw new Error("Unknown renderWhichFaces");
                    }
                };
                BMDRenderer.prototype.translateMaterial = function (gl, material) {
                    var texture = material.texture;
                    var texId;
                    function wrapMode(repeat, flip) {
                        if (repeat)
                            return flip ? gl.MIRRORED_REPEAT : gl.REPEAT;
                        else
                            return gl.CLAMP_TO_EDGE;
                    }
                    if (texture !== null) {
                        texId = this.arena.createTexture(gl);
                        gl.bindTexture(gl.TEXTURE_2D, texId);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        var repeatS = !!((material.texParams >> 16) & 0x01);
                        var repeatT = !!((material.texParams >> 17) & 0x01);
                        var flipS = !!((material.texParams >> 18) & 0x01);
                        var flipT = !!((material.texParams >> 19) & 0x01);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapMode(repeatS, flipS));
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapMode(repeatT, flipT));
                        gl.bindTexture(gl.TEXTURE_2D, texId);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texture.width, texture.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, texture.pixels);
                    }
                    // Find any possible material animations.
                    var crg1mat = this.crg1Level ? this.crg1Level.TextureAnimations.find(function (c) { return c.MaterialName === material.name; }) : undefined;
                    var texCoordMat = gl_matrix_11.mat3.create();
                    gl_matrix_11.mat3.fromMat2d(texCoordMat, material.texCoordMat);
                    var renderFlags = new render_14.RenderFlags();
                    renderFlags.blendMode = render_14.BlendMode.ADD;
                    renderFlags.depthTest = true;
                    renderFlags.depthWrite = material.depthWrite;
                    renderFlags.cullMode = this.translateCullMode(material.renderWhichFaces);
                    var texAnimMat = gl_matrix_11.mat3.create();
                    return function (state) {
                        function selectArray(arr, time) {
                            return arr[(time | 0) % arr.length];
                        }
                        if (crg1mat !== undefined) {
                            var time = state.time / 30;
                            var scale = selectArray(crg1mat.Scale, time);
                            var rotation = selectArray(crg1mat.Rotation, time);
                            var x = selectArray(crg1mat.X, time);
                            var y = selectArray(crg1mat.Y, time);
                            gl_matrix_11.mat3.identity(texAnimMat);
                            gl_matrix_11.mat3.scale(texAnimMat, texAnimMat, [scale, scale]);
                            gl_matrix_11.mat3.rotate(texAnimMat, texAnimMat, rotation / 180 * Math.PI);
                            gl_matrix_11.mat3.translate(texAnimMat, texAnimMat, [-x, y]);
                            gl_matrix_11.mat3.fromMat2d(texCoordMat, material.texCoordMat);
                            gl_matrix_11.mat3.multiply(texCoordMat, texAnimMat, texCoordMat);
                        }
                        if (texture !== null) {
                            var prog = state.currentProgram;
                            gl.uniformMatrix3fv(prog.texCoordMatLocation, false, texCoordMat);
                            gl.bindTexture(gl.TEXTURE_2D, texId);
                        }
                        state.useFlags(renderFlags);
                    };
                };
                BMDRenderer.prototype.bindModelView = function (state, isBillboard) {
                    var gl = state.gl;
                    var prog = this.program;
                    // Build model matrix
                    var modelMatrix = scratchModelMatrix;
                    if (isBillboard) {
                        // Apply billboard model if necessary.
                        Camera_5.computeModelMatrixYBillboard(modelMatrix, state.camera);
                        gl_matrix_11.mat4.mul(modelMatrix, this.localMatrix, modelMatrix);
                    }
                    else {
                        gl_matrix_11.mat4.copy(modelMatrix, this.localMatrix);
                    }
                    if (this.animation !== null)
                        this.animation.updateModelMatrix(state, modelMatrix);
                    // Build view matrix
                    var viewMatrix = scratchViewMatrix;
                    if (this.isSkybox) {
                        Camera_5.computeViewMatrixSkybox(viewMatrix, state.camera);
                    }
                    else {
                        Camera_5.computeViewMatrix(viewMatrix, state.camera);
                    }
                    gl_matrix_11.mat4.mul(viewMatrix, viewMatrix, modelMatrix);
                    gl.uniformMatrix4fv(prog.projectionLocation, false, state.camera.projectionMatrix);
                    gl.uniformMatrix4fv(prog.modelViewLocation, false, viewMatrix);
                };
                BMDRenderer.prototype.translateBatch = function (gl, model, batch) {
                    var _this = this;
                    var applyMaterial = this.translateMaterial(gl, batch.material);
                    var renderPoly = this.translatePoly(gl, batch.poly);
                    var func = function (state) {
                        state.useProgram(_this.program);
                        applyMaterial(state);
                        _this.bindModelView(state, model.billboard);
                        renderPoly(state);
                    };
                    if (batch.material.isTranslucent)
                        this.transparentCommands.push(func);
                    else
                        this.opaqueCommands.push(func);
                };
                BMDRenderer.prototype.translateBMD = function (gl, bmd) {
                    try {
                        for (var _a = __values(bmd.models), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var model = _b.value;
                            try {
                                for (var _c = __values(model.batches), _d = _c.next(); !_d.done; _d = _c.next()) {
                                    var batch = _d.value;
                                    this.translateBatch(gl, model, batch);
                                }
                            }
                            catch (e_39_1) { e_39 = { error: e_39_1 }; }
                            finally {
                                try {
                                    if (_d && !_d.done && (_e = _c.return)) _e.call(_c);
                                }
                                finally { if (e_39) throw e_39.error; }
                            }
                        }
                    }
                    catch (e_40_1) { e_40 = { error: e_40_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_f = _a.return)) _f.call(_a);
                        }
                        finally { if (e_40) throw e_40.error; }
                    }
                    var e_40, _f, e_39, _e;
                };
                BMDRenderer.prototype.destroy = function (gl) {
                    this.arena.destroy(gl);
                };
                return BMDRenderer;
            }());
            SM64DSRenderer = /** @class */ (function () {
                function SM64DSRenderer(mainBMD, skyboxBMD, extraBMDs) {
                    this.mainBMD = mainBMD;
                    this.skyboxBMD = skyboxBMD;
                    this.extraBMDs = extraBMDs;
                    this.textures = collectTextures(__spread([this.mainBMD, this.skyboxBMD], this.extraBMDs));
                }
                SM64DSRenderer.prototype.runCommands = function (state, funcs) {
                    funcs.forEach(function (func) {
                        func(state);
                    });
                };
                SM64DSRenderer.prototype.render = function (renderState) {
                    var _this = this;
                    var gl = renderState.gl;
                    if (this.skyboxBMD) {
                        this.runCommands(renderState, this.skyboxBMD.opaqueCommands);
                        renderState.useFlags(render_14.depthClearFlags);
                        gl.clear(gl.DEPTH_BUFFER_BIT);
                    }
                    else {
                        // No skybox? Black.
                        gl.clearColor(0, 0, 0, 1.0);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                    }
                    // Opaque.
                    this.runCommands(renderState, this.mainBMD.opaqueCommands);
                    this.extraBMDs.forEach(function (bmd) {
                        _this.runCommands(renderState, bmd.opaqueCommands);
                    });
                    // Transparent.
                    this.runCommands(renderState, this.mainBMD.transparentCommands);
                    this.extraBMDs.forEach(function (bmd) {
                        _this.runCommands(renderState, bmd.transparentCommands);
                    });
                };
                SM64DSRenderer.prototype.destroy = function (gl) {
                    this.mainBMD.destroy(gl);
                    if (this.skyboxBMD)
                        this.skyboxBMD.destroy(gl);
                    this.extraBMDs.forEach(function (renderer) { return renderer.destroy(gl); });
                };
                return SM64DSRenderer;
            }());
            SceneDesc = /** @class */ (function () {
                function SceneDesc(name, levelId) {
                    this.name = name;
                    this.levelId = levelId;
                    this.id = '' + this.levelId;
                }
                SceneDesc.prototype.createScene = function (gl) {
                    var _this = this;
                    return util_24.fetch('data/sm64ds/sm64ds.crg1').then(function (result) {
                        var crg1 = BYML.parse(result, 1 /* CRG1 */);
                        return _this._createSceneFromCRG1(gl, crg1);
                    });
                };
                SceneDesc.prototype._createBMDRenderer = function (gl, filename, scale, level, isSkybox) {
                    return util_24.fetch("data/sm64ds/" + filename).then(function (result) {
                        result = LZ77.maybeDecompress(result);
                        var bmd = NITRO_BMD.parse(result);
                        var renderer = new BMDRenderer(gl, bmd, level);
                        gl_matrix_11.mat4.scale(renderer.localMatrix, renderer.localMatrix, [scale, scale, scale]);
                        renderer.isSkybox = isSkybox;
                        return renderer;
                    });
                };
                SceneDesc.prototype._createBMDObjRenderer = function (gl, filename, translation, rotationY, scale, spinSpeed) {
                    if (scale === void 0) { scale = 1; }
                    if (spinSpeed === void 0) { spinSpeed = 0; }
                    return util_24.fetch("data/sm64ds/" + filename).then(function (result) {
                        result = LZ77.maybeDecompress(result);
                        var bmd = NITRO_BMD.parse(result);
                        var renderer = new BMDRenderer(gl, bmd, null);
                        gl_matrix_11.vec3.scale(translation, translation, 16 / bmd.scaleFactor);
                        gl_matrix_11.mat4.translate(renderer.localMatrix, renderer.localMatrix, translation);
                        gl_matrix_11.mat4.rotateY(renderer.localMatrix, renderer.localMatrix, rotationY);
                        gl_matrix_11.mat4.scale(renderer.localMatrix, renderer.localMatrix, [scale, scale, scale]);
                        if (spinSpeed > 0) {
                            var spinPhase = Math.random() * Math.PI * 2;
                            renderer.animation = new YSpinAnimation(spinSpeed, spinPhase);
                        }
                        return renderer;
                    });
                };
                SceneDesc.prototype._createBMDRendererForObject = function (gl, object) {
                    var translation = gl_matrix_11.vec3.fromValues(object.Position.X, object.Position.Y, object.Position.Z);
                    // WTF is with the Tau? And the object scales?
                    gl_matrix_11.vec3.scale(translation, translation, Math.PI * 2);
                    var rotationY = object.Rotation.Y / 180 * Math.PI;
                    switch (object.ObjectId) {
                        case 7: // Up/down lift thingy
                        case 9: // Pathlift?
                        case 10: // Chain Chomp (copy/pasted)
                        case 13: // LONELY ROLLING BALL
                        case 15: // Goomba
                        case 19: // Bob-omb
                        case 20: // Friendly Bob-omb
                        case 21: // Koopa
                            return null;
                        case 23: // Brick Block
                            return this._createBMDObjRenderer(gl, "normal_obj/obj_block/broken_block_l.bmd", translation, rotationY, 0.8);
                        case 24: // Brick Block Larger
                            return this._createBMDObjRenderer(gl, "normal_obj/obj_block/broken_block_l.bmd", translation, rotationY, 1.2);
                        case 26: // Powerup inside block?
                        case 29: // Cannon hatch
                            return null;
                        case 30: // Item Block
                            return this._createBMDObjRenderer(gl, "normal_obj/obj_hatena_box/hatena_box.bmd", translation, rotationY, 0.8);
                        case 36: // Pole
                            return this._createBMDObjRenderer(gl, "normal_obj/obj_pile/pile.bmd", translation, rotationY, 0.8);
                        case 37: // Coin
                            return this._createBMDObjRenderer(gl, "normal_obj/coin/coin_poly32.bmd", translation, rotationY, 0.8, 0.1);
                        case 38: // Red Coin
                            return this._createBMDObjRenderer(gl, "normal_obj/coin/coin_red_poly32.bmd", translation, rotationY, 0.8, 0.1);
                        case 39: // Blue Coin
                            return this._createBMDObjRenderer(gl, "normal_obj/coin/coin_blue_poly32.bmd", translation, rotationY, 0.8, 0.1);
                        case 41: { // Tree
                            var treeType = (object.Parameters[0] >>> 4) & 0x07;
                            var treeFilenames = ['bomb', 'toge', 'yuki', 'yashi', 'castle', 'castle', 'castle', 'castle'];
                            var filename = "normal_obj/tree/" + treeFilenames[treeType] + "_tree.bmd";
                            return this._createBMDObjRenderer(gl, filename, translation, rotationY);
                        }
                        case 42: { // Castle Painting
                            var painting = (object.Parameters[0] >>> 8) & 0x1F;
                            var filenames = [
                                'for_bh', 'for_bk', 'for_ki', 'for_sm', 'for_cv_ex5', 'for_fl', 'for_dl', 'for_wl', 'for_sl', 'for_wc',
                                'for_hm', 'for_hs', 'for_td_tt', 'for_ct', 'for_ex_mario', 'for_ex_luigi', 'for_ex_wario', 'for_vs_cross', 'for_vs_island',
                            ];
                            var filename = "picture/" + filenames[painting] + ".bmd";
                            var scale = ((object.Parameters[0] & 0xF) + 1);
                            translation[1] += scale * 0.3;
                            return this._createBMDObjRenderer(gl, filename, translation, rotationY, scale);
                        }
                        case 43: // Switch
                        case 44: // Switch-powered Star
                        case 45: // Switch-powered Trapdoor
                        case 48: // Chain Chomp Unchained
                        case 49: // 1-up
                        case 50: // Cannon
                        case 51: // Chain-chomp fence (BoB)
                        case 52: // Water bombs (BoB)
                        case 53: // Birds
                        case 54: // Fish
                        case 55: // Butterflies
                        case 56: // Super Bob Fuckan Omb Bob-Omb In BoB (the summit)
                        case 59: // Pirahna Plant
                        case 60: // Star Camera Path
                        case 61: // Star Target
                            return null;
                        case 62: // Silver Star
                            return this._createBMDObjRenderer(gl, "normal_obj/star/obj_star_silver.bmd", translation, rotationY, 0.8, 0.08);
                        case 63: // Star
                            return this._createBMDObjRenderer(gl, "normal_obj/star/obj_star.bmd", translation, rotationY, 0.8, 0.08);
                        case 64: // Whomp
                        case 65: // Big Whomp
                        case 66: // Thwomp
                        case 67: // Boo
                        case 74: // Minigame Cabinet Trigger (Invisible)
                            return null;
                        case 75: // Wall sign
                            return this._createBMDObjRenderer(gl, "normal_obj/obj_kanban/obj_kanban.bmd", translation, rotationY, 0.8);
                        case 76: // Signpost
                            return this._createBMDObjRenderer(gl, "normal_obj/obj_tatefuda/obj_tatefuda.bmd", translation, rotationY, 0.8);
                        case 79: // Heart
                        case 80: // Toad
                        case 167: // Peach's Castle Tippy TTC Hour Hand
                        case 168: // Peach's Castle Tippy TTC Minute Hand
                        case 169: // Peach's Castle Tippy TTC Pendulum
                            return null;
                        case 187: // Left Arrow Sign
                            return this._createBMDObjRenderer(gl, "normal_obj/obj_yajirusi_l/yajirusi_l.bmd", translation, rotationY, 0.8);
                        case 188: // Right Arrow Sign
                            return this._createBMDObjRenderer(gl, "normal_obj/obj_yajirusi_r/yajirusi_r.bmd", translation, rotationY, 0.8);
                        case 196: // WF
                        case 197: // WF
                        case 198: // WF
                        case 199: // WF
                        case 200: // WF
                        case 201: // WF
                        case 202: // WF
                        case 203: // WF Tower
                            return null;
                        case 204: // WF Spinning Island
                            return this._createBMDObjRenderer(gl, "special_obj/bk_ukisima/bk_ukisima.bmd", translation, rotationY, 1, 0.1);
                        case 205: // WF
                        case 206: // WF
                        case 207: // WF
                        case 208: // WF
                        case 209: // WF
                        case 228: // Switch Pillar
                        case 237: // MIPS
                        case 239: // That Stupid Owl
                        case 243: // Invisible pole hitbox
                        case 244: // Lakitu
                        case 254: // Mario's Iconic Cap
                        case 264: // Red Flame
                        case 265: // Blue Flame
                        case 269: // 1-Up Mushroom Inside Block
                        case 270: // Some brick thing?
                        case 273: // Peach's Castle First Floor Trapdoor
                        case 274: // Peach's Castle First Floor Light Beam
                        case 275: // Peach's Castle First Floor Peach/Bowser Fade Painting
                        case 281: // Koopa the Quick
                        case 282: // Koopa the Quick Finish Flag
                            return null;
                        case 284: // Wario Block
                            return this._createBMDObjRenderer(gl, "normal_obj/obj_block/broken_block_ll.bmd", translation, rotationY);
                        case 293: // Water
                            return this._createBMDObjRenderer(gl, "special_obj/mc_water/mc_water.bmd", translation, rotationY, 0.8);
                        case 295: // Metal net
                            return this._createBMDObjRenderer(gl, "special_obj/mc_metalnet/mc_metalnet.bmd", translation, rotationY, 0.8);
                        case 298: // Flag
                            return this._createBMDObjRenderer(gl, "special_obj/mc_flag/mc_flag.bmd", translation, rotationY, 0.8);
                        case 303: // Castle Basement Water
                        case 304: // Secret number thingy
                            return null;
                        case 305: // Blue Coin Switch
                            return this._createBMDObjRenderer(gl, "normal_obj/b_coin_switch/b_coin_switch.bmd", translation, rotationY, 0.8);
                        case 314: // Hidden Pirahna Plant
                        case 315: // Enemy spawner trigger
                        case 316: // Enemy spawner
                        case 323: // Ambient sound effects
                        case 324: // Music
                        case 511: // Appears to be a bug in the level layout
                            return null;
                        default:
                            console.warn("Unknown object type " + object.ObjectId);
                            return null;
                    }
                };
                SceneDesc.prototype._createSceneFromCRG1 = function (gl, crg1) {
                    var level = crg1.Levels[this.levelId];
                    var renderers = [this._createBMDRenderer(gl, level.MapBmdFile, 100, level, false)];
                    if (level.VrboxBmdFile)
                        renderers.push(this._createBMDRenderer(gl, level.VrboxBmdFile, 0.8, level, true));
                    else
                        renderers.push(Promise.resolve(null));
                    try {
                        for (var _a = __values(level.Objects), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var object = _b.value;
                            var objRenderer = this._createBMDRendererForObject(gl, object);
                            if (objRenderer)
                                renderers.push(objRenderer);
                        }
                    }
                    catch (e_41_1) { e_41 = { error: e_41_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_41) throw e_41.error; }
                    }
                    return Promise.all(renderers).then(function (_a) {
                        var _b = __read(_a), mainBMD = _b[0], skyboxBMD = _b[1], extraBMDs = _b.slice(2);
                        return new SM64DSRenderer(mainBMD, skyboxBMD, extraBMDs);
                    });
                    var e_41, _c;
                };
                return SceneDesc;
            }());
            exports_43("SceneDesc", SceneDesc);
        }
    };
});
System.register("sm64ds/scenes", ["sm64ds/render"], function (exports_44, context_44) {
    "use strict";
    var __moduleName = context_44 && context_44.id;
    var render_15, id, name, sceneDescs, sceneGroup;
    return {
        setters: [
            function (render_15_1) {
                render_15 = render_15_1;
            }
        ],
        execute: function () {
            id = "sm64ds";
            name = "Super Mario 64 DS";
            sceneDescs = [
                { 'id': 1, 'name': "Princess Peach's Castle - Gardens" },
                { 'id': 2, 'name': "Princess Peach's Castle - 1st Floor" },
                { 'id': 5, 'name': "Princess Peach's Castle - 2nd Floor" },
                { 'id': 4, 'name': "Princess Peach's Castle - Basement" },
                { 'id': 3, 'name': "Princess Peach's Castle - Courtyard" },
                { 'id': 50, 'name': "Princess Peach's Castle - Playroom" },
                { 'id': 6, 'name': 'Bob-omb Battlefield' },
                { 'id': 7, 'name': "Whomp's Fortress" },
                { 'id': 8, 'name': 'Jolly Roger Bay' },
                { 'id': 9, 'name': 'Jolly Roger Bay - Inside the Ship' },
                { 'id': 10, 'name': 'Cool, Cool Mountain' },
                { 'id': 11, 'name': 'Cool, Cool Mountain - Inside the Slide' },
                { 'id': 12, 'name': "Big Boo's Haunt" },
                { 'id': 13, 'name': 'Hazy Maze Cave' },
                { 'id': 14, 'name': 'Lethal Lava Land' },
                { 'id': 15, 'name': 'Lethal Lava Land - Inside the Volcano' },
                { 'id': 16, 'name': 'Shifting Sand Land' },
                { 'id': 17, 'name': 'Shifting Sand Land - Inside the Pyramid' },
                { 'id': 18, 'name': 'Dire, Dire Docks' },
                { 'id': 19, 'name': "Snowman's Land" },
                { 'id': 20, 'name': "Snowman's Land - Inside the Igloo" },
                { 'id': 21, 'name': 'Wet-Dry World' },
                { 'id': 22, 'name': 'Tall Tall Mountain' },
                { 'id': 23, 'name': 'Tall Tall Mountain - Inside the Slide' },
                { 'id': 25, 'name': 'Tiny-Huge Island - Tiny' },
                { 'id': 24, 'name': 'Tiny-Huge Island - Huge' },
                { 'id': 26, 'name': "Tiny-Huge Island - Inside Wiggler's Cavern" },
                { 'id': 27, 'name': 'Tick Tock Clock' },
                { 'id': 28, 'name': 'Rainbow Ride' },
                { 'id': 35, 'name': 'Bowser in the Dark World' },
                { 'id': 36, 'name': 'Bowser in the Dark World - Battle' },
                { 'id': 37, 'name': 'Bowser in the Fire Sea' },
                { 'id': 38, 'name': 'Bowser in the Fire Sea - Battle' },
                { 'id': 39, 'name': 'Bowser in the Sky' },
                { 'id': 40, 'name': 'Bowser in the Sky - Battle' },
                { 'id': 29, 'name': 'The Princess\'s Secret Slide' },
                { 'id': 30, 'name': 'The Secret Aquarium' },
                { 'id': 34, 'name': 'Wing Mario over the Rainbow' },
                { 'id': 31, 'name': 'Tower of the Wing Cap' },
                { 'id': 32, 'name': 'Vanish Cap Under the Moat' },
                { 'id': 33, 'name': 'Cavern of the Metal Cap' },
                { 'id': 46, 'name': 'Big Boo Battle' },
                { 'id': 47, 'name': 'Big Boo Battle - Battle' },
                { 'id': 44, 'name': 'Goomboss Battle' },
                { 'id': 45, 'name': 'Goomboss Battle - Battle' },
                { 'id': 48, 'name': 'Chief Chilly Challenge' },
                { 'id': 49, 'name': 'Chief Chilly Challenge - Battle' },
                { 'id': 42, 'name': 'VS Map - The Secret of Battle Fort' },
                { 'id': 43, 'name': 'VS Map - Sunshine Isles' },
                { 'id': 51, 'name': 'VS Map - Castle Gardens' },
                { 'id': 0, 'name': 'Test Map A' },
                { 'id': 41, 'name': 'Test Map B' },
            ].map(function (entry) {
                return new render_15.SceneDesc(entry.name, entry.id);
            });
            exports_44("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
System.register("mdl0/mdl0", ["util"], function (exports_45, context_45) {
    "use strict";
    var __moduleName = context_45 && context_45.id;
    function parse(buffer) {
        ;
        var view = buffer.createDataView();
        util_25.assert(util_25.readString(buffer, 0, 4, false) === 'MDL\0');
        var flags = view.getUint8(0x04);
        var primType = view.getUint8(0x05);
        var vertCount = view.getUint16(0x06, true);
        var animCount = view.getUint16(0x08, true);
        var offs = 0x0A;
        if (flags & 2 /* HAS_UV */) {
            // XXX: How to parse UV?
            var start = offs;
            var end = start + vertCount * 8;
            offs = end;
        }
        var clrData;
        if (flags & 4 /* HAS_COLOR */) {
            clrData = buffer.createTypedArray(Uint8Array, offs, vertCount * 4);
            offs += clrData.byteLength;
        }
        else {
            clrData = new Uint8Array(vertCount * 4);
        }
        // Read in index buffer.
        var idxCount = view.getUint16(offs, true);
        offs += 0x02;
        var idxData;
        {
            var idxArr = buffer.createTypedArray(Uint16Array, offs, idxCount);
            if (primType === 3) {
                idxData = idxArr;
            }
            else if (primType === 4) {
                idxCount = (idxCount / 4 * 6);
                idxData = new Uint16Array(idxCount);
                for (var i = 0, j = 0; i < idxCount; i += 6) {
                    idxData[i + 0] = idxArr[j + 0];
                    idxData[i + 1] = idxArr[j + 1];
                    idxData[i + 2] = idxArr[j + 2];
                    idxData[i + 3] = idxArr[j + 2];
                    idxData[i + 4] = idxArr[j + 3];
                    idxData[i + 5] = idxArr[j + 0];
                    j += 4;
                }
            }
            offs += idxArr.byteLength;
        }
        var vtxData;
        var vertSize = 4 * (3 + ((flags & 1 /* HAS_NORMAL */) ? 3 : 0));
        var animSize = vertCount * vertSize;
        {
            vtxData = buffer.createTypedArray(Float32Array, offs, (animCount * animSize) / 4);
            offs += vtxData.byteLength;
        }
        util_25.assert(offs === buffer.byteLength);
        return { clrData: clrData, idxData: idxData, vtxData: vtxData, animCount: animCount, animSize: animSize, vertCount: vertCount, vertSize: vertSize };
    }
    exports_45("parse", parse);
    var util_25;
    return {
        setters: [
            function (util_25_1) {
                util_25 = util_25_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("mdl0/render", ["mdl0/mdl0", "render", "Program", "util", "Camera"], function (exports_46, context_46) {
    "use strict";
    var __moduleName = context_46 && context_46.id;
    var MDL0, render_16, Program_7, util_26, Camera_6, FancyGrid_Program, FancyGrid, MDL0_Program, Scene, SceneDesc;
    return {
        setters: [
            function (MDL0_1) {
                MDL0 = MDL0_1;
            },
            function (render_16_1) {
                render_16 = render_16_1;
            },
            function (Program_7_1) {
                Program_7 = Program_7_1;
            },
            function (util_26_1) {
                util_26 = util_26_1;
            },
            function (Camera_6_1) {
                Camera_6 = Camera_6_1;
            }
        ],
        execute: function () {
            FancyGrid_Program = /** @class */ (function (_super) {
                __extends(FancyGrid_Program, _super);
                function FancyGrid_Program() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.vert = "\nprecision mediump float;\n\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\n\nattribute vec3 a_position;\nvarying float v_eyeFade;\nvarying vec2 v_surfCoord;\n\nvoid main() {\n    v_surfCoord = a_position.xz;\n\n    float scale = 200.0;\n    gl_Position = u_projection * u_modelView * vec4(a_position * scale, 1.0);\n\n    vec3 V = (vec4(0.0, 0.0, 1.0, 0.0) * u_modelView).xyz;\n    vec3 N = vec3(0.0, 1.0, 0.0);\n    v_eyeFade = dot(V, N);\n}\n";
                    _this.frag = "\n#extension GL_EXT_frag_depth : enable\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\nvarying float v_eyeFade;\nvarying vec2 v_surfCoord;\n\nvoid main() {\n    float distFromCenter = distance(v_surfCoord, vec2(0.0));\n    vec2 uv = (v_surfCoord + 1.0) * 0.5;\n\n    vec4 color;\n    color.a = 1.0;\n\n    // Base Grid color.\n    color.rgb = mix(vec3(0.8, 0.0, 0.8), vec3(0.4, 0.2, 0.8), clamp(distFromCenter * 1.5, 0.0, 1.0));\n    color.a *= clamp(mix(2.0, 0.0, distFromCenter), 0.0, 1.0);\n\n    // Grid lines mask.\n    uv *= 80.0;\n    float sharpDx = clamp(1.0 / min(abs(dFdx(uv.x)), abs(dFdy(uv.y))), 2.0, 20.0);\n    float sharpMult = sharpDx * 10.0;\n    float sharpOffs = sharpDx * 4.40;\n    vec2 gridM = (abs(fract(uv) - 0.5)) * sharpMult - sharpOffs;\n    float gridMask = max(gridM.x, gridM.y);\n    color.a *= clamp(gridMask, 0.0, 1.0);\n\n    color.a += (1.0 - clamp(distFromCenter * 1.2, 0.0, 1.0)) * 0.5 * v_eyeFade;\n\n    // Eye fade.\n    color.a *= clamp(v_eyeFade, 0.3, 1.0);\n    gl_FragColor = color;\n\n    gl_FragDepth = gl_FragCoord.z + 1e-6;\n}\n";
                    return _this;
                }
                FancyGrid_Program.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.positionLocation = gl.getAttribLocation(prog, "a_position");
                };
                return FancyGrid_Program;
            }(Program_7.default));
            FancyGrid = /** @class */ (function () {
                function FancyGrid(gl) {
                    this.program = new FancyGrid_Program();
                    this._createBuffers(gl);
                    this.renderFlags = new render_16.RenderFlags();
                    this.renderFlags.blendMode = render_16.BlendMode.ADD;
                }
                FancyGrid.prototype.render = function (state) {
                    var gl = state.gl;
                    state.useProgram(this.program);
                    state.bindModelView();
                    state.useFlags(this.renderFlags);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.vtxBuffer);
                    gl.vertexAttribPointer(this.program.positionLocation, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(this.program.positionLocation);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    gl.disableVertexAttribArray(this.program.positionLocation);
                };
                FancyGrid.prototype._createBuffers = function (gl) {
                    this.vtxBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.vtxBuffer);
                    var vtx = new Float32Array(4 * 3);
                    vtx[0] = -1;
                    vtx[1] = 0;
                    vtx[2] = -1;
                    vtx[3] = 1;
                    vtx[4] = 0;
                    vtx[5] = -1;
                    vtx[6] = -1;
                    vtx[7] = 0;
                    vtx[8] = 1;
                    vtx[9] = 1;
                    vtx[10] = 0;
                    vtx[11] = 1;
                    gl.bufferData(gl.ARRAY_BUFFER, vtx, gl.STATIC_DRAW);
                };
                FancyGrid.prototype.destroy = function (gl) {
                    this.program.destroy(gl);
                    gl.deleteBuffer(this.vtxBuffer);
                };
                return FancyGrid;
            }());
            MDL0_Program = /** @class */ (function (_super) {
                __extends(MDL0_Program, _super);
                function MDL0_Program() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.vert = "\nprecision mediump float;\n\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\n\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n\nvoid main() {\n    v_color = a_color.bgra;\n    gl_Position = u_projection * u_modelView * vec4(a_position, 1.0);\n}\n";
                    _this.frag = "\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid main() {\n    gl_FragColor = v_color;\n}\n";
                    return _this;
                }
                MDL0_Program.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.positionLocation = gl.getAttribLocation(prog, "a_position");
                    this.colorLocation = gl.getAttribLocation(prog, "a_color");
                };
                return MDL0_Program;
            }(Program_7.default));
            Scene = /** @class */ (function () {
                function Scene(gl, mdl0) {
                    this.textures = [];
                    this.fancyGrid = new FancyGrid(gl);
                    this.program = new MDL0_Program();
                    this.mdl0 = mdl0;
                    this._createBuffers(gl);
                    this.renderFlags = new render_16.RenderFlags();
                    this.renderFlags.depthTest = true;
                }
                Scene.prototype.render = function (state) {
                    var gl = state.gl;
                    state.useProgram(this.program);
                    state.bindModelView();
                    state.useFlags(this.renderFlags);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.clrBuffer);
                    gl.vertexAttribPointer(this.program.colorLocation, 4, gl.UNSIGNED_BYTE, true, 0, 0);
                    gl.enableVertexAttribArray(this.program.colorLocation);
                    var frameNumber = ((state.time / 16) % this.mdl0.animCount) | 0;
                    var vtxOffset = frameNumber * this.mdl0.animSize;
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.vtxBuffer);
                    gl.vertexAttribPointer(this.program.positionLocation, 3, gl.FLOAT, false, this.mdl0.vertSize, vtxOffset);
                    gl.enableVertexAttribArray(this.program.positionLocation);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.idxBuffer);
                    gl.drawElements(gl.TRIANGLES, this.mdl0.idxData.length, gl.UNSIGNED_SHORT, 0);
                    gl.disableVertexAttribArray(this.program.colorLocation);
                    gl.disableVertexAttribArray(this.program.positionLocation);
                    this.fancyGrid.render(state);
                };
                Scene.prototype._createBuffers = function (gl) {
                    this.clrBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.clrBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, this.mdl0.clrData, gl.STATIC_DRAW);
                    this.idxBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.idxBuffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.mdl0.idxData, gl.STATIC_DRAW);
                    this.vtxBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.vtxBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, this.mdl0.vtxData, gl.STATIC_DRAW);
                };
                Scene.prototype.destroy = function (gl) {
                    gl.deleteBuffer(this.clrBuffer);
                    gl.deleteBuffer(this.vtxBuffer);
                    gl.deleteBuffer(this.idxBuffer);
                    this.program.destroy(gl);
                };
                return Scene;
            }());
            SceneDesc = /** @class */ (function () {
                function SceneDesc(name, path) {
                    this.defaultCameraController = Camera_6.OrbitCameraController;
                    this.name = name;
                    this.path = path;
                    this.id = this.path;
                }
                SceneDesc.prototype.createScene = function (gl) {
                    return util_26.fetch(this.path).then(function (result) {
                        var mdl0 = MDL0.parse(result);
                        return new Scene(gl, mdl0);
                    });
                };
                return SceneDesc;
            }());
            exports_46("SceneDesc", SceneDesc);
        }
    };
});
System.register("mdl0/scenes", ["mdl0/render"], function (exports_47, context_47) {
    "use strict";
    var __moduleName = context_47 && context_47.id;
    var render_17, name, id, sceneDescs, sceneGroup;
    return {
        setters: [
            function (render_17_1) {
                render_17 = render_17_1;
            }
        ],
        execute: function () {
            name = "Sonic Mania";
            id = "mdl0";
            sceneDescs = [
                'Meshes/Continue/Count0.bin',
                'Meshes/Continue/Count1.bin',
                'Meshes/Continue/Count2.bin',
                'Meshes/Continue/Count3.bin',
                'Meshes/Continue/Count4.bin',
                'Meshes/Continue/Count5.bin',
                'Meshes/Continue/Count6.bin',
                'Meshes/Continue/Count7.bin',
                'Meshes/Continue/Count8.bin',
                'Meshes/Continue/Count9.bin',
                'Meshes/Decoration/Bird.bin',
                'Meshes/Decoration/Fish.bin',
                'Meshes/Decoration/Flower1.bin',
                'Meshes/Decoration/Flower2.bin',
                'Meshes/Decoration/Flower3.bin',
                'Meshes/Decoration/Pillar1.bin',
                'Meshes/Decoration/Pillar2.bin',
                'Meshes/Decoration/Tree.bin',
                'Meshes/Global/Sonic.bin',
                'Meshes/Global/SpecialRing.bin',
                'Meshes/Special/EmeraldBlue.bin',
                'Meshes/Special/EmeraldCyan.bin',
                'Meshes/Special/EmeraldGreen.bin',
                'Meshes/Special/EmeraldGrey.bin',
                'Meshes/Special/EmeraldPurple.bin',
                'Meshes/Special/EmeraldRed.bin',
                'Meshes/Special/EmeraldYellow.bin',
                'Meshes/Special/ItemBox.bin',
                'Meshes/Special/KnuxBall.bin',
                'Meshes/Special/KnuxDash.bin',
                'Meshes/Special/KnuxJog.bin',
                'Meshes/Special/KnuxJump.bin',
                'Meshes/Special/KnuxTumble.bin',
                'Meshes/Special/Shadow.bin',
                'Meshes/Special/SonicBall.bin',
                'Meshes/Special/SonicDash.bin',
                'Meshes/Special/SonicJog.bin',
                'Meshes/Special/SonicJump.bin',
                'Meshes/Special/SonicTumble.bin',
                'Meshes/Special/Springboard.bin',
                'Meshes/Special/TailsBall.bin',
                'Meshes/Special/TailsDash.bin',
                'Meshes/Special/TailsJog.bin',
                'Meshes/Special/TailsJump.bin',
                'Meshes/Special/TailsTumble.bin',
                'Meshes/Special/UFOChase.bin',
                'Meshes/SSZ/EggTower.bin',
                'Meshes/TMZ/MonarchBG.bin',
                'Meshes/TMZ/OrbNet.bin',
            ].map(function (filename) {
                var path = "data/mdl0/" + filename;
                var name = filename;
                return new render_17.SceneDesc(name, path);
            });
            exports_47("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
System.register("zelview/zelview0", ["gl-matrix", "zelview/f3dex2", "util"], function (exports_48, context_48) {
    "use strict";
    var __moduleName = context_48 && context_48.id;
    function readZELVIEW0(buffer) {
        var view = buffer.createDataView();
        var MAGIC = "ZELVIEW0";
        if (util_27.readString(buffer, 0, MAGIC.length, false) !== MAGIC)
            throw new Error("Invalid ZELVIEW0 file");
        var offs = 0x08;
        var count = view.getUint8(offs);
        offs += 0x04;
        var mainFile = view.getUint8(offs);
        offs += 0x04;
        function readVFSEntry() {
            var entry = new VFSEntry();
            entry.filename = util_27.readString(buffer, offs, 0x30);
            offs += 0x30;
            entry.pStart = view.getUint32(offs, true);
            entry.pEnd = view.getUint32(offs + 0x04, true);
            entry.vStart = view.getUint32(offs + 0x08, true);
            entry.vEnd = view.getUint32(offs + 0x0C, true);
            offs += 0x10;
            return entry;
        }
        var entries = [];
        for (var i = 0; i < count; i++)
            entries.push(readVFSEntry());
        var zelview0 = new ZELVIEW0();
        zelview0.entries = entries;
        zelview0.sceneFile = entries[mainFile];
        zelview0.view = view;
        zelview0.buffer = buffer;
        return zelview0;
    }
    exports_48("readZELVIEW0", readZELVIEW0);
    function readHeaders(gl, rom, offs, banks) {
        var headers = new Headers();
        function loadAddress(addr) {
            return rom.loadAddress(banks, addr);
        }
        function readCollision(collisionAddr) {
            var offs = rom.lookupAddress(banks, collisionAddr);
            function readVerts(N, addr) {
                var offs = rom.lookupAddress(banks, addr);
                var verts = new Uint16Array(N * 3);
                for (var i = 0; i < N; i++) {
                    verts[i * 3 + 0] = rom.view.getInt16(offs + 0x00, false);
                    verts[i * 3 + 1] = rom.view.getInt16(offs + 0x02, false);
                    verts[i * 3 + 2] = rom.view.getInt16(offs + 0x04, false);
                    offs += 0x06;
                }
                return verts;
            }
            var vertsN = rom.view.getUint16(offs + 0x0C, false);
            var vertsAddr = rom.view.getUint32(offs + 0x10, false);
            var verts = readVerts(vertsN, vertsAddr);
            function readPolys(N, addr) {
                var offs = rom.lookupAddress(banks, addr);
                var polys = new Uint16Array(N * 3);
                for (var i = 0; i < N; i++) {
                    polys[i * 3 + 0] = rom.view.getUint16(offs + 0x02, false) & 0x0FFF;
                    polys[i * 3 + 1] = rom.view.getUint16(offs + 0x04, false) & 0x0FFF;
                    polys[i * 3 + 2] = rom.view.getUint16(offs + 0x06, false) & 0x0FFF;
                    offs += 0x10;
                }
                return polys;
            }
            var polysN = rom.view.getUint16(offs + 0x14, false);
            var polysAddr = rom.view.getUint32(offs + 0x18, false);
            var polys = readPolys(polysN, polysAddr);
            function readWaters(N, addr) {
                // XXX: While we should probably keep the actual stuff about
                // water boxes, I'm just drawing them, so let's just record
                // a quad.
                var offs = rom.lookupAddress(banks, addr);
                var waters = new Uint16Array(N * 3 * 4);
                for (var i = 0; i < N; i++) {
                    var x = rom.view.getInt16(offs + 0x00, false);
                    var y = rom.view.getInt16(offs + 0x02, false);
                    var z = rom.view.getInt16(offs + 0x04, false);
                    var sx = rom.view.getInt16(offs + 0x06, false);
                    var sz = rom.view.getInt16(offs + 0x08, false);
                    waters[i * 3 * 4 + 0] = x;
                    waters[i * 3 * 4 + 1] = y;
                    waters[i * 3 * 4 + 2] = z;
                    waters[i * 3 * 4 + 3] = x + sx;
                    waters[i * 3 * 4 + 4] = y;
                    waters[i * 3 * 4 + 5] = z;
                    waters[i * 3 * 4 + 6] = x;
                    waters[i * 3 * 4 + 7] = y;
                    waters[i * 3 * 4 + 8] = z + sz;
                    waters[i * 3 * 4 + 9] = x + sx;
                    waters[i * 3 * 4 + 10] = y;
                    waters[i * 3 * 4 + 11] = z + sz;
                    offs += 0x10;
                }
                return waters;
            }
            var watersN = rom.view.getUint16(offs + 0x24, false);
            var watersAddr = rom.view.getUint32(offs + 0x28, false);
            var waters = readWaters(watersN, watersAddr);
            function readCamera(addr) {
                var skyboxCamera = loadAddress(addr + 0x04);
                var offs = rom.lookupAddress(banks, skyboxCamera);
                var x = rom.view.getInt16(offs + 0x00, false);
                var y = rom.view.getInt16(offs + 0x02, false);
                var z = rom.view.getInt16(offs + 0x04, false);
                var a = rom.view.getUint16(offs + 0x06, false) / 0xFFFF * (Math.PI * 2);
                var b = rom.view.getUint16(offs + 0x08, false) / 0xFFFF * (Math.PI * 2) + Math.PI;
                var c = rom.view.getUint16(offs + 0x0A, false) / 0xFFFF * (Math.PI * 2);
                var d = rom.view.getUint16(offs + 0x0C, false);
                var mtx = gl_matrix_12.mat4.create();
                gl_matrix_12.mat4.translate(mtx, mtx, [x, y, z]);
                gl_matrix_12.mat4.rotateZ(mtx, mtx, c);
                gl_matrix_12.mat4.rotateY(mtx, mtx, b);
                gl_matrix_12.mat4.rotateX(mtx, mtx, -a);
                return mtx;
            }
            var cameraAddr = rom.view.getUint32(offs + 0x20, false);
            var camera = readCamera(cameraAddr);
            return { verts: verts, polys: polys, waters: waters, camera: camera };
        }
        function readRoom(file) {
            var banks2 = { scene: banks.scene, room: file };
            return readHeaders(gl, rom, file.vStart, banks2);
        }
        function readRooms(nRooms, roomTableAddr) {
            var rooms = [];
            for (var i = 0; i < nRooms; i++) {
                var pStart = loadAddress(roomTableAddr);
                var file = rom.lookupFile(pStart);
                var room = readRoom(file);
                room.filename = file.filename;
                rooms.push(room);
                roomTableAddr += 8;
            }
            return rooms;
        }
        function loadImage(gl, src) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            var texId = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texId);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            var img = document.createElement('img');
            img.src = src;
            var aspect = 1;
            img.onload = function () {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                gl.bindTexture(gl.TEXTURE_2D, texId);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, imgData.width, imgData.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imgData.data);
            };
            // XXX: Should pull this dynamically at runtime.
            var imgWidth = 320;
            var imgHeight = 240;
            var imgAspect = imgWidth / imgHeight;
            // const viewportAspect = gl.viewportWidth / gl.viewportHeight;
            var x = imgAspect;
            var vertData = new Float32Array([
                /* x   y   z   u  v */
                -x, -1, 0, 0, 1,
                x, -1, 0, 1, 1,
                -x, 1, 0, 0, 0,
                x, 1, 0, 1, 0,
            ]);
            var vertBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertData, gl.STATIC_DRAW);
            var idxData = new Uint8Array([
                0, 1, 2, 3,
            ]);
            var idxBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idxData, gl.STATIC_DRAW);
            // 3 pos + 2 uv
            var VERTEX_SIZE = 5;
            var VERTEX_BYTES = VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT;
            return function (renderState) {
                var gl = renderState.gl;
                var prog = renderState.currentProgram;
                gl.disable(gl.BLEND);
                gl.disable(gl.DEPTH_TEST);
                gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
                gl.vertexAttribPointer(prog.positionLocation, 3, gl.FLOAT, false, VERTEX_BYTES, 0);
                gl.vertexAttribPointer(prog.uvLocation, 2, gl.FLOAT, false, VERTEX_BYTES, 3 * Float32Array.BYTES_PER_ELEMENT);
                gl.enableVertexAttribArray(prog.positionLocation);
                gl.enableVertexAttribArray(prog.uvLocation);
                gl.bindTexture(gl.TEXTURE_2D, texId);
                gl.drawElements(gl.TRIANGLE_STRIP, 4, gl.UNSIGNED_BYTE, 0);
            };
        }
        function readMesh(meshAddr) {
            var hdr = loadAddress(meshAddr);
            var type = (hdr >> 24);
            var nEntries = (hdr >> 16) & 0xFF;
            var entriesAddr = loadAddress(meshAddr + 4);
            var mesh = new Mesh();
            function readDL(addr) {
                var dlStart = loadAddress(addr);
                if (dlStart === 0)
                    return null;
                return F3DEX2.readDL(gl, rom, banks, dlStart);
            }
            if (type === 0) {
                for (var i = 0; i < nEntries; i++) {
                    mesh.opaque.push(readDL(entriesAddr));
                    mesh.transparent.push(readDL(entriesAddr + 4));
                    entriesAddr += 8;
                }
            }
            else if (type === 1) {
                // The last entry always seems to contain the BG. Not sure
                // what the other data is about... maybe the VR skybox for rotating scenes?
                var lastEntry = nEntries - 1;
                var bg = loadAddress(meshAddr + (lastEntry * 0x0C) + 0x08);
                var bgOffs = rom.lookupAddress(banks, bg);
                var buffer = rom.buffer.slice(bgOffs);
                var blob = new Blob([buffer.castToBuffer()], { type: 'image/jpeg' });
                var url = window.URL.createObjectURL(blob);
                mesh.bg = loadImage(gl, url);
            }
            else if (type === 2) {
                for (var i = 0; i < nEntries; i++) {
                    mesh.opaque.push(readDL(entriesAddr + 8));
                    mesh.transparent.push(readDL(entriesAddr + 12));
                    entriesAddr += 16;
                }
            }
            mesh.opaque = mesh.opaque.filter(function (dl) { return !!dl; });
            mesh.transparent = mesh.transparent.filter(function (dl) { return !!dl; });
            mesh.textures = [];
            mesh.opaque.forEach(function (dl) { mesh.textures = mesh.textures.concat(dl.textures); });
            mesh.transparent.forEach(function (dl) { mesh.textures = mesh.textures.concat(dl.textures); });
            return mesh;
        }
        headers.rooms = [];
        headers.mesh = null;
        var startOffs = offs;
        while (true) {
            var cmd1 = rom.view.getUint32(offs, false);
            var cmd2 = rom.view.getUint32(offs + 4, false);
            offs += 8;
            var cmdType = cmd1 >> 24;
            if (cmdType === HeaderCommands.End)
                break;
            switch (cmdType) {
                case HeaderCommands.Collision:
                    headers.collision = readCollision(cmd2);
                    break;
                case HeaderCommands.Rooms:
                    var nRooms = (cmd1 >> 16) & 0xFF;
                    headers.rooms = readRooms(nRooms, cmd2);
                    break;
                case HeaderCommands.Mesh:
                    headers.mesh = readMesh(cmd2);
                    break;
            }
        }
        return headers;
    }
    function readScene(gl, zelview0, file) {
        var banks = { scene: file };
        return readHeaders(gl, zelview0, file.vStart, banks);
    }
    var gl_matrix_12, F3DEX2, util_27, VFSEntry, ZELVIEW0, Mesh, Headers, HeaderCommands;
    return {
        setters: [
            function (gl_matrix_12_1) {
                gl_matrix_12 = gl_matrix_12_1;
            },
            function (F3DEX2_1) {
                F3DEX2 = F3DEX2_1;
            },
            function (util_27_1) {
                util_27 = util_27_1;
            }
        ],
        execute: function () {
            // Loads the ZELVIEW0 format.
            VFSEntry = /** @class */ (function () {
                function VFSEntry() {
                }
                return VFSEntry;
            }());
            ZELVIEW0 = /** @class */ (function () {
                function ZELVIEW0() {
                }
                ZELVIEW0.prototype.lookupFile = function (pStart) {
                    try {
                        for (var _a = __values(this.entries), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var entry = _b.value;
                            if (entry.pStart === pStart)
                                return entry;
                        }
                    }
                    catch (e_42_1) { e_42 = { error: e_42_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_42) throw e_42.error; }
                    }
                    return null;
                    var e_42, _c;
                };
                ZELVIEW0.prototype.lookupAddress = function (banks, addr) {
                    var bankIdx = addr >>> 24;
                    var offs = addr & 0x00FFFFFF;
                    function findBank() {
                        switch (bankIdx) {
                            case 0x02: return banks.scene;
                            case 0x03: return banks.room;
                            default: return null;
                        }
                    }
                    var bank = findBank();
                    if (bank === null)
                        return null;
                    var absOffs = bank.vStart + offs;
                    if (absOffs > bank.vEnd)
                        return null;
                    return absOffs;
                };
                ZELVIEW0.prototype.loadAddress = function (banks, addr) {
                    var offs = this.lookupAddress(banks, addr);
                    return this.view.getUint32(offs);
                };
                ZELVIEW0.prototype.loadScene = function (gl, scene) {
                    return readScene(gl, this, scene);
                };
                ZELVIEW0.prototype.loadMainScene = function (gl) {
                    return this.loadScene(gl, this.sceneFile);
                };
                return ZELVIEW0;
            }());
            exports_48("ZELVIEW0", ZELVIEW0);
            Mesh = /** @class */ (function () {
                function Mesh() {
                    this.opaque = [];
                    this.transparent = [];
                }
                return Mesh;
            }());
            exports_48("Mesh", Mesh);
            Headers = /** @class */ (function () {
                function Headers() {
                    this.rooms = [];
                }
                return Headers;
            }());
            exports_48("Headers", Headers);
            (function (HeaderCommands) {
                HeaderCommands[HeaderCommands["Spawns"] = 0] = "Spawns";
                HeaderCommands[HeaderCommands["Actors"] = 1] = "Actors";
                HeaderCommands[HeaderCommands["Camera"] = 2] = "Camera";
                HeaderCommands[HeaderCommands["Collision"] = 3] = "Collision";
                HeaderCommands[HeaderCommands["Rooms"] = 4] = "Rooms";
                HeaderCommands[HeaderCommands["WindSettings"] = 5] = "WindSettings";
                HeaderCommands[HeaderCommands["EntranceList"] = 6] = "EntranceList";
                HeaderCommands[HeaderCommands["SpecialObjects"] = 7] = "SpecialObjects";
                HeaderCommands[HeaderCommands["SpecialBehavior"] = 8] = "SpecialBehavior";
                // 0x09 is unknown
                HeaderCommands[HeaderCommands["Mesh"] = 10] = "Mesh";
                HeaderCommands[HeaderCommands["Objects"] = 11] = "Objects";
                // 0x0C is unused
                HeaderCommands[HeaderCommands["Waypoints"] = 13] = "Waypoints";
                HeaderCommands[HeaderCommands["Transitions"] = 14] = "Transitions";
                HeaderCommands[HeaderCommands["Environment"] = 15] = "Environment";
                HeaderCommands[HeaderCommands["Time"] = 16] = "Time";
                HeaderCommands[HeaderCommands["Skybox"] = 17] = "Skybox";
                HeaderCommands[HeaderCommands["End"] = 20] = "End";
            })(HeaderCommands || (HeaderCommands = {}));
        }
    };
});
System.register("zelview/f3dex2", ["gl-matrix", "zelview/render", "render"], function (exports_49, context_49) {
    "use strict";
    var __moduleName = context_49 && context_49.id;
    function extractBits(value, offset, bits) {
        return (value >> offset) & ((1 << bits) - 1);
    }
    function readVertex(state, which, addr) {
        var rom = state.rom;
        var offs = state.lookupAddress(addr);
        var posX = rom.view.getInt16(offs + 0, false);
        var posY = rom.view.getInt16(offs + 2, false);
        var posZ = rom.view.getInt16(offs + 4, false);
        var pos = gl_matrix_13.vec3.clone([posX, posY, posZ]);
        gl_matrix_13.vec3.transformMat4(pos, pos, state.mtx);
        var txU = rom.view.getInt16(offs + 8, false) * (1 / 32);
        var txV = rom.view.getInt16(offs + 10, false) * (1 / 32);
        var vtxArray = new Float32Array(state.vertexBuffer.buffer, which * VERTEX_BYTES, VERTEX_SIZE);
        vtxArray[0] = pos[0];
        vtxArray[1] = pos[1];
        vtxArray[2] = pos[2];
        vtxArray[3] = txU;
        vtxArray[4] = txV;
        vtxArray[5] = rom.view.getUint8(offs + 12) / 255;
        vtxArray[6] = rom.view.getUint8(offs + 13) / 255;
        vtxArray[7] = rom.view.getUint8(offs + 14) / 255;
        vtxArray[8] = rom.view.getUint8(offs + 15) / 255;
    }
    function cmd_VTX(state, w0, w1) {
        var N = (w0 >> 12) & 0xFF;
        var V0 = ((w0 >> 1) & 0x7F) - N;
        var addr = w1;
        for (var i = 0; i < N; i++) {
            var which = V0 + i;
            readVertex(state, which, addr);
            addr += 16;
        }
    }
    function flushDraw(state) {
        var gl = state.gl;
        var vtxBufSize = state.vertexData.length / VERTEX_SIZE;
        var vtxOffs = state.vertexOffs;
        var vtxCount = vtxBufSize - vtxOffs;
        state.vertexOffs = vtxBufSize;
        if (vtxCount === 0)
            return;
        state.pushProgramCmds();
        state.cmds.push(function (renderState) {
            var gl = renderState.gl;
            gl.drawArrays(gl.TRIANGLES, vtxOffs, vtxCount);
        });
    }
    function translateTRI(state, idxData) {
        idxData.forEach(function (idx, i) {
            var offs = idx * VERTEX_SIZE;
            for (var i_3 = 0; i_3 < VERTEX_SIZE; i_3++) {
                state.vertexData.push(state.vertexBuffer[offs + i_3]);
            }
        });
    }
    function tri(idxData, offs, cmd) {
        idxData[offs + 0] = (cmd >> 17) & 0x7F;
        idxData[offs + 1] = (cmd >> 9) & 0x7F;
        idxData[offs + 2] = (cmd >> 1) & 0x7F;
    }
    function flushTexture(state) {
        if (state.textureTiles[0] && state.textureTiles[0].addr != 0)
            loadTile(state, state.textureTiles[0]);
        if (state.textureTiles[1] && state.textureTiles[0].addr != 0)
            loadTile(state, state.textureTiles[1]);
    }
    function cmd_TRI1(state, w0, w1) {
        flushTexture(state);
        var idxData = new Uint8Array(3);
        tri(idxData, 0, w0);
        translateTRI(state, idxData);
    }
    function cmd_TRI2(state, w0, w1) {
        flushTexture(state);
        var idxData = new Uint8Array(6);
        tri(idxData, 0, w0);
        tri(idxData, 3, w1);
        translateTRI(state, idxData);
    }
    function cmd_GEOMETRYMODE(state, w0, w1) {
        flushDraw(state);
        state.geometryMode = state.geometryMode & ((~w0) & 0x00FFFFFF) | w1;
        var newMode = state.geometryMode;
        var renderFlags = new render_18.RenderFlags();
        var cullFront = newMode & GeometryMode.CULL_FRONT;
        var cullBack = newMode & GeometryMode.CULL_BACK;
        if (cullFront && cullBack)
            renderFlags.cullMode = render_18.CullMode.FRONT_AND_BACK;
        else if (cullFront)
            renderFlags.cullMode = render_18.CullMode.FRONT;
        else if (cullBack)
            renderFlags.cullMode = render_18.CullMode.BACK;
        else
            renderFlags.cullMode = render_18.CullMode.NONE;
        state.cmds.push(function (renderState) {
            renderState.useFlags(renderFlags);
        });
    }
    function cmd_SETOTHERMODE_L(state, w0, w1) {
        flushDraw(state);
        var len = extractBits(w0, 0, 8) + 1;
        var sft = Math.max(0, 32 - extractBits(w0, 8, 8) - len);
        var mask = ((1 << len) - 1) << sft;
        state.otherModeL = (state.otherModeL & ~mask) | (w1 & mask);
        var renderFlags = new render_18.RenderFlags();
        var newMode = state.otherModeL;
        renderFlags.depthTest = !!(newMode & OtherModeL.Z_CMP);
        renderFlags.depthWrite = !!(newMode & OtherModeL.Z_UPD);
        var alphaTestMode;
        if (newMode & OtherModeL.FORCE_BL) {
            alphaTestMode = 0;
            renderFlags.blendMode = render_18.BlendMode.ADD;
        }
        else {
            alphaTestMode = ((newMode & OtherModeL.CVG_X_ALPHA) ? 0x1 : 0 |
                (newMode & OtherModeL.ALPHA_CVG_SEL) ? 0x2 : 0);
            renderFlags.blendMode = render_18.BlendMode.NONE;
        }
        state.cmds.push(function (renderState) {
            var gl = renderState.gl;
            renderState.useFlags(renderFlags);
            if (newMode & OtherModeL.ZMODE_DEC) {
                gl.enable(gl.POLYGON_OFFSET_FILL);
                gl.polygonOffset(-0.5, -0.5);
            }
            else {
                gl.disable(gl.POLYGON_OFFSET_FILL);
            }
        });
    }
    function cmd_SETOTHERMODE_H(state, w0, w1) {
        flushDraw(state);
        var len = extractBits(w0, 0, 8) + 1;
        var sft = Math.max(0, 32 - extractBits(w0, 8, 8) - len);
        var mask = ((1 << len) - 1) << sft;
        state.otherModeH = (state.otherModeH & ~mask) | (w1 & mask);
    }
    function cmd_DL(state, w0, w1) {
        runDL(state, w1);
    }
    function cmd_MTX(state, w0, w1) {
        if (w1 & 0x80000000)
            state.mtx = state.mtxStack.pop();
        w1 &= ~0x80000000;
        state.geometryMode = 0;
        state.otherModeL = 0;
        state.mtxStack.push(state.mtx);
        state.mtx = gl_matrix_13.mat4.clone(state.mtx);
        var rom = state.rom;
        var offs = state.lookupAddress(w1);
        var mtx = gl_matrix_13.mat4.create();
        for (var x = 0; x < 4; x++) {
            for (var y = 0; y < 4; y++) {
                var mt1 = rom.view.getUint16(offs, false);
                var mt2 = rom.view.getUint16(offs + 32, false);
                mtx[(x * 4) + y] = ((mt1 << 16) | (mt2)) * (1 / 0x10000);
                offs += 2;
            }
        }
        gl_matrix_13.mat4.multiply(state.mtx, state.mtx, mtx);
    }
    function cmd_POPMTX(state, w0, w1) {
        state.mtx = state.mtxStack.pop();
    }
    function cmd_TEXTURE(state, w0, w1) {
        // XXX(jstpierre): Bring this back at some point.
        /*
        const boundTexture = {};
        state.boundTexture = boundTexture;
    
        const s = w1 >> 16;
        const t = w1 & 0x0000FFFF;
    
        state.boundTexture.scaleS = (s + 1) / 0x10000;
        state.boundTexture.scaleT = (t + 1) / 0x10000;
        */
    }
    function cmd_SETCOMBINE(state, w0, w1) {
        flushDraw(state);
        state.combiners = Object.freeze({
            colorCombiners: Object.freeze([
                Object.freeze({
                    subA: extractBits(w0, 20, 4),
                    subB: extractBits(w1, 28, 4),
                    mul: extractBits(w0, 15, 5),
                    add: extractBits(w1, 15, 3),
                }),
                Object.freeze({
                    subA: extractBits(w0, 5, 4),
                    subB: extractBits(w1, 24, 4),
                    mul: extractBits(w0, 0, 5),
                    add: extractBits(w1, 6, 3),
                }),
            ]),
            alphaCombiners: Object.freeze([
                Object.freeze({
                    subA: extractBits(w0, 12, 3),
                    subB: extractBits(w1, 12, 3),
                    mul: extractBits(w0, 9, 3),
                    add: extractBits(w1, 9, 3),
                }),
                Object.freeze({
                    subA: extractBits(w1, 21, 3),
                    subB: extractBits(w1, 3, 3),
                    mul: extractBits(w1, 18, 3),
                    add: extractBits(w1, 0, 3),
                }),
            ]),
        });
    }
    function cmd_SETENVCOLOR(state, w0, w1) {
        flushDraw(state);
        state.envColor = gl_matrix_13.vec4.clone([
            extractBits(w1, 24, 8) / 255,
            extractBits(w1, 16, 8) / 255,
            extractBits(w1, 8, 8) / 255,
            extractBits(w1, 0, 8) / 255,
        ]);
    }
    function cmd_SETPRIMCOLOR(state, w0, w1) {
        flushDraw(state);
        state.primColor = gl_matrix_13.vec4.clone([
            extractBits(w1, 24, 8) / 255,
            extractBits(w1, 16, 8) / 255,
            extractBits(w1, 8, 8) / 255,
            extractBits(w1, 0, 8) / 255,
        ]);
    }
    function r5g5b5a1(dst, dstOffs, p) {
        var r, g, b, a;
        r = (p & 0xF800) >> 11;
        r = (r << (8 - 5)) | (r >> (10 - 8));
        g = (p & 0x07C0) >> 6;
        g = (g << (8 - 5)) | (g >> (10 - 8));
        b = (p & 0x003E) >> 1;
        b = (b << (8 - 5)) | (b >> (10 - 8));
        a = (p & 0x0001) ? 0xFF : 0x00;
        dst[dstOffs + 0] = r;
        dst[dstOffs + 1] = g;
        dst[dstOffs + 2] = b;
        dst[dstOffs + 3] = a;
    }
    function cmd_SETTIMG(state, w0, w1) {
        var format = (w0 >> 21) & 0x7;
        var size = (w0 >> 19) & 0x3;
        var width = (w0 & 0x1000) + 1;
        var addr = w1;
        state.textureImageAddr = addr;
    }
    function cmd_SETTILE(state, w0, w1) {
        state.currentTile = {
            format: (w0 >> 16) & 0xFF,
            cms: (w1 >> 8) & 0x3,
            cmt: (w1 >> 18) & 0x3,
            // tmem: w0 & 0x1FF,
            lineSize: (w0 >> 9) & 0x1FF,
            // palette: (w1 >> 20) & 0xF,
            // shiftS: w1 & 0xF,
            // shiftT: (w1 >> 10) & 0xF,
            maskS: (w1 >> 4) & 0xF,
            maskT: (w1 >> 14) & 0xF,
            width: 0, height: 0, dstFormat: null,
            pixels: null, addr: 0, glTextureId: null,
            uls: 0, ult: 0, lrs: 0, lrt: 0,
        };
    }
    function cmd_SETTILESIZE(state, w0, w1) {
        var tileIdx = (w1 >> 24) & 0x7;
        // XXX(jstpierre): Multiple tiles?
        var tile = state.currentTile;
        tile.uls = (w0 >> 14) & 0x3FF;
        tile.ult = (w0 >> 2) & 0x3FF;
        tile.lrs = (w1 >> 14) & 0x3FF;
        tile.lrt = (w1 >> 2) & 0x3FF;
        calcTextureSize(tile);
    }
    function cmd_LOADTLUT(state, w0, w1) {
        var rom = state.rom;
        // XXX: properly implement uls/ult/lrs/lrt
        var size = ((w1 & 0x00FFF000) >> 14) + 1;
        var dst = new Uint8Array(size * 4);
        var srcOffs = state.lookupAddress(state.textureImageAddr);
        var dstOffs = 0;
        for (var i = 0; i < size; i++) {
            var pixel = rom.view.getUint16(srcOffs, false);
            r5g5b5a1(dst, dstOffs, pixel);
            srcOffs += 2;
            dstOffs += 4;
        }
        state.palettePixels = dst;
    }
    function tileCacheKey(state, tile) {
        // XXX: Do we need more than this?
        var srcOffs = state.lookupAddress(tile.addr);
        return srcOffs;
    }
    function loadTile(state, texture) {
        if (texture.glTextureId)
            return;
        var key = tileCacheKey(state, texture);
        var otherTile = tileCache.get(key);
        if (!otherTile) {
            translateTexture(state, texture);
            tileCache.set(key, texture);
        }
        else if (texture !== otherTile) {
            texture.glTextureId = otherTile.glTextureId;
        }
    }
    function convert_CI4(state, texture) {
        var palette = state.palettePixels;
        if (!palette)
            return;
        var nBytes = texture.width * texture.height * 4;
        var dst = new Uint8Array(nBytes);
        var srcOffs = state.lookupAddress(texture.addr);
        var i = 0;
        for (var y = 0; y < texture.height; y++) {
            for (var x = 0; x < texture.width; x += 2) {
                var b = state.rom.view.getUint8(srcOffs++);
                var idx = void 0;
                idx = ((b & 0xF0) >> 4) * 4;
                dst[i++] = palette[idx++];
                dst[i++] = palette[idx++];
                dst[i++] = palette[idx++];
                dst[i++] = palette[idx++];
                idx = (b & 0x0F) * 4;
                dst[i++] = palette[idx++];
                dst[i++] = palette[idx++];
                dst[i++] = palette[idx++];
                dst[i++] = palette[idx++];
            }
        }
        texture.pixels = dst;
    }
    function convert_I4(state, texture) {
        var nBytes = texture.width * texture.height * 2;
        var dst = new Uint8Array(nBytes);
        var srcOffs = state.lookupAddress(texture.addr);
        var i = 0;
        for (var y = 0; y < texture.height; y++) {
            for (var x = 0; x < texture.width; x += 2) {
                var b = state.rom.view.getUint8(srcOffs++);
                var p = void 0;
                p = (b & 0xF0) >> 4;
                p = p << 4 | p;
                dst[i++] = p;
                dst[i++] = p;
                p = (b & 0x0F);
                p = p << 4 | p;
                dst[i++] = p;
                dst[i++] = p;
            }
        }
        texture.pixels = dst;
    }
    function convert_IA4(state, texture) {
        var nBytes = texture.width * texture.height * 2;
        var dst = new Uint8Array(nBytes);
        var srcOffs = state.lookupAddress(texture.addr);
        var i = 0;
        for (var y = 0; y < texture.height; y++) {
            for (var x = 0; x < texture.width; x += 2) {
                var b = state.rom.view.getUint8(srcOffs++);
                var p = void 0;
                var pm = void 0;
                p = (b & 0xF0) >> 4;
                pm = p & 0x0E;
                dst[i++] = (pm << 4 | pm);
                dst[i++] = (p & 0x01) ? 0xFF : 0x00;
                p = (b & 0x0F);
                pm = p & 0x0E;
                dst[i++] = (pm << 4 | pm);
                dst[i++] = (p & 0x01) ? 0xFF : 0x00;
            }
        }
        texture.pixels = dst;
    }
    function convert_CI8(state, texture) {
        var palette = state.palettePixels;
        if (!palette)
            return;
        var nBytes = texture.width * texture.height * 4;
        var dst = new Uint8Array(nBytes);
        var srcOffs = state.lookupAddress(texture.addr);
        var i = 0;
        for (var y = 0; y < texture.height; y++) {
            for (var x = 0; x < texture.width; x++) {
                var idx = state.rom.view.getUint8(srcOffs) * 4;
                dst[i++] = palette[idx++];
                dst[i++] = palette[idx++];
                dst[i++] = palette[idx++];
                dst[i++] = palette[idx++];
                srcOffs++;
            }
        }
        texture.pixels = dst;
    }
    function convert_I8(state, texture) {
        var nBytes = texture.width * texture.height * 2;
        var dst = new Uint8Array(nBytes);
        var srcOffs = state.lookupAddress(texture.addr);
        var i = 0;
        for (var y = 0; y < texture.height; y++) {
            for (var x = 0; x < texture.width; x++) {
                var p = state.rom.view.getUint8(srcOffs++);
                dst[i++] = p;
                dst[i++] = p;
            }
        }
        texture.pixels = dst;
    }
    function convert_IA8(state, texture) {
        var nBytes = texture.width * texture.height * 2;
        var dst = new Uint8Array(nBytes);
        var srcOffs = state.lookupAddress(texture.addr);
        var i = 0;
        for (var y = 0; y < texture.height; y++) {
            for (var x = 0; x < texture.width; x++) {
                var b = state.rom.view.getUint8(srcOffs++);
                var p = void 0;
                p = (b & 0xF0) >> 4;
                p = p << 4 | p;
                dst[i++] = p;
                p = (b & 0x0F);
                p = p >> 4 | p;
                dst[i++] = p;
            }
        }
        texture.pixels = dst;
    }
    function convert_RGBA16(state, texture) {
        var rom = state.rom;
        var nBytes = texture.width * texture.height * 4;
        var dst = new Uint8Array(nBytes);
        var srcOffs = state.lookupAddress(texture.addr);
        var i = 0;
        for (var y = 0; y < texture.height; y++) {
            for (var x = 0; x < texture.width; x++) {
                var pixel = rom.view.getUint16(srcOffs, false);
                r5g5b5a1(dst, i, pixel);
                i += 4;
                srcOffs += 2;
            }
        }
        texture.pixels = dst;
    }
    function convert_IA16(state, texture) {
        var nBytes = texture.width * texture.height * 2;
        var dst = new Uint8Array(nBytes);
        var srcOffs = state.lookupAddress(texture.addr);
        var i = 0;
        for (var y = 0; y < texture.height; y++) {
            for (var x = 0; x < texture.width; x++) {
                dst[i++] = state.rom.view.getUint8(srcOffs++);
                dst[i++] = state.rom.view.getUint8(srcOffs++);
            }
        }
        texture.pixels = dst;
    }
    function textureToCanvas(texture) {
        var canvas = document.createElement("canvas");
        canvas.width = texture.width;
        canvas.height = texture.height;
        var ctx = canvas.getContext("2d");
        var imgData = ctx.createImageData(canvas.width, canvas.height);
        if (texture.dstFormat === "i8") {
            for (var si = 0, di = 0; di < imgData.data.length; si++, di += 4) {
                imgData.data[di + 0] = texture.pixels[si];
                imgData.data[di + 1] = texture.pixels[si];
                imgData.data[di + 2] = texture.pixels[si];
                imgData.data[di + 3] = 255;
            }
        }
        else if (texture.dstFormat === "i8_a8") {
            for (var si = 0, di = 0; di < imgData.data.length; si += 2, di += 4) {
                imgData.data[di + 0] = texture.pixels[si];
                imgData.data[di + 1] = texture.pixels[si];
                imgData.data[di + 2] = texture.pixels[si];
                imgData.data[di + 3] = texture.pixels[si + 1];
            }
        }
        else if (texture.dstFormat === "rgba8") {
            imgData.data.set(texture.pixels);
        }
        canvas.title = '0x' + texture.addr.toString(16) + '  ' + texture.format.toString(16) + '  ' + texture.dstFormat;
        ctx.putImageData(imgData, 0, 0);
        var surfaces = [canvas];
        return { name: canvas.title, surfaces: surfaces };
    }
    function translateTexture(state, texture) {
        var gl = state.gl;
        function convertTexturePixels() {
            switch (texture.format) {
                // 4-bit
                case 0x40: return convert_CI4(state, texture); // CI
                case 0x60: return convert_IA4(state, texture); // IA
                case 0x80: return convert_I4(state, texture); // I
                // 8-bit
                case 0x48: return convert_CI8(state, texture); // CI
                case 0x68: return convert_IA8(state, texture); // IA
                case 0x88: return convert_I8(state, texture); // I
                // 16-bit
                case 0x10: return convert_RGBA16(state, texture); // RGBA
                case 0x70: return convert_IA16(state, texture); // IA
                default: console.error("Unsupported texture", texture.format.toString(16));
            }
        }
        texture.dstFormat = calcTextureDestFormat(texture);
        var srcOffs = state.lookupAddress(texture.addr);
        if (srcOffs !== null)
            convertTexturePixels();
        if (!texture.pixels) {
            if (texture.dstFormat === "i8")
                texture.pixels = new Uint8Array(texture.width * texture.height);
            else if (texture.dstFormat === "i8_a8")
                texture.pixels = new Uint8Array(texture.width * texture.height * 2);
            else if (texture.dstFormat === "rgba8")
                texture.pixels = new Uint8Array(texture.width * texture.height * 4);
        }
        function translateWrap(cm) {
            switch (cm) {
                case 1: return gl.MIRRORED_REPEAT;
                case 2: return gl.CLAMP_TO_EDGE;
                case 3: return gl.CLAMP_TO_EDGE;
                default: return gl.REPEAT;
            }
        }
        var texId = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texId);
        // Filters are set to NEAREST here because filtering is performed in the fragment shader.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, translateWrap(texture.cms));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, translateWrap(texture.cmt));
        var glFormat;
        if (texture.dstFormat === "i8")
            glFormat = gl.LUMINANCE;
        else if (texture.dstFormat === "i8_a8")
            glFormat = gl.LUMINANCE_ALPHA;
        else if (texture.dstFormat === "rgba8")
            glFormat = gl.RGBA;
        gl.texImage2D(gl.TEXTURE_2D, 0, glFormat, texture.width, texture.height, 0, glFormat, gl.UNSIGNED_BYTE, texture.pixels);
        texture.glTextureId = texId;
        state.textures.push(textureToCanvas(texture));
    }
    function calcTextureDestFormat(texture) {
        switch (texture.format & 0xE0) {
            case 0x00: return "rgba8"; // RGBA
            case 0x40: return "rgba8"; // CI -- XXX -- do we need to check the palette type?
            case 0x60: return "i8_a8"; // IA
            case 0x80: return "i8_a8"; // I
            default: throw new Error("Invalid texture type");
        }
    }
    function calcTextureSize(texture) {
        var maxTexel, lineShift;
        switch (texture.format) {
            // 4-bit
            case 0x00:
                maxTexel = 4096;
                lineShift = 4;
                break; // RGBA
            case 0x40:
                maxTexel = 4096;
                lineShift = 4;
                break; // CI
            case 0x60:
                maxTexel = 8196;
                lineShift = 4;
                break; // IA
            case 0x80:
                maxTexel = 8196;
                lineShift = 4;
                break; // I
            // 8-bit
            case 0x08:
                maxTexel = 2048;
                lineShift = 3;
                break; // RGBA
            case 0x48:
                maxTexel = 2048;
                lineShift = 3;
                break; // CI
            case 0x68:
                maxTexel = 4096;
                lineShift = 3;
                break; // IA
            case 0x88:
                maxTexel = 4096;
                lineShift = 3;
                break; // I
            // 16-bit
            case 0x10:
                maxTexel = 2048;
                lineShift = 2;
                break; // RGBA
            case 0x50:
                maxTexel = 2048;
                lineShift = 0;
                break; // CI
            case 0x70:
                maxTexel = 2048;
                lineShift = 2;
                break; // IA
            case 0x90:
                maxTexel = 2048;
                lineShift = 0;
                break; // I
            // 32-bit
            case 0x18:
                maxTexel = 1024;
                lineShift = 2;
                break; // RGBA
            default:
                throw "whoops";
        }
        var lineW = texture.lineSize << lineShift;
        var tileW = texture.lrs - texture.uls + 1;
        var tileH = texture.lrt - texture.ult + 1;
        var maskW = 1 << texture.maskS;
        var maskH = 1 << texture.maskT;
        var lineH;
        if (lineW > 0)
            lineH = Math.min(maxTexel / lineW, tileH);
        else
            lineH = 0;
        var width;
        if (texture.maskS > 0 && (maskW * maskH) <= maxTexel)
            width = maskW;
        else if ((tileW * tileH) <= maxTexel)
            width = tileW;
        else
            width = lineW;
        var height;
        if (texture.maskT > 0 && (maskW * maskH) <= maxTexel)
            height = maskH;
        else if ((tileW * tileH) <= maxTexel)
            height = tileH;
        else
            height = lineH;
        texture.width = width;
        texture.height = height;
    }
    function loadTextureBlock(state, cmds) {
        flushDraw(state);
        var tileIdx = (cmds[5][1] >> 24) & 0x7;
        cmd_SETTIMG(state, cmds[0][0], cmds[0][1]);
        cmd_SETTILE(state, cmds[5][0], cmds[5][1]); // state.currentTile is constructed here
        cmd_SETTILESIZE(state, cmds[6][0], cmds[6][1]);
        state.currentTile.addr = state.textureImageAddr;
        state.textureTiles[tileIdx] = state.currentTile;
    }
    function runDL(state, addr) {
        function collectNextCmds() {
            var L = [];
            var voffs = offs;
            for (var i = 0; i < 8; i++) {
                var cmd0 = rom.view.getUint32(voffs, false);
                var cmd1 = rom.view.getUint32(voffs + 4, false);
                L.push([cmd0, cmd1]);
                voffs += 8;
            }
            return L;
        }
        function matchesCmdStream(cmds, needle) {
            for (var i = 0; i < needle.length; i++)
                if (cmds[i][0] >>> 24 !== needle[i])
                    return false;
            return true;
        }
        var rom = state.rom;
        var offs = state.lookupAddress(addr);
        if (offs === null)
            return;
        while (true) {
            var cmd0 = rom.view.getUint32(offs, false);
            var cmd1 = rom.view.getUint32(offs + 4, false);
            var cmdType = cmd0 >>> 24;
            if (cmdType === 223 /* ENDDL */)
                break;
            // Texture uploads need to be special.
            if (cmdType === 253 /* SETTIMG */) {
                var nextCmds = collectNextCmds();
                if (matchesCmdStream(nextCmds, [253 /* SETTIMG */, 245 /* SETTILE */, 230 /* RDPLOADSYNC */, 243 /* LOADBLOCK */, 231 /* RDPPIPESYNC */, 245 /* SETTILE */, 242 /* SETTILESIZE */])) {
                    loadTextureBlock(state, nextCmds);
                    offs += 7 * 8;
                    continue;
                }
            }
            var func = CommandDispatch[cmdType];
            if (func)
                func(state, cmd0, cmd1);
            offs += 8;
        }
        flushDraw(state);
    }
    function readDL(gl, rom, banks, startAddr) {
        var state = new State();
        state.gl = gl;
        state.cmds = [];
        state.textures = [];
        state.mtx = gl_matrix_13.mat4.create();
        state.mtxStack = [state.mtx];
        state.vertexBuffer = new Float32Array(32 * VERTEX_SIZE);
        state.vertexData = [];
        state.vertexOffs = 0;
        state.rom = rom;
        state.banks = banks;
        runDL(state, startAddr);
        var vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        var vertBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(state.vertexData), gl.STATIC_DRAW);
        gl.vertexAttribPointer(Render.F3DEX2Program.a_Position, 3, gl.FLOAT, false, VERTEX_BYTES, 0);
        gl.vertexAttribPointer(Render.F3DEX2Program.a_UV, 2, gl.FLOAT, false, VERTEX_BYTES, 3 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(Render.F3DEX2Program.a_Shade, 4, gl.FLOAT, false, VERTEX_BYTES, 5 * Float32Array.BYTES_PER_ELEMENT);
        gl.enableVertexAttribArray(Render.F3DEX2Program.a_Position);
        gl.enableVertexAttribArray(Render.F3DEX2Program.a_UV);
        gl.enableVertexAttribArray(Render.F3DEX2Program.a_Shade);
        gl.bindVertexArray(null);
        return new DL(vao, state.cmds, state.textures);
    }
    exports_49("readDL", readDL);
    var gl_matrix_13, Render, render_18, OtherModeH, CYCLETYPE, State, VERTEX_SIZE, VERTEX_BYTES, GeometryMode, OtherModeL, tileCache, CommandDispatch, F3DEX2, DL;
    return {
        setters: [
            function (gl_matrix_13_1) {
                gl_matrix_13 = gl_matrix_13_1;
            },
            function (Render_1) {
                Render = Render_1;
            },
            function (render_18_1) {
                render_18 = render_18_1;
            }
        ],
        execute: function () {
            OtherModeH = {
                CYCLETYPE_SFT: 20,
                CYCLETYPE_LEN: 2,
            };
            CYCLETYPE = {
                _1CYCLE: 0,
                _2CYCLE: 1,
                COPY: 2,
                FILL: 3,
            };
            State = /** @class */ (function () {
                function State() {
                    this.programMap = {};
                    this.geometryMode = 0;
                    this.otherModeL = 0;
                    this.otherModeH = (CYCLETYPE._2CYCLE << OtherModeH.CYCLETYPE_SFT);
                    this.primColor = gl_matrix_13.vec4.clone([1, 1, 1, 1]);
                    // FIXME: Initial envColor depends on which map is loaded, and can be animated.
                    this.envColor = gl_matrix_13.vec4.clone([0, 0, 0, 0.5]);
                    this.textureTiles = [];
                }
                State.prototype.lookupAddress = function (addr) {
                    return this.rom.lookupAddress(this.banks, addr);
                };
                State.prototype.getDLProgram = function (params) {
                    var hash = Render.hashF3DEX2Params(params);
                    if (!(hash in this.programMap)) {
                        this.programMap[hash] = new Render.F3DEX2Program(params);
                    }
                    return this.programMap[hash];
                };
                State.prototype.pushProgramCmds = function () {
                    // Clone all relevant fields to prevent the closure from seeing different data than
                    // intended.
                    var envColor = gl_matrix_13.vec4.clone(this.envColor);
                    var primColor = gl_matrix_13.vec4.clone(this.primColor);
                    var geometryMode = this.geometryMode;
                    var otherModeL = this.otherModeL;
                    var otherModeH = this.otherModeH;
                    var progParams = {
                        use2Cycle: (extractBits(otherModeH, OtherModeH.CYCLETYPE_SFT, OtherModeH.CYCLETYPE_LEN) == CYCLETYPE._2CYCLE),
                        combiners: this.combiners,
                    };
                    // TODO: Don't call getDLProgram if state didn't change, because it can be expensive.
                    var prog = this.getDLProgram(progParams);
                    var alphaTestMode;
                    if (otherModeL & OtherModeL.FORCE_BL) {
                        alphaTestMode = 0;
                    }
                    else {
                        alphaTestMode = ((otherModeL & OtherModeL.CVG_X_ALPHA) ? 0x1 : 0 |
                            (otherModeL & OtherModeL.ALPHA_CVG_SEL) ? 0x2 : 0);
                    }
                    flushTexture(this);
                    var textures = [];
                    // TODO: handle tiles other than 0 and 1 if needed?
                    if (this.textureTiles[0] && this.textureTiles[0].addr != 0)
                        textures[0] = Object.assign({}, this.textureTiles[0]);
                    if (this.textureTiles[1] && this.textureTiles[1].addr != 0)
                        textures[1] = Object.assign({}, this.textureTiles[1]);
                    this.cmds.push(function (renderState) {
                        var gl = renderState.gl;
                        renderState.useProgram(prog);
                        renderState.bindModelView();
                        gl.uniform1i(prog.texture0Location, 0);
                        gl.uniform1i(prog.texture1Location, 1);
                        gl.uniform4fv(prog.envLocation, envColor);
                        gl.uniform4fv(prog.primLocation, primColor);
                        for (var i = 0; i < 2; i++) {
                            gl.activeTexture(gl.TEXTURE0 + i);
                            if (textures[i]) {
                                gl.bindTexture(gl.TEXTURE_2D, textures[i].glTextureId);
                                gl.uniform2fv(prog.txsLocation[i], [1 / textures[i].width, 1 / textures[i].height]);
                            }
                            else {
                                gl.bindTexture(gl.TEXTURE_2D, null);
                                gl.uniform2fv(prog.txsLocation[i], [1, 1]);
                            }
                        }
                        gl.activeTexture(gl.TEXTURE0);
                        var lighting = !!(geometryMode & GeometryMode.LIGHTING);
                        // When lighting is disabled, the vertex colors are passed to the rasterizer as the SHADE attribute.
                        // When lighting is enabled, the vertex colors represent normals and SHADE is computed by the RSP.
                        var useVertexColors = lighting ? 0 : 1;
                        gl.uniform1i(prog.useVertexColorsLocation, useVertexColors);
                        gl.uniform1i(prog.alphaTestLocation, alphaTestMode);
                    });
                };
                return State;
            }());
            // 3 pos + 2 uv + 4 color/nrm
            VERTEX_SIZE = 9;
            VERTEX_BYTES = VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT;
            GeometryMode = {
                CULL_FRONT: 0x0200,
                CULL_BACK: 0x0400,
                LIGHTING: 0x020000,
            };
            OtherModeL = {
                Z_CMP: 0x0010,
                Z_UPD: 0x0020,
                ZMODE_DEC: 0x0C00,
                CVG_X_ALPHA: 0x1000,
                ALPHA_CVG_SEL: 0x2000,
                FORCE_BL: 0x4000,
            };
            // XXX: This is global to cut down on resources between DLs.
            tileCache = new Map();
            CommandDispatch = {};
            CommandDispatch[1 /* VTX */] = cmd_VTX;
            CommandDispatch[5 /* TRI1 */] = cmd_TRI1;
            CommandDispatch[6 /* TRI2 */] = cmd_TRI2;
            CommandDispatch[217 /* GEOMETRYMODE */] = cmd_GEOMETRYMODE;
            CommandDispatch[222 /* DL */] = cmd_DL;
            CommandDispatch[218 /* MTX */] = cmd_MTX;
            CommandDispatch[216 /* POPMTX */] = cmd_POPMTX;
            CommandDispatch[226 /* SETOTHERMODE_L */] = cmd_SETOTHERMODE_L;
            CommandDispatch[227 /* SETOTHERMODE_H */] = cmd_SETOTHERMODE_H;
            CommandDispatch[240 /* LOADTLUT */] = cmd_LOADTLUT;
            CommandDispatch[215 /* TEXTURE */] = cmd_TEXTURE;
            CommandDispatch[252 /* SETCOMBINE */] = cmd_SETCOMBINE;
            CommandDispatch[251 /* SETENVCOLOR */] = cmd_SETENVCOLOR;
            CommandDispatch[249 /* SETPRIMCOLOR */] = cmd_SETPRIMCOLOR;
            CommandDispatch[253 /* SETTIMG */] = cmd_SETTIMG;
            CommandDispatch[245 /* SETTILE */] = cmd_SETTILE;
            CommandDispatch[242 /* SETTILESIZE */] = cmd_SETTILESIZE;
            F3DEX2 = {};
            DL = /** @class */ (function () {
                function DL(vao, cmds, textures) {
                    this.vao = vao;
                    this.cmds = cmds;
                    this.textures = textures;
                }
                DL.prototype.render = function (renderState) {
                    var gl = renderState.gl;
                    gl.bindVertexArray(this.vao);
                    this.cmds.forEach(function (cmd) {
                        cmd(renderState);
                    });
                    gl.bindVertexArray(null);
                };
                return DL;
            }());
            exports_49("DL", DL);
        }
    };
});
System.register("zelview/render", ["zelview/zelview0", "render", "Program", "util"], function (exports_50, context_50) {
    "use strict";
    var __moduleName = context_50 && context_50.id;
    function ccUsesTexel0(c) {
        return c.subA == 1 || c.subB == 1 || c.mul == 1 || c.mul == 8 || c.add == 1;
    }
    function acUsesTexel0(c) {
        return c.subA == 1 || c.subB == 1 || c.mul == 1 || c.add == 1;
    }
    function ccUsesTexel1(c) {
        return c.subA == 2 || c.subB == 2 || c.mul == 2 || c.mul == 9 || c.add == 2;
    }
    function acUsesTexel1(c) {
        return c.subA == 2 || c.subB == 2 || c.mul == 2 || c.add == 2;
    }
    function getOrDefault(obj, key, def) {
        var result = obj[key];
        return (result === undefined) ? def : result;
    }
    function hashF3DEX2Params(params) {
        return JSON.stringify(params); // TODO: use a more efficient hash mechanism
    }
    exports_50("hashF3DEX2Params", hashF3DEX2Params);
    var ZELVIEW0, render_19, Program_8, util_28, BillboardBGProgram, F3DEX2_FRAG_BASE, CC_SUBA, CC_SUBB, CC_MUL, CC_ADD, AC_ADDSUB, AC_MUL, F3DEX2Program, CollisionProgram, WaterboxProgram, Scene, SceneDesc;
    return {
        setters: [
            function (ZELVIEW0_1) {
                ZELVIEW0 = ZELVIEW0_1;
            },
            function (render_19_1) {
                render_19 = render_19_1;
            },
            function (Program_8_1) {
                Program_8 = Program_8_1;
            },
            function (util_28_1) {
                util_28 = util_28_1;
            }
        ],
        execute: function () {
            BillboardBGProgram = /** @class */ (function (_super) {
                __extends(BillboardBGProgram, _super);
                function BillboardBGProgram() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.vert = "\nattribute vec3 a_position;\nattribute vec2 a_uv;\nvarying vec2 v_uv;\n\nvoid main() {\n    gl_Position = vec4(a_position, 1.0);\n    v_uv = a_uv;\n}\n";
                    _this.frag = "\nprecision mediump float;\nvarying vec2 v_uv;\nuniform sampler2D u_texture;\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_uv);\n}\n";
                    return _this;
                }
                BillboardBGProgram.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.positionLocation = gl.getAttribLocation(prog, "a_position");
                    this.uvLocation = gl.getAttribLocation(prog, "a_uv");
                };
                return BillboardBGProgram;
            }(Program_8.default));
            exports_50("BillboardBGProgram", BillboardBGProgram);
            F3DEX2_FRAG_BASE = "\nprecision mediump float;\nvarying vec2 v_uv;\nvarying vec4 v_shade;\nuniform vec4 u_env;\nuniform vec4 u_prim;\nuniform sampler2D u_texture0;\nuniform sampler2D u_texture1;\nuniform bool u_useVertexColors;\nuniform int u_alphaTest;\n\nvec4 n64Texture2D(sampler2D tex, vec2 texCoord) {\n    vec2 texSize = vec2(textureSize(tex, 0));\n    vec2 offset = fract(texCoord * texSize - 0.5);\n    offset -= step(1.0, offset.x + offset.y);\n    vec4 c0 = texture2D(tex, texCoord - offset / texSize, 0.0);\n    vec4 c1 = texture2D(tex, texCoord - vec2(offset.x - sign(offset.x), offset.y) / texSize, 0.0);\n    vec4 c2 = texture2D(tex, texCoord - vec2(offset.x, offset.y - sign(offset.y)) / texSize, 0.0);\n    return c0 + abs(offset.x) * (c1 - c0) + abs(offset.y) * (c2 - c0);\t\t\n}\n\nvoid main() {\n#if USE_2CYCLE && CC1_USES_T1\n    // 2-cycle, complete\n    vec4 t00 = n64Texture2D(u_texture0, v_uv);\n    vec4 t10 = n64Texture2D(u_texture1, v_uv);\n    vec4 t01 = t00; // ???\n    vec4 t11 = t10; // ???\n#elif USE_2CYCLE && (CC0_USES_T1 || CC1_USES_T0)\n    // 2-cycle, no texel-next?\n    vec4 t00 = n64Texture2D(u_texture0, v_uv);\n    vec4 t10 = n64Texture2D(u_texture1, v_uv);\n    vec4 t01 = n64Texture2D(u_texture0, v_uv); // ???\n    vec4 t11 = n64Texture2D(u_texture1, v_uv); // ???\n#elif USE_2CYCLE && (CC0_USES_T0 || CC0_USES_LOD_FRAC || CC1_USES_LOD_FRAC)\n    // 2-cycle, no texel 1\n    vec4 t00 = n64Texture2D(u_texture0, v_uv);\n    vec4 t10 = vec4(0.0);\n    vec4 t01 = t00; // ???\n    vec4 t11 = t10; // ???\n#elif USE_2CYCLE\n    vec4 t00 = vec4(0.0);\n    vec4 t10 = vec4(0.0);\n    vec4 t01 = vec4(0.0);\n    vec4 t11 = vec4(0.0);\n#else\n    #error TODO: handle 1-cycle\n#endif\n\n    vec4 shade = v_shade;\n    if (!u_useVertexColors) {\n        shade = vec4(1.0);\n    }\n\n    vec4 combined = shade;\n    vec4 t0;\n    vec4 t1;\n#if USE_2CYCLE\n    t0 = t00;\n    t1 = t10;\n    combined = vec4(\n        (CC0_SUBA - CC0_SUBB) * CC0_MUL + CC0_ADD,\n        (AC0_SUBA - AC0_SUBB) * AC0_MUL + AC0_ADD\n    );\n#endif\n    t0 = t01;\n    t1 = t11;\n    combined = vec4(\n        (CC1_SUBA - CC1_SUBB) * CC1_MUL + CC1_ADD,\n        (AC1_SUBA - AC1_SUBB) * AC1_MUL + AC1_ADD\n    );\n\n    gl_FragColor = combined;\n\n    if (u_alphaTest > 0 && gl_FragColor.a < 0.0125)\n        discard;\n}\n";
            CC_SUBA = {
                0: "combined.rgb",
                1: "t0.rgb",
                2: "t1.rgb",
                3: "u_prim.rgb",
                4: "shade.rgb",
                5: "u_env.rgb",
                6: "vec3(1.0)",
                7: "vec3(0.5)",
            };
            CC_SUBB = {
                0: "combined.rgb",
                1: "t0.rgb",
                2: "t1.rgb",
                3: "u_prim.rgb",
                4: "shade.rgb",
                5: "u_env.rgb",
                6: "vec3(0.0)",
                7: "vec3(0.5)",
            };
            CC_MUL = {
                0: "combined.rgb",
                1: "t0.rgb",
                2: "t1.rgb",
                3: "u_prim.rgb",
                4: "shade.rgb",
                5: "u_env.rgb",
                6: "vec3(1.0)",
                7: "combined.aaa",
                8: "t0.aaa",
                9: "t1.aaa",
                10: "u_prim.aaa",
                11: "shade.aaa",
                12: "u_env.aaa",
                13: "vec3(1.0)",
                14: "vec3(1.0)",
                15: "vec3(0.5)",
            };
            CC_ADD = {
                0: "combined.rgb",
                1: "t0.rgb",
                2: "t1.rgb",
                3: "u_prim.rgb",
                4: "shade.rgb",
                5: "u_env.rgb",
                6: "vec3(1.0)",
            };
            AC_ADDSUB = {
                0: "combined.a",
                1: "t0.a",
                2: "t1.a",
                3: "u_prim.a",
                4: "shade.a",
                5: "u_env.a",
                6: "1.0",
            };
            AC_MUL = {
                0: "1.0",
                1: "t0.a",
                2: "t1.a",
                3: "u_prim.a",
                4: "shade.a",
                5: "u_env.a",
                6: "1.0",
            };
            F3DEX2Program = /** @class */ (function (_super) {
                __extends(F3DEX2Program, _super);
                function F3DEX2Program(params) {
                    var _this = _super.call(this) || this;
                    _this.vert = "\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nlayout(location = " + F3DEX2Program.a_Position + ") attribute vec3 a_Position;\nlayout(location = " + F3DEX2Program.a_UV + ") attribute vec2 a_UV;\nlayout(location = " + F3DEX2Program.a_Shade + ") attribute vec4 a_Shade;\nout vec4 v_shade;\nout vec2 v_uv;\nuniform vec2 u_txs[2];\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_Position, 1.0);\n    v_uv = a_UV * u_txs[0]; // ??? Is there a second set of texcoords?\n    v_shade = a_Shade;\n}\n";
                    _this.frag = "\n#error Shader was not properly constructed.\n";
                    _this.frag = "#define USE_2CYCLE " + (params.use2Cycle ? 1 : 0) + "\n";
                    for (var i = 0; i < 2; i++) {
                        var usesT0 = ccUsesTexel0(params.combiners.colorCombiners[i]) || acUsesTexel0(params.combiners.alphaCombiners[i]);
                        var usesT1 = ccUsesTexel1(params.combiners.colorCombiners[i]) || acUsesTexel1(params.combiners.alphaCombiners[i]);
                        var usesLodFrac = params.combiners.colorCombiners[i].mul == 13 || params.combiners.alphaCombiners[i].mul == 0;
                        _this.frag += "\n#define CC" + i + "_USES_T0 " + (usesT0 ? 1 : 0) + "\n#define CC" + i + "_USES_T1 " + (usesT1 ? 1 : 0) + "\n#define CC" + i + "_USES_LOD_FRAC " + (usesLodFrac ? 1 : 0) + "\n#define CC" + i + "_SUBA " + getOrDefault(CC_SUBA, params.combiners.colorCombiners[i].subA, 'vec3(0.0)') + "\n#define CC" + i + "_SUBB " + getOrDefault(CC_SUBB, params.combiners.colorCombiners[i].subB, 'vec3(0.0)') + "\n#define CC" + i + "_MUL " + getOrDefault(CC_MUL, params.combiners.colorCombiners[i].mul, 'vec3(0.0)') + "\n#define CC" + i + "_ADD " + getOrDefault(CC_ADD, params.combiners.colorCombiners[i].add, 'vec3(0.0)') + "\n#define AC" + i + "_SUBA " + getOrDefault(AC_ADDSUB, params.combiners.alphaCombiners[i].subA, '0.0') + "\n#define AC" + i + "_SUBB " + getOrDefault(AC_ADDSUB, params.combiners.alphaCombiners[i].subB, '0.0') + "\n#define AC" + i + "_MUL " + getOrDefault(AC_MUL, params.combiners.alphaCombiners[i].mul, '0.0') + "\n#define AC" + i + "_ADD " + getOrDefault(AC_ADDSUB, params.combiners.alphaCombiners[i].add, '0.0') + "\n";
                    }
                    _this.frag += F3DEX2_FRAG_BASE;
                    return _this;
                }
                F3DEX2Program.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.texture0Location = gl.getUniformLocation(prog, "u_texture0");
                    this.texture1Location = gl.getUniformLocation(prog, "u_texture1");
                    this.txsLocation = [];
                    this.txsLocation[0] = gl.getUniformLocation(prog, "u_txs[0]");
                    this.txsLocation[1] = gl.getUniformLocation(prog, "u_txs[1]");
                    this.envLocation = gl.getUniformLocation(prog, "u_env");
                    this.primLocation = gl.getUniformLocation(prog, "u_prim");
                    this.useVertexColorsLocation = gl.getUniformLocation(prog, "u_useVertexColors");
                    this.alphaTestLocation = gl.getUniformLocation(prog, "u_alphaTest");
                };
                F3DEX2Program.a_Position = 0;
                F3DEX2Program.a_UV = 1;
                F3DEX2Program.a_Shade = 2;
                return F3DEX2Program;
            }(Program_8.default));
            exports_50("F3DEX2Program", F3DEX2Program);
            CollisionProgram = /** @class */ (function (_super) {
                __extends(CollisionProgram, _super);
                function CollisionProgram() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.vert = "\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nattribute vec3 a_position;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_position, 1.0);\n}\n";
                    _this.frag = "\n#extension GL_EXT_frag_depth : enable\n\nvoid main() {\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 0.2);\n    gl_FragDepthEXT = gl_FragCoord.z - 1e-6;\n}\n";
                    return _this;
                }
                CollisionProgram.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.positionLocation = gl.getAttribLocation(prog, "a_position");
                };
                return CollisionProgram;
            }(Program_8.default));
            WaterboxProgram = /** @class */ (function (_super) {
                __extends(WaterboxProgram, _super);
                function WaterboxProgram() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.vert = "\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nattribute vec3 a_position;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_position, 1.0);\n}\n";
                    _this.frag = "\nvoid main() {\n    gl_FragColor = vec4(0.2, 0.6, 1.0, 0.2);\n}\n";
                    return _this;
                }
                WaterboxProgram.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.positionLocation = gl.getAttribLocation(prog, "a_position");
                };
                return WaterboxProgram;
            }(Program_8.default));
            Scene = /** @class */ (function () {
                function Scene(gl, zelview0) {
                    var _this = this;
                    this.zelview0 = zelview0;
                    this.textures = [];
                    this.program_BG = new BillboardBGProgram();
                    this.program_COLL = new CollisionProgram();
                    this.program_WATERS = new WaterboxProgram();
                    var mainScene = zelview0.loadMainScene(gl);
                    mainScene.rooms.forEach(function (room) {
                        _this.textures = _this.textures.concat(room.mesh.textures);
                    });
                    var renderScene = this.translateScene(gl, mainScene);
                    var renderCollision = this.translateCollision(gl, mainScene);
                    var renderWaterBoxes = this.translateWaterBoxes(gl, mainScene);
                    this.render = function (state) {
                        renderScene(state);
                        //renderCollision(state);
                        renderWaterBoxes(state);
                    };
                }
                Scene.prototype.translateScene = function (gl, scene) {
                    var _this = this;
                    return function (state) {
                        var gl = state.gl;
                        var renderDL = function (dl) {
                            dl.render(state);
                        };
                        var renderMesh = function (mesh) {
                            if (mesh.bg) {
                                state.useProgram(_this.program_BG);
                                state.bindModelView();
                                mesh.bg(state);
                            }
                            mesh.opaque.forEach(renderDL);
                            mesh.transparent.forEach(renderDL);
                        };
                        var renderRoom = function (room) {
                            renderMesh(room.mesh);
                        };
                        scene.rooms.forEach(function (room) { return renderRoom(room); });
                    };
                };
                Scene.prototype.translateCollision = function (gl, scene) {
                    var _this = this;
                    var coll = scene.collision;
                    function stitchLines(ibd) {
                        var lines = new Uint16Array(ibd.length * 2);
                        var o = 0;
                        for (var i = 0; i < ibd.length; i += 3) {
                            lines[o++] = ibd[i + 0];
                            lines[o++] = ibd[i + 1];
                            lines[o++] = ibd[i + 1];
                            lines[o++] = ibd[i + 2];
                            lines[o++] = ibd[i + 2];
                            lines[o++] = ibd[i + 0];
                        }
                        return lines;
                    }
                    var collIdxBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, collIdxBuffer);
                    var lineData = stitchLines(coll.polys);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, lineData, gl.STATIC_DRAW);
                    var nLinePrim = lineData.length;
                    var collVertBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, collVertBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, coll.verts, gl.STATIC_DRAW);
                    var renderFlags = new render_19.RenderFlags();
                    renderFlags.depthTest = true;
                    renderFlags.blendMode = render_19.BlendMode.ADD;
                    return function (state) {
                        var prog = _this.program_COLL;
                        state.useProgram(prog);
                        state.bindModelView();
                        state.useFlags(renderFlags);
                        gl.bindBuffer(gl.ARRAY_BUFFER, collVertBuffer);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, collIdxBuffer);
                        gl.vertexAttribPointer(prog.positionLocation, 3, gl.SHORT, false, 0, 0);
                        gl.enableVertexAttribArray(prog.positionLocation);
                        gl.drawElements(gl.LINES, nLinePrim, gl.UNSIGNED_SHORT, 0);
                        gl.disableVertexAttribArray(prog.positionLocation);
                    };
                };
                Scene.prototype.translateWaterBoxes = function (gl, scene) {
                    var _this = this;
                    var coll = scene.collision;
                    var wbVtx = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, wbVtx);
                    gl.bufferData(gl.ARRAY_BUFFER, coll.waters, gl.STATIC_DRAW);
                    var wbIdxData = new Uint16Array(coll.waters.length / 3);
                    for (var i = 0; i < wbIdxData.length; i++)
                        wbIdxData[i] = i;
                    var wbIdx = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wbIdx);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, wbIdxData, gl.STATIC_DRAW);
                    var renderFlags = new render_19.RenderFlags();
                    renderFlags.blendMode = render_19.BlendMode.ADD;
                    renderFlags.cullMode = render_19.CullMode.NONE;
                    return function (state) {
                        var prog = _this.program_WATERS;
                        state.useProgram(prog);
                        state.bindModelView();
                        state.useFlags(renderFlags);
                        gl.bindBuffer(gl.ARRAY_BUFFER, wbVtx);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wbIdx);
                        gl.vertexAttribPointer(prog.positionLocation, 3, gl.SHORT, false, 0, 0);
                        gl.enableVertexAttribArray(prog.positionLocation);
                        for (var i = 0; i < wbIdxData.length; i += 4)
                            gl.drawElements(gl.TRIANGLE_STRIP, 4, gl.UNSIGNED_SHORT, i * 2);
                        gl.disableVertexAttribArray(prog.positionLocation);
                    };
                };
                Scene.prototype.destroy = function (gl) {
                    // TODO(jstpierre): Implement destroy for zelview.
                };
                return Scene;
            }());
            SceneDesc = /** @class */ (function () {
                function SceneDesc(name, path) {
                    this.name = name;
                    this.path = path;
                    this.id = this.path;
                }
                SceneDesc.prototype.createScene = function (gl) {
                    return util_28.fetch(this.path).then(function (result) {
                        var zelview0 = ZELVIEW0.readZELVIEW0(result);
                        return new Scene(gl, zelview0);
                    });
                };
                return SceneDesc;
            }());
            exports_50("SceneDesc", SceneDesc);
        }
    };
});
System.register("zelview/scenes", ["zelview/render"], function (exports_51, context_51) {
    "use strict";
    var __moduleName = context_51 && context_51.id;
    var render_20, id, name, sceneDescs, sceneGroup;
    return {
        setters: [
            function (render_20_1) {
                render_20 = render_20_1;
            }
        ],
        execute: function () {
            id = "zelview";
            name = "Ocarina of Time";
            sceneDescs = [
                {
                    filename: "ydan_scene",
                    label: "Inside the Deku Tree",
                },
                {
                    filename: "ddan_scene",
                    label: "Dodongo's Cavern",
                },
                {
                    filename: "bdan_scene",
                    label: "Inside Jabu-Jabu's Belly",
                },
                {
                    filename: "Bmori1_scene",
                    label: "Forest Temple",
                },
                {
                    filename: "HIDAN_scene",
                    label: "Fire Temple",
                },
                {
                    filename: "MIZUsin_scene",
                    label: "Water Temple",
                },
                {
                    filename: "jyasinzou_scene",
                    label: "Spirit Temple",
                },
                {
                    filename: "HAKAdan_scene",
                    label: "Shadow Temple",
                },
                {
                    filename: "HAKAdanCH_scene",
                    label: "Bottom of the Well",
                },
                {
                    filename: "ice_doukutu_scene",
                    label: "Ice Cavern",
                },
                {
                    filename: "ganon_scene",
                    label: "Ganon's Castle Tower",
                },
                {
                    filename: "men_scene",
                    label: "Gerudo Training Grounds",
                },
                {
                    filename: "gerudoway_scene",
                    label: "Thieves' Hideout",
                },
                {
                    filename: "ganontika_scene",
                    label: "Ganon's Castle",
                },
                {
                    filename: "ganon_sonogo_scene",
                    label: "Ganon's Castle Tower (Crumbling)",
                },
                {
                    filename: "ganontikasonogo_scene",
                    label: "Ganon's Castle (Crumbling)",
                },
                {
                    filename: "takaraya_scene",
                    label: "Treasure Chest Contest",
                },
                {
                    filename: "ydan_boss_scene",
                    label: "Inside the Deku Tree (Boss)",
                },
                {
                    filename: "ddan_boss_scene",
                    label: "Dodongo's Cavern (Boss)",
                },
                {
                    filename: "bdan_boss_scene",
                    label: "Inside Jabu-Jabu's Belly (Boss)",
                },
                {
                    filename: "moribossroom_scene",
                    label: "Forest Temple (Boss)",
                },
                {
                    filename: "FIRE_bs_scene",
                    label: "Fire Temple (Boss)",
                },
                {
                    filename: "MIZUsin_bs_scene",
                    label: "Water Temple (Boss)",
                },
                {
                    filename: "jyasinboss_scene",
                    label: "Spirit Temple (Mid-Boss)",
                },
                {
                    filename: "HAKAdan_bs_scene",
                    label: "Shadow Temple (Boss)",
                },
                {
                    filename: "ganon_boss_scene",
                    label: "Second-To-Last Boss Ganondorf",
                },
                {
                    filename: "ganon_final_scene",
                    label: "Ganondorf, Death Scene",
                },
                {
                    filename: "entra_scene",
                    label: "Market Entrance (Day)",
                },
                {
                    filename: "entra_n_scene",
                    label: "Market Entrance (Night)",
                },
                {
                    filename: "enrui_scene",
                    label: "Market Entrance (Adult)",
                },
                {
                    filename: "market_alley_scene",
                    label: "Back Alley (Day)",
                },
                {
                    filename: "market_alley_n_scene",
                    label: "Back Alley (Night)",
                },
                {
                    filename: "market_day_scene",
                    label: "Market (Day)",
                },
                {
                    filename: "market_night_scene",
                    label: "Market (Night)",
                },
                {
                    filename: "market_ruins_scene",
                    label: "Market (Adult)",
                },
                {
                    filename: "shrine_scene",
                    label: "Temple of Time (Outside, Day)",
                },
                {
                    filename: "shrine_n_scene",
                    label: "Temple of Time (Outside, Night)",
                },
                {
                    filename: "shrine_r_scene",
                    label: "Temple of Time (Outside, Adult)",
                },
                {
                    filename: "kokiri_home_scene",
                    label: "Know-it-all Brothers",
                },
                {
                    filename: "kokiri_home3_scene",
                    label: "House of Twins",
                },
                {
                    filename: "kokiri_home4_scene",
                    label: "Mido's House",
                },
                {
                    filename: "kokiri_home5_scene",
                    label: "Saria's House",
                },
                {
                    filename: "kakariko_scene",
                    label: "Kakariko Village House",
                },
                {
                    filename: "kakariko3_scene",
                    label: "Back Alley Village House",
                },
                {
                    filename: "shop1_scene",
                    label: "Kakariko Bazaar",
                },
                {
                    filename: "kokiri_shop_scene",
                    label: "Kokiri Shop",
                },
                {
                    filename: "golon_scene",
                    label: "Goron Shop",
                },
                {
                    filename: "zoora_scene",
                    label: "Zora Shop",
                },
                {
                    filename: "drag_scene",
                    label: "Kakariko Potion Shop",
                },
                {
                    filename: "alley_shop_scene",
                    label: "Market Potion Shop",
                },
                {
                    filename: "night_shop_scene",
                    label: "Bombchu Shop",
                },
                {
                    filename: "face_shop_scene",
                    label: "Happy Mask Shop",
                },
                {
                    filename: "link_home_scene",
                    label: "Link's House",
                },
                {
                    filename: "impa_scene",
                    label: "Puppy Woman's House",
                },
                {
                    filename: "malon_stable_scene",
                    label: "Stables",
                },
                {
                    filename: "labo_scene",
                    label: "Impa's House",
                },
                {
                    filename: "hylia_labo_scene",
                    label: "Lakeside Laboratory",
                },
                {
                    filename: "tent_scene",
                    label: "Carpenter's Tent",
                },
                {
                    filename: "hut_scene",
                    label: "Damp's Hut",
                },
                {
                    filename: "daiyousei_izumi_scene",
                    label: "Great Fairy Fountain",
                },
                {
                    filename: "yousei_izumi_tate_scene",
                    label: "Small Fairy Fountain",
                },
                {
                    filename: "yousei_izumi_yoko_scene",
                    label: "Magic Fairy Fountain",
                },
                {
                    filename: "kakusiana_scene",
                    label: "Grottos",
                },
                {
                    filename: "hakaana_scene",
                    label: "Grave (1)",
                },
                {
                    filename: "hakaana2_scene",
                    label: "Grave (2)",
                },
                {
                    filename: "hakaana_ouke_scene",
                    label: "Royal Family's Tomb",
                },
                {
                    filename: "syatekijyou_scene",
                    label: "Shooting Gallery",
                },
                {
                    filename: "tokinoma_scene",
                    label: "Temple of Time Inside",
                },
                {
                    filename: "kenjyanoma_scene",
                    label: "Chamber of Sages",
                },
                {
                    filename: "hairal_niwa_scene",
                    label: "Castle Courtyard (Day)",
                },
                {
                    filename: "hairal_niwa_n_scene",
                    label: "Castle Courtyard (Night)",
                },
                {
                    filename: "hiral_demo_scene",
                    label: "Cutscene Map",
                },
                {
                    filename: "hakasitarelay_scene",
                    label: "Damp's Grave & Kakariko Windmill",
                },
                {
                    filename: "turibori_scene",
                    label: "Fishing Pond",
                },
                {
                    filename: "nakaniwa_scene",
                    label: "Zelda's Courtyard",
                },
                {
                    filename: "bowling_scene",
                    label: "Bombchu Bowling Alley",
                },
                {
                    filename: "souko_scene",
                    label: "Talon's House",
                },
                {
                    filename: "miharigoya_scene",
                    label: "Lots'o Pots",
                },
                {
                    filename: "mahouya_scene",
                    label: "Granny's Potion Shop",
                },
                {
                    filename: "ganon_demo_scene",
                    label: "Final Battle against Ganon",
                },
                {
                    filename: "kinsuta_scene",
                    label: "Skulltula House",
                },
                {
                    filename: "spot00_scene",
                    label: "Hyrule Field",
                },
                {
                    filename: "spot01_scene",
                    label: "Kakariko Village",
                },
                {
                    filename: "spot02_scene",
                    label: "Kakariko Graveyard",
                },
                {
                    filename: "spot03_scene",
                    label: "Zora's River",
                },
                {
                    filename: "spot04_scene",
                    label: "Kokiri Forest",
                },
                {
                    filename: "spot05_scene",
                    label: "Sacred Forest Meadow",
                },
                {
                    filename: "spot06_scene",
                    label: "Lake Hylia",
                },
                {
                    filename: "spot07_scene",
                    label: "Zora's Domain",
                },
                {
                    filename: "spot08_scene",
                    label: "Zora's Fountain",
                },
                {
                    filename: "spot09_scene",
                    label: "Gerudo Valley",
                },
                {
                    filename: "spot10_scene",
                    label: "Lost Woods",
                },
                {
                    filename: "spot11_scene",
                    label: "Desert Colossus",
                },
                {
                    filename: "spot12_scene",
                    label: "Gerudo's Fortress",
                },
                {
                    filename: "spot13_scene",
                    label: "Haunted Wasteland",
                },
                {
                    filename: "spot15_scene",
                    label: "Hyrule Castle",
                },
                {
                    filename: "spot16_scene",
                    label: "Death Mountain",
                },
                {
                    filename: "spot17_scene",
                    label: "Death Mountain Crater",
                },
                {
                    filename: "spot18_scene",
                    label: "Goron City",
                },
                {
                    filename: "spot20_scene",
                    label: "Lon Lon Ranch",
                },
                {
                    filename: "ganon_tou_scene",
                    label: "Ganon's Tower (Outside)",
                },
                {
                    filename: "test01_scene",
                    label: "Collision Testing Area",
                },
                {
                    filename: "besitu_scene",
                    label: "Besitu / Treasure Chest Warp",
                },
                {
                    filename: "depth_test_scene",
                    label: "Depth Test",
                },
                {
                    filename: "syotes_scene",
                    label: "Stalfos Middle Room",
                },
                {
                    filename: "syotes2_scene",
                    label: "Stalfos Boss Room",
                },
                {
                    filename: "sutaru_scene",
                    label: "Dark Link Testing Area",
                },
                {
                    filename: "hairal_niwa2_scene",
                    label: "Beta Castle Courtyard",
                },
                {
                    filename: "sasatest_scene",
                    label: "Action Testing Room",
                },
                {
                    filename: "testroom_scene",
                    label: "Item Testing Room",
                },
            ].map(function (entry) {
                var path = "data/zelview/" + entry.filename + ".zelview0";
                return new render_20.SceneDesc(entry.label, path);
            });
            exports_51("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
System.register("oot3d/cmb", ["util"], function (exports_52, context_52) {
    "use strict";
    var __moduleName = context_52 && context_52.id;
    function readMatsChunk(cmb, buffer) {
        var view = buffer.createDataView();
        util_29.assert(util_29.readString(buffer, 0x00, 0x04) === 'mats');
        var count = view.getUint32(0x08, true);
        var offs = 0x0C;
        for (var i = 0; i < count; i++) {
            var mat = new Material();
            var bindingOffs = offs + 0x10;
            for (var j = 0; j < 3; j++) {
                var binding = new TextureBinding();
                binding.textureIdx = view.getInt16(bindingOffs + 0x00, true);
                binding.minFilter = view.getUint16(bindingOffs + 0x04, true);
                binding.magFilter = view.getUint16(bindingOffs + 0x06, true);
                binding.wrapS = view.getUint16(bindingOffs + 0x08, true);
                binding.wrapT = view.getUint16(bindingOffs + 0x0A, true);
                mat.textureBindings.push(binding);
                bindingOffs += 0x18;
            }
            mat.alphaTestEnable = !!view.getUint8(offs + 0x130);
            cmb.materials.push(mat);
            offs += 0x15C;
        }
    }
    function expand4to8(n) {
        return (n << 4) | n;
    }
    function expand5to8(n) {
        return (n << (8 - 5)) | (n >>> (10 - 8));
    }
    function expand6to8(n) {
        return (n << (8 - 6)) | (n >>> (12 - 8));
    }
    function decodeTexture_ETC1_4x4_Color(dst, w1, w2, dstOffs, stride) {
        // w1 = Upper 32-bit word, "control" data
        // w2 = Lower 32-bit word, "pixel" data
        // Table 3.17.2 -- Intensity tables for each codeword.
        var intensityTableMap = [
            [-8, -2, 2, 8],
            [-17, -5, 5, 17],
            [-29, -9, 9, 29],
            [-42, -13, 13, 42],
            [-60, -18, 18, 60],
            [-80, -24, 24, 80],
            [-106, -33, 33, 106],
            [-183, -47, 48, 183],
        ];
        // Table 3.17.3 -- MSB/LSB colors to modifiers.
        //
        //  msb lsb
        //  --- ---
        //   0  0   small positive value (2nd intensity)
        //   0  1   large positive value (3rd intensity)
        //   1  0   small negative value (1st intensity)
        //   1  1   large negative value (0th intensity)
        //
        // Why the spec doesn't lay out the intensity map in this order,
        // I'll never know...
        var pixelToColorIndex = [2, 3, 1, 0];
        var diff = (w1 & 2);
        var flip = (w1 & 1);
        // Intensity tables for each block.
        var intensityIndex1 = (w1 >> 5) & 0x7;
        var intensityIndex2 = (w1 >> 2) & 0x7;
        var intensityTable1 = intensityTableMap[intensityIndex1];
        var intensityTable2 = intensityTableMap[intensityIndex2];
        function signed3(n) {
            // Sign-extend.
            return n << 29 >> 29;
        }
        function clamp(n) {
            if (n < 0)
                return 0;
            if (n > 255)
                return 255;
            return n;
        }
        // Get the color table for a given block.
        function getColors(colors, r, g, b, intensityMap) {
            for (var i = 0; i < 4; i++) {
                colors[(i * 3) + 0] = clamp(r + intensityMap[i]);
                colors[(i * 3) + 1] = clamp(g + intensityMap[i]);
                colors[(i * 3) + 2] = clamp(b + intensityMap[i]);
            }
        }
        var colors1 = new Uint8Array(3 * 4);
        var colors2 = new Uint8Array(3 * 4);
        if (diff) {
            var baseR1a = (w1 >>> 27) & 0x1F;
            var baseR2d = signed3((w1 >>> 24) & 0x07);
            var baseG1a = (w1 >>> 19) & 0x1F;
            var baseG2d = signed3((w1 >>> 16) & 0x07);
            var baseB1a = (w1 >>> 11) & 0x1F;
            var baseB2d = signed3((w1 >>> 8) & 0x07);
            var baseR1 = expand5to8(baseR1a);
            var baseR2 = expand5to8(baseR1a + baseR2d);
            var baseG1 = expand5to8(baseG1a);
            var baseG2 = expand5to8(baseG1a + baseG2d);
            var baseB1 = expand5to8(baseB1a);
            var baseB2 = expand5to8(baseB1a + baseB2d);
            getColors(colors1, baseR1, baseG1, baseB1, intensityTable1);
            getColors(colors2, baseR2, baseG2, baseB2, intensityTable2);
        }
        else {
            var baseR1 = expand4to8((w1 >>> 28) & 0x0F);
            var baseR2 = expand4to8((w1 >>> 24) & 0x0F);
            var baseG1 = expand4to8((w1 >>> 20) & 0x0F);
            var baseG2 = expand4to8((w1 >>> 16) & 0x0F);
            var baseB1 = expand4to8((w1 >>> 12) & 0x0F);
            var baseB2 = expand4to8((w1 >>> 8) & 0x0F);
            getColors(colors1, baseR1, baseG1, baseB1, intensityTable1);
            getColors(colors2, baseR2, baseG2, baseB2, intensityTable2);
        }
        // Go through each pixel and copy the color into the right spot...
        for (var i = 0; i < 16; i++) {
            var lsb = (w2 >>> i) & 0x01;
            var msb = (w2 >>> (16 + i)) & 0x01;
            var lookup = (msb << 1) | lsb;
            var colorsIndex = pixelToColorIndex[lookup];
            // Indexes march down and to the right here.
            var y = i & 0x03;
            var x = i >> 2;
            var dstIndex = dstOffs + ((y * stride) + x) * 4;
            // Whether we're in block 1 or block 2;
            var whichBlock = void 0;
            // If flipbit=0, the block is divided into two 2x4
            // subblocks side-by-side.
            if (flip === 0)
                whichBlock = x & 2;
            else
                whichBlock = y & 2;
            var colors = whichBlock ? colors2 : colors1;
            dst[dstIndex + 0] = colors[(colorsIndex * 3) + 0];
            dst[dstIndex + 1] = colors[(colorsIndex * 3) + 1];
            dst[dstIndex + 2] = colors[(colorsIndex * 3) + 2];
        }
    }
    function decodeTexture_ETC1_4x4_Alpha(dst, a1, a2, dstOffs, stride) {
        for (var ax = 0; ax < 2; ax++) {
            for (var ay = 0; ay < 4; ay++) {
                var dstIndex = dstOffs + ((ay * stride) + ax) * 4;
                dst[dstIndex + 3] = expand4to8(a2 & 0x0F);
                a2 >>= 4;
            }
        }
        for (var ax = 2; ax < 4; ax++) {
            for (var ay = 0; ay < 4; ay++) {
                var dstIndex = dstOffs + ((ay * stride) + ax) * 4;
                dst[dstIndex + 3] = expand4to8(a1 & 0x0F);
                a1 >>= 4;
            }
        }
    }
    function decodeTexture_ETC1(texture, texData, alpha) {
        var pixels = new Uint8Array(texture.width * texture.height * 4);
        var stride = texture.width;
        var src = texData.createDataView();
        var offs = 0;
        for (var yy = 0; yy < texture.height; yy += 8) {
            for (var xx = 0; xx < texture.width; xx += 8) {
                // Order of each set of 4 blocks: top left, top right, bottom left, bottom right...
                for (var y = 0; y < 8; y += 4) {
                    for (var x = 0; x < 8; x += 4) {
                        var dstOffs = ((yy + y) * stride + (xx + x)) * 4;
                        var a1 = void 0;
                        var a2 = void 0;
                        if (alpha) {
                            // In ETC1A4 mode, we have 8 bytes of per-pixel alpha data preceeding the tile.
                            a2 = src.getUint32(offs + 0x00, true);
                            a1 = src.getUint32(offs + 0x04, true);
                            offs += 0x08;
                        }
                        else {
                            a2 = 0xFFFFFFFF;
                            a1 = 0xFFFFFFFF;
                        }
                        decodeTexture_ETC1_4x4_Alpha(pixels, a1, a2, dstOffs, stride);
                        var w2 = src.getUint32(offs + 0x00, true);
                        var w1 = src.getUint32(offs + 0x04, true);
                        decodeTexture_ETC1_4x4_Color(pixels, w1, w2, dstOffs, stride);
                        offs += 0x08;
                    }
                }
            }
        }
        return pixels;
    }
    function decodeTexture_Tiled(texture, texData, decoder) {
        var pixels = new Uint8Array(texture.width * texture.height * 4);
        var stride = texture.width;
        function morton7(n) {
            // 0a0b0c => 000abc
            return ((n >> 2) & 0x04) | ((n >> 1) & 0x02) | (n & 0x01);
        }
        for (var yy = 0; yy < texture.height; yy += 8) {
            for (var xx = 0; xx < texture.width; xx += 8) {
                // Iterate in Morton order inside each tile.
                for (var i = 0; i < 0x40; i++) {
                    var x = morton7(i);
                    var y = morton7(i >> 1);
                    var dstOffs = ((yy + y) * stride + xx + x) * 4;
                    decoder(pixels, dstOffs);
                }
            }
        }
        return pixels;
    }
    function decodeTexture_RGBA5551(texture, texData) {
        var src = texData.createDataView();
        var srcOffs = 0;
        return decodeTexture_Tiled(texture, texData, function (pixels, dstOffs) {
            var p = src.getUint16(srcOffs, true);
            pixels[dstOffs + 0] = expand5to8((p >> 11) & 0x1F);
            pixels[dstOffs + 1] = expand5to8((p >> 6) & 0x1F);
            pixels[dstOffs + 2] = expand5to8((p >> 1) & 0x1F);
            pixels[dstOffs + 3] = (p & 0x01) ? 0xFF : 0x00;
            srcOffs += 2;
        });
    }
    function decodeTexture_RGB565(texture, texData) {
        var src = texData.createDataView();
        var srcOffs = 0;
        return decodeTexture_Tiled(texture, texData, function (pixels, dstOffs) {
            var p = src.getUint16(srcOffs, true);
            pixels[dstOffs + 0] = expand5to8((p >> 11) & 0x1F);
            pixels[dstOffs + 1] = expand6to8((p >> 5) & 0x3F);
            pixels[dstOffs + 2] = expand5to8(p & 0x1F);
            pixels[dstOffs + 3] = 0xFF;
            srcOffs += 2;
        });
    }
    function decodeTexture_A8(texture, texData) {
        var src = texData.createDataView();
        var srcOffs = 0;
        return decodeTexture_Tiled(texture, texData, function (pixels, dstOffs) {
            var A = src.getUint8(srcOffs++);
            pixels[dstOffs + 0] = 0xFF;
            pixels[dstOffs + 1] = 0xFF;
            pixels[dstOffs + 2] = 0xFF;
            pixels[dstOffs + 3] = A;
        });
    }
    function decodeTexture_L8(texture, texData) {
        var src = texData.createDataView();
        var srcOffs = 0;
        return decodeTexture_Tiled(texture, texData, function (pixels, dstOffs) {
            var L = src.getUint8(srcOffs++);
            pixels[dstOffs + 0] = L;
            pixels[dstOffs + 1] = L;
            pixels[dstOffs + 2] = L;
            pixels[dstOffs + 3] = L;
        });
    }
    function decodeTexture_LA8(texture, texData) {
        var src = texData.createDataView();
        var srcOffs = 0;
        return decodeTexture_Tiled(texture, texData, function (pixels, dstOffs) {
            var L = src.getUint8(srcOffs++);
            var A = src.getUint8(srcOffs++);
            pixels[dstOffs + 0] = L;
            pixels[dstOffs + 1] = L;
            pixels[dstOffs + 2] = L;
            pixels[dstOffs + 3] = A;
        });
    }
    function decodeTexture(texture, texData) {
        switch (texture.format) {
            case TextureFormat.ETC1:
                return decodeTexture_ETC1(texture, texData, false);
            case TextureFormat.ETC1A4:
                return decodeTexture_ETC1(texture, texData, true);
            case TextureFormat.RGBA5551:
                return decodeTexture_RGBA5551(texture, texData);
            case TextureFormat.RGB565:
                return decodeTexture_RGB565(texture, texData);
            case TextureFormat.A8:
                return decodeTexture_A8(texture, texData);
            case TextureFormat.L8:
                return decodeTexture_L8(texture, texData);
            case TextureFormat.LA8:
                return decodeTexture_LA8(texture, texData);
            default:
                throw new Error("Unsupported texture type! " + texture.format);
        }
    }
    function readTexChunk(cmb, buffer, texData) {
        var view = buffer.createDataView();
        util_29.assert(util_29.readString(buffer, 0x00, 0x04) === 'tex ');
        var count = view.getUint32(0x08, true);
        var offs = 0x0C;
        for (var i = 0; i < count; i++) {
            var texture = new Texture();
            var size = view.getUint32(offs + 0x00, true);
            texture.width = view.getUint16(offs + 0x08, true);
            texture.height = view.getUint16(offs + 0x0A, true);
            texture.format = view.getUint32(offs + 0x0C, true);
            var dataOffs = view.getUint32(offs + 0x10, true);
            texture.name = util_29.readString(buffer, offs + 0x14, 0x10);
            texture.name = texture.name + "  (" + texture.format + ")";
            offs += 0x24;
            texture.pixels = decodeTexture(texture, texData.slice(dataOffs, dataOffs + size));
            cmb.textures.push(texture);
        }
    }
    function readVatrChunk(cmb, buffer) {
        var view = buffer.createDataView();
        util_29.assert(util_29.readString(buffer, 0x00, 0x04) === 'vatr');
        cmb.vertexBufferSlices = new VertexBufferSlices();
        var posSize = view.getUint32(0x0C, true);
        var posOffs = view.getUint32(0x10, true);
        cmb.vertexBufferSlices.posBuffer = buffer.slice(posOffs, posOffs + posSize);
        var nrmSize = view.getUint32(0x14, true);
        var nrmOffs = view.getUint32(0x18, true);
        cmb.vertexBufferSlices.nrmBuffer = buffer.slice(nrmOffs, nrmOffs + nrmSize);
        var colSize = view.getUint32(0x1C, true);
        var colOffs = view.getUint32(0x20, true);
        cmb.vertexBufferSlices.colBuffer = buffer.slice(colOffs, colOffs + colSize);
        var txcSize = view.getUint32(0x24, true);
        var txcOffs = view.getUint32(0x28, true);
        cmb.vertexBufferSlices.txcBuffer = buffer.slice(txcOffs, txcOffs + txcSize);
    }
    function readMshsChunk(cmb, buffer) {
        var view = buffer.createDataView();
        util_29.assert(util_29.readString(buffer, 0x00, 0x04) === 'mshs');
        var count = view.getUint32(0x08, true);
        var offs = 0x10;
        for (var i = 0; i < count; i++) {
            var mesh = new Mesh();
            mesh.sepdIdx = view.getUint16(offs, true);
            mesh.matsIdx = view.getUint8(offs + 2);
            cmb.meshs.push(mesh);
            offs += 0x04;
        }
    }
    function readPrmChunk(cmb, buffer) {
        var view = buffer.createDataView();
        util_29.assert(util_29.readString(buffer, 0x00, 0x04) === 'prm ');
        var prm = new Prm();
        prm.indexType = view.getUint32(0x10, true);
        prm.count = view.getUint16(0x14, true);
        prm.offset = view.getUint16(0x16, true);
        return prm;
    }
    function readPrmsChunk(cmb, buffer) {
        var view = buffer.createDataView();
        util_29.assert(util_29.readString(buffer, 0x00, 0x04) === 'prms');
        var prmOffs = view.getUint32(0x14, true);
        return readPrmChunk(cmb, buffer.slice(prmOffs));
    }
    function readSepdChunk(cmb, buffer) {
        var view = buffer.createDataView();
        util_29.assert(util_29.readString(buffer, 0x00, 0x04) === 'sepd');
        var count = view.getUint16(0x08, true);
        var sepd = new Sepd();
        var offs = 0x108;
        for (var i = 0; i < count; i++) {
            var prmsOffs = view.getUint32(offs, true);
            sepd.prms.push(readPrmsChunk(cmb, buffer.slice(prmsOffs)));
            offs += 0x02;
        }
        sepd.posStart = view.getUint32(0x24, true);
        sepd.posScale = view.getFloat32(0x28, true);
        sepd.posType = view.getUint16(0x2C, true);
        sepd.nrmStart = view.getUint32(0x40, true);
        sepd.nrmScale = view.getFloat32(0x44, true);
        sepd.nrmType = view.getUint16(0x48, true);
        sepd.colStart = view.getUint32(0x5C, true);
        sepd.colScale = view.getFloat32(0x60, true);
        sepd.colType = view.getUint16(0x64, true);
        sepd.txcStart = view.getUint32(0x78, true);
        sepd.txcScale = view.getFloat32(0x7C, true);
        sepd.txcType = view.getUint16(0x80, true);
        return sepd;
    }
    function readShpChunk(cmb, buffer) {
        var view = buffer.createDataView();
        util_29.assert(util_29.readString(buffer, 0x00, 0x04) === 'shp ');
        var count = view.getUint32(0x08, true);
        var offs = 0x10;
        for (var i = 0; i < count; i++) {
            var sepdOffs = view.getUint16(offs, true);
            var sepd = readSepdChunk(cmb, buffer.slice(sepdOffs));
            cmb.sepds.push(sepd);
            offs += 0x02;
        }
    }
    function readSklmChunk(cmb, buffer) {
        var view = buffer.createDataView();
        util_29.assert(util_29.readString(buffer, 0x00, 0x04) === 'sklm');
        var mshsChunkOffs = view.getUint32(0x08, true);
        readMshsChunk(cmb, buffer.slice(mshsChunkOffs));
        var shpChunkOffs = view.getUint32(0x0C, true);
        readShpChunk(cmb, buffer.slice(shpChunkOffs));
    }
    function parse(buffer) {
        var view = buffer.createDataView();
        var cmb = new CMB();
        util_29.assert(util_29.readString(buffer, 0x00, 0x04) === 'cmb ');
        var size = view.getUint32(0x04, true);
        cmb.name = util_29.readString(buffer, 0x10, 0x10);
        var matsChunkOffs = view.getUint32(0x28, true);
        readMatsChunk(cmb, buffer.slice(matsChunkOffs));
        var texDataOffs = view.getUint32(0x40, true);
        var texChunkOffs = view.getUint32(0x2C, true);
        readTexChunk(cmb, buffer.slice(texChunkOffs), buffer.slice(texDataOffs));
        var vatrChunkOffs = view.getUint32(0x38, true);
        readVatrChunk(cmb, buffer.slice(vatrChunkOffs));
        var sklmChunkOffs = view.getUint32(0x30, true);
        readSklmChunk(cmb, buffer.slice(sklmChunkOffs));
        var idxDataOffs = view.getUint32(0x3C, true);
        var idxDataCount = view.getUint32(0x20, true);
        cmb.indexBuffer = buffer.slice(idxDataOffs, idxDataOffs + idxDataCount * 2);
        return cmb;
    }
    exports_52("parse", parse);
    var util_29, VertexBufferSlices, CMB, TextureFilter, TextureWrapMode, TextureBinding, Material, TextureFormat, Texture, Mesh, DataType, Prm, Sepd;
    return {
        setters: [
            function (util_29_1) {
                util_29 = util_29_1;
            }
        ],
        execute: function () {
            VertexBufferSlices = /** @class */ (function () {
                function VertexBufferSlices() {
                }
                return VertexBufferSlices;
            }());
            CMB = /** @class */ (function () {
                function CMB() {
                    this.textures = [];
                    this.materials = [];
                    this.sepds = [];
                    this.meshs = [];
                }
                return CMB;
            }());
            exports_52("CMB", CMB);
            (function (TextureFilter) {
                TextureFilter[TextureFilter["NEAREST"] = 9728] = "NEAREST";
                TextureFilter[TextureFilter["LINEAR"] = 9729] = "LINEAR";
                TextureFilter[TextureFilter["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
                TextureFilter[TextureFilter["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
                TextureFilter[TextureFilter["NEAREST_MIPMIP_LINEAR"] = 9986] = "NEAREST_MIPMIP_LINEAR";
                TextureFilter[TextureFilter["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
            })(TextureFilter || (TextureFilter = {}));
            exports_52("TextureFilter", TextureFilter);
            (function (TextureWrapMode) {
                TextureWrapMode[TextureWrapMode["CLAMP"] = 10496] = "CLAMP";
                TextureWrapMode[TextureWrapMode["REPEAT"] = 10497] = "REPEAT";
            })(TextureWrapMode || (TextureWrapMode = {}));
            exports_52("TextureWrapMode", TextureWrapMode);
            TextureBinding = /** @class */ (function () {
                function TextureBinding() {
                }
                return TextureBinding;
            }());
            Material = /** @class */ (function () {
                function Material() {
                    this.textureBindings = [];
                }
                return Material;
            }());
            exports_52("Material", Material);
            (function (TextureFormat) {
                TextureFormat[TextureFormat["ETC1"] = 26458] = "ETC1";
                TextureFormat[TextureFormat["ETC1A4"] = 26459] = "ETC1A4";
                TextureFormat[TextureFormat["RGBA5551"] = 2150917970] = "RGBA5551";
                TextureFormat[TextureFormat["RGB565"] = 2204329812] = "RGB565";
                TextureFormat[TextureFormat["A8"] = 335636310] = "A8";
                TextureFormat[TextureFormat["L8"] = 335636311] = "L8";
                TextureFormat[TextureFormat["LA8"] = 335636312] = "LA8";
            })(TextureFormat || (TextureFormat = {}));
            Texture = /** @class */ (function () {
                function Texture() {
                }
                return Texture;
            }());
            exports_52("Texture", Texture);
            Mesh = /** @class */ (function () {
                function Mesh() {
                }
                return Mesh;
            }());
            exports_52("Mesh", Mesh);
            (function (DataType) {
                DataType[DataType["Byte"] = 5120] = "Byte";
                DataType[DataType["UByte"] = 5121] = "UByte";
                DataType[DataType["Short"] = 5122] = "Short";
                DataType[DataType["UShort"] = 5123] = "UShort";
                DataType[DataType["Int"] = 5124] = "Int";
                DataType[DataType["UInt"] = 5125] = "UInt";
                DataType[DataType["Float"] = 5126] = "Float";
            })(DataType || (DataType = {}));
            exports_52("DataType", DataType);
            Prm = /** @class */ (function () {
                function Prm() {
                }
                return Prm;
            }());
            exports_52("Prm", Prm);
            Sepd = /** @class */ (function () {
                function Sepd() {
                    this.prms = [];
                }
                return Sepd;
            }());
            exports_52("Sepd", Sepd);
        }
    };
});
System.register("oot3d/zsi", ["oot3d/cmb", "util"], function (exports_53, context_53) {
    "use strict";
    var __moduleName = context_53 && context_53.id;
    function readRooms(buffer, nRooms, offs) {
        var rooms = [];
        for (var i = 0; i < nRooms; i++) {
            rooms.push(util_30.readString(buffer, offs, 0x44));
            offs += 0x44;
        }
        return rooms;
    }
    function readMesh(buffer, offs) {
        var mesh = new Mesh();
        var view = buffer.createDataView();
        var hdr = view.getUint32(offs);
        var type = (hdr >> 24);
        var nEntries = (hdr >> 16) & 0xFF;
        var entriesAddr = view.getUint32(offs + 4, true);
        util_30.assert(type === 0x02);
        util_30.assert(nEntries === 0x01);
        var opaqueAddr = view.getUint32(entriesAddr + 0x08, true);
        var transparentAddr = view.getUint32(entriesAddr + 0x0C, true);
        if (opaqueAddr !== 0)
            mesh.opaque = CMB.parse(buffer.slice(opaqueAddr));
        if (transparentAddr !== 0)
            mesh.transparent = CMB.parse(buffer.slice(transparentAddr));
        mesh.textures = [];
        if (mesh.opaque)
            mesh.textures = mesh.textures.concat(mesh.opaque.textures);
        if (mesh.transparent)
            mesh.textures = mesh.textures.concat(mesh.transparent.textures);
        return mesh;
    }
    function readCollision(buffer, offs) {
        var view = buffer.createDataView();
        var waterboxTableCount = view.getUint16(offs + 0x14, true);
        var waterboxTableOffs = view.getUint32(offs + 0x28, true);
        var waterboxes = new Uint16Array(waterboxTableCount * 3 * 4);
        var waterboxTableIdx = waterboxTableOffs;
        for (var i = 0; i < waterboxTableCount; i++) {
            var x = view.getInt16(waterboxTableIdx + 0x00, true);
            var y = view.getInt16(waterboxTableIdx + 0x02, true);
            var z = view.getInt16(waterboxTableIdx + 0x04, true);
            var sx = view.getInt16(waterboxTableIdx + 0x06, true);
            var sz = view.getInt16(waterboxTableIdx + 0x08, true);
            waterboxes[i * 3 * 4 + 0] = x;
            waterboxes[i * 3 * 4 + 1] = y;
            waterboxes[i * 3 * 4 + 2] = z;
            waterboxes[i * 3 * 4 + 3] = x + sx;
            waterboxes[i * 3 * 4 + 4] = y;
            waterboxes[i * 3 * 4 + 5] = z;
            waterboxes[i * 3 * 4 + 6] = x;
            waterboxes[i * 3 * 4 + 7] = y;
            waterboxes[i * 3 * 4 + 8] = z + sz;
            waterboxes[i * 3 * 4 + 9] = x + sx;
            waterboxes[i * 3 * 4 + 10] = y;
            waterboxes[i * 3 * 4 + 11] = z + sz;
            waterboxTableIdx += 0x10;
        }
        return { waterboxes: waterboxes };
    }
    // ZSI headers are a slight modification of the original Z64 headers.
    function readHeaders(buffer) {
        var view = buffer.createDataView();
        var offs = 0;
        var zsi = new ZSI();
        while (true) {
            var cmd1 = view.getUint32(offs, false);
            var cmd2 = view.getUint32(offs + 4, true);
            offs += 8;
            var cmdType = cmd1 >> 24;
            if (cmdType == HeaderCommands.End)
                break;
            switch (cmdType) {
                case HeaderCommands.Rooms:
                    var nRooms = (cmd1 >> 16) & 0xFF;
                    zsi.rooms = readRooms(buffer, nRooms, cmd2);
                    break;
                case HeaderCommands.Mesh:
                    zsi.mesh = readMesh(buffer, cmd2);
                    break;
                case HeaderCommands.Collision:
                    zsi.collision = readCollision(buffer, cmd2);
                    break;
            }
        }
        return zsi;
    }
    function parse(buffer) {
        util_30.assert(util_30.readString(buffer, 0x00, 0x04) === 'ZSI\x01');
        var name = util_30.readString(buffer, 0x04, 0x0C);
        // ZSI header is done. It's that simple! Now for the actual data.
        var headersBuf = buffer.slice(0x10);
        return readHeaders(headersBuf);
    }
    exports_53("parse", parse);
    var CMB, util_30, ZSI, HeaderCommands, Mesh;
    return {
        setters: [
            function (CMB_1) {
                CMB = CMB_1;
            },
            function (util_30_1) {
                util_30 = util_30_1;
            }
        ],
        execute: function () {
            ZSI = /** @class */ (function () {
                function ZSI() {
                }
                return ZSI;
            }());
            exports_53("ZSI", ZSI);
            // Subset of Z64 command types.
            (function (HeaderCommands) {
                HeaderCommands[HeaderCommands["Collision"] = 3] = "Collision";
                HeaderCommands[HeaderCommands["Rooms"] = 4] = "Rooms";
                HeaderCommands[HeaderCommands["Mesh"] = 10] = "Mesh";
                HeaderCommands[HeaderCommands["End"] = 20] = "End";
            })(HeaderCommands || (HeaderCommands = {}));
            Mesh = /** @class */ (function () {
                function Mesh() {
                }
                return Mesh;
            }());
            exports_53("Mesh", Mesh);
        }
    };
});
System.register("oot3d/render", ["oot3d/cmb", "oot3d/zsi", "Progressable", "render", "Program", "RenderArena", "util"], function (exports_54, context_54) {
    "use strict";
    var __moduleName = context_54 && context_54.id;
    function textureToCanvas(texture) {
        var canvas = document.createElement("canvas");
        canvas.width = texture.width;
        canvas.height = texture.height;
        canvas.title = texture.name;
        var ctx = canvas.getContext("2d");
        var imgData = ctx.createImageData(canvas.width, canvas.height);
        for (var i = 0; i < imgData.data.length; i++)
            imgData.data[i] = texture.pixels[i];
        ctx.putImageData(imgData, 0, 0);
        var surfaces = [canvas];
        return { name: texture.name, surfaces: surfaces };
    }
    function dirname(path) {
        var parts = path.split('/');
        parts.pop();
        return parts.join('/');
    }
    var CMB, ZSI, Progressable_5, render_21, Program_9, RenderArena_2, util_31, OoT3D_Program, Scene, MultiScene, SceneDesc;
    return {
        setters: [
            function (CMB_2) {
                CMB = CMB_2;
            },
            function (ZSI_1) {
                ZSI = ZSI_1;
            },
            function (Progressable_5_1) {
                Progressable_5 = Progressable_5_1;
            },
            function (render_21_1) {
                render_21 = render_21_1;
            },
            function (Program_9_1) {
                Program_9 = Program_9_1;
            },
            function (RenderArena_2_1) {
                RenderArena_2 = RenderArena_2_1;
            },
            function (util_31_1) {
                util_31 = util_31_1;
            }
        ],
        execute: function () {
            OoT3D_Program = /** @class */ (function (_super) {
                __extends(OoT3D_Program, _super);
                function OoT3D_Program() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.vert = "\nprecision mediump float;\n\nuniform mat4 u_modelView;\nuniform mat4 u_localMatrix;\nuniform mat4 u_projection;\nuniform float u_posScale;\nuniform float u_uvScale;\nlayout(location = " + OoT3D_Program.a_position + ") in vec3 a_position;\nlayout(location = " + OoT3D_Program.a_uv + ") in vec2 a_uv;\nlayout(location = " + OoT3D_Program.a_color + ") in vec4 a_color;\nvarying vec4 v_color;\nvarying vec2 v_uv;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_position, 1.0) * u_posScale;\n    v_color = a_color;\n    v_uv = a_uv * u_uvScale;\n    v_uv.t = 1.0 - v_uv.t;\n}";
                    _this.frag = "\nprecision mediump float;\nvarying vec2 v_uv;\nvarying vec4 v_color;\nuniform sampler2D u_texture;\nuniform bool u_alphaTest;\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_uv);\n    gl_FragColor *= v_color;\n    if (u_alphaTest && gl_FragColor.a <= 0.8)\n        discard;\n}";
                    return _this;
                }
                OoT3D_Program.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.posScaleLocation = gl.getUniformLocation(prog, "u_posScale");
                    this.uvScaleLocation = gl.getUniformLocation(prog, "u_uvScale");
                    this.alphaTestLocation = gl.getUniformLocation(prog, "u_alphaTest");
                };
                OoT3D_Program.a_position = 0;
                OoT3D_Program.a_color = 1;
                OoT3D_Program.a_uv = 2;
                return OoT3D_Program;
            }(Program_9.default));
            Scene = /** @class */ (function () {
                function Scene(gl, zsi) {
                    this.program = new OoT3D_Program();
                    this.textures = zsi.mesh.textures.map(function (texture) {
                        return textureToCanvas(texture);
                    });
                    this.zsi = zsi;
                    this.arena = new RenderArena_2.default();
                    this.model = this.translateModel(gl, zsi.mesh);
                }
                Scene.prototype.render = function (state) {
                    var gl = state.gl;
                    state.useProgram(this.program);
                    state.bindModelView();
                    this.model(state);
                };
                Scene.prototype.translateDataType = function (gl, dataType) {
                    switch (dataType) {
                        case CMB.DataType.Byte: return gl.BYTE;
                        case CMB.DataType.UByte: return gl.UNSIGNED_BYTE;
                        case CMB.DataType.Short: return gl.SHORT;
                        case CMB.DataType.UShort: return gl.UNSIGNED_SHORT;
                        case CMB.DataType.Int: return gl.INT;
                        case CMB.DataType.UInt: return gl.UNSIGNED_INT;
                        case CMB.DataType.Float: return gl.FLOAT;
                        default: throw new Error();
                    }
                };
                Scene.prototype.dataTypeSize = function (dataType) {
                    switch (dataType) {
                        case CMB.DataType.Byte: return 1;
                        case CMB.DataType.UByte: return 1;
                        case CMB.DataType.Short: return 2;
                        case CMB.DataType.UShort: return 2;
                        case CMB.DataType.Int: return 4;
                        case CMB.DataType.UInt: return 4;
                        case CMB.DataType.Float: return 4;
                        default: throw new Error();
                    }
                };
                Scene.prototype.translateSepd = function (gl, cmbContext, sepd) {
                    var _this = this;
                    var vao = this.arena.createVertexArray(gl);
                    gl.bindVertexArray(vao);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cmbContext.idxBuffer);
                    gl.bindBuffer(gl.ARRAY_BUFFER, cmbContext.posBuffer);
                    gl.vertexAttribPointer(OoT3D_Program.a_position, 3, this.translateDataType(gl, sepd.posType), false, 0, sepd.posStart);
                    gl.bindBuffer(gl.ARRAY_BUFFER, cmbContext.colBuffer);
                    gl.vertexAttribPointer(OoT3D_Program.a_color, 4, this.translateDataType(gl, sepd.colType), true, 0, sepd.colStart);
                    gl.bindBuffer(gl.ARRAY_BUFFER, cmbContext.txcBuffer);
                    gl.vertexAttribPointer(OoT3D_Program.a_uv, 2, this.translateDataType(gl, sepd.txcType), false, 0, sepd.txcStart);
                    gl.enableVertexAttribArray(OoT3D_Program.a_position);
                    gl.enableVertexAttribArray(OoT3D_Program.a_color);
                    gl.enableVertexAttribArray(OoT3D_Program.a_uv);
                    gl.bindVertexArray(null);
                    return function () {
                        gl.uniform1f(_this.program.uvScaleLocation, sepd.txcScale);
                        gl.uniform1f(_this.program.posScaleLocation, sepd.posScale);
                        gl.bindVertexArray(vao);
                        try {
                            for (var _a = __values(sepd.prms), _b = _a.next(); !_b.done; _b = _a.next()) {
                                var prm = _b.value;
                                gl.drawElements(gl.TRIANGLES, prm.count, _this.translateDataType(gl, prm.indexType), prm.offset * _this.dataTypeSize(prm.indexType));
                            }
                        }
                        catch (e_43_1) { e_43 = { error: e_43_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                            }
                            finally { if (e_43) throw e_43.error; }
                        }
                        gl.bindVertexArray(null);
                        var e_43, _c;
                    };
                };
                Scene.prototype.translateTexture = function (gl, texture) {
                    var texId = this.arena.createTexture(gl);
                    gl.bindTexture(gl.TEXTURE_2D, texId);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texture.width, texture.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, texture.pixels);
                    return texId;
                };
                Scene.prototype.translateMaterial = function (gl, cmbContext, material) {
                    var _this = this;
                    function translateWrapMode(wrapMode) {
                        switch (wrapMode) {
                            case CMB.TextureWrapMode.CLAMP: return gl.CLAMP_TO_EDGE;
                            case CMB.TextureWrapMode.REPEAT: return gl.REPEAT;
                            default: throw new Error();
                        }
                    }
                    function translateTextureFilter(filter) {
                        switch (filter) {
                            case CMB.TextureFilter.LINEAR: return gl.LINEAR;
                            case CMB.TextureFilter.NEAREST: return gl.NEAREST;
                            case CMB.TextureFilter.LINEAR_MIPMAP_LINEAR: return gl.NEAREST;
                            case CMB.TextureFilter.LINEAR_MIPMAP_NEAREST: return gl.NEAREST;
                            case CMB.TextureFilter.NEAREST_MIPMAP_NEAREST: return gl.NEAREST;
                            case CMB.TextureFilter.NEAREST_MIPMIP_LINEAR: return gl.NEAREST;
                            default: throw new Error();
                        }
                    }
                    return function () {
                        for (var i = 0; i < 1; i++) {
                            var binding = material.textureBindings[i];
                            if (binding.textureIdx === -1)
                                continue;
                            gl.uniform1i(_this.program.alphaTestLocation, material.alphaTestEnable ? 1 : 0);
                            gl.activeTexture(gl.TEXTURE0 + i);
                            gl.bindTexture(gl.TEXTURE_2D, cmbContext.textures[binding.textureIdx]);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, translateTextureFilter(binding.minFilter));
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, translateTextureFilter(binding.magFilter));
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, translateWrapMode(binding.wrapS));
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, translateWrapMode(binding.wrapT));
                        }
                    };
                };
                Scene.prototype.translateMesh = function (gl, cmbContext, mesh) {
                    var mat = cmbContext.matFuncs[mesh.matsIdx];
                    var sepd = cmbContext.sepdFuncs[mesh.sepdIdx];
                    return function () {
                        mat(mesh);
                        sepd();
                    };
                };
                Scene.prototype.translateCmb = function (gl, cmb) {
                    var _this = this;
                    if (!cmb)
                        return function () { };
                    var posBuffer = this.arena.createBuffer(gl);
                    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, cmb.vertexBufferSlices.posBuffer.castToBuffer(), gl.STATIC_DRAW);
                    var colBuffer = this.arena.createBuffer(gl);
                    gl.bindBuffer(gl.ARRAY_BUFFER, colBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, cmb.vertexBufferSlices.colBuffer.castToBuffer(), gl.STATIC_DRAW);
                    var nrmBuffer = this.arena.createBuffer(gl);
                    gl.bindBuffer(gl.ARRAY_BUFFER, nrmBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, cmb.vertexBufferSlices.nrmBuffer.castToBuffer(), gl.STATIC_DRAW);
                    var txcBuffer = this.arena.createBuffer(gl);
                    gl.bindBuffer(gl.ARRAY_BUFFER, txcBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, cmb.vertexBufferSlices.txcBuffer.castToBuffer(), gl.STATIC_DRAW);
                    var textures = cmb.textures.map(function (texture) {
                        return _this.translateTexture(gl, texture);
                    });
                    var idxBuffer = this.arena.createBuffer(gl);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cmb.indexBuffer.castToBuffer(), gl.STATIC_DRAW);
                    var cmbContext = {
                        posBuffer: posBuffer,
                        colBuffer: colBuffer,
                        nrmBuffer: nrmBuffer,
                        txcBuffer: txcBuffer,
                        idxBuffer: idxBuffer,
                        textures: textures,
                    };
                    cmbContext.sepdFuncs = cmb.sepds.map(function (sepd) { return _this.translateSepd(gl, cmbContext, sepd); });
                    cmbContext.matFuncs = cmb.materials.map(function (material) { return _this.translateMaterial(gl, cmbContext, material); });
                    var meshFuncs = cmb.meshs.map(function (mesh) { return _this.translateMesh(gl, cmbContext, mesh); });
                    return function () {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
                        try {
                            for (var meshFuncs_1 = __values(meshFuncs), meshFuncs_1_1 = meshFuncs_1.next(); !meshFuncs_1_1.done; meshFuncs_1_1 = meshFuncs_1.next()) {
                                var func = meshFuncs_1_1.value;
                                func();
                            }
                        }
                        catch (e_44_1) { e_44 = { error: e_44_1 }; }
                        finally {
                            try {
                                if (meshFuncs_1_1 && !meshFuncs_1_1.done && (_a = meshFuncs_1.return)) _a.call(meshFuncs_1);
                            }
                            finally { if (e_44) throw e_44.error; }
                        }
                        var e_44, _a;
                    };
                };
                Scene.prototype.translateModel = function (gl, mesh) {
                    var opaque = this.translateCmb(gl, mesh.opaque);
                    var transparent = this.translateCmb(gl, mesh.transparent);
                    var renderFlags = new render_21.RenderFlags();
                    renderFlags.blendMode = render_21.BlendMode.ADD;
                    renderFlags.depthTest = true;
                    renderFlags.cullMode = render_21.CullMode.BACK;
                    return function (state) {
                        state.useFlags(renderFlags);
                        opaque();
                        transparent();
                    };
                };
                Scene.prototype.destroy = function (gl) {
                    this.arena.destroy(gl);
                };
                return Scene;
            }());
            MultiScene = /** @class */ (function () {
                function MultiScene(scenes) {
                    this.scenes = scenes;
                    this.textures = [];
                    try {
                        for (var _a = __values(this.scenes), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var scene = _b.value;
                            this.textures = this.textures.concat(scene.textures);
                        }
                    }
                    catch (e_45_1) { e_45 = { error: e_45_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_45) throw e_45.error; }
                    }
                    var e_45, _c;
                }
                MultiScene.prototype.render = function (renderState) {
                    this.scenes.forEach(function (scene) {
                        scene.render(renderState);
                    });
                };
                MultiScene.prototype.destroy = function (gl) {
                    this.scenes.forEach(function (scene) { return scene.destroy(gl); });
                };
                return MultiScene;
            }());
            SceneDesc = /** @class */ (function () {
                function SceneDesc(name, path) {
                    this.name = name;
                    this.path = path;
                    this.id = this.path;
                }
                SceneDesc.prototype.createScene = function (gl) {
                    var _this = this;
                    return util_31.fetch(this.path).then(function (result) {
                        return _this._createSceneFromData(gl, result);
                    });
                };
                SceneDesc.prototype._createRoomSceneFromData = function (gl, result) {
                    var zsi = ZSI.parse(result);
                    util_31.assert(zsi.mesh !== null);
                    return new Progressable_5.default(Promise.resolve(new Scene(gl, zsi)));
                };
                SceneDesc.prototype._createSceneFromData = function (gl, result) {
                    var _this = this;
                    var zsi = ZSI.parse(result);
                    util_31.assert(zsi.rooms !== null);
                    var basePath = dirname(this.path);
                    var roomFilenames = zsi.rooms.map(function (romPath) {
                        var filename = romPath.split('/').pop();
                        return basePath + '/' + filename;
                    });
                    return Progressable_5.default.all(roomFilenames.map(function (filename) {
                        return util_31.fetch(filename).then(function (roomResult) { return _this._createRoomSceneFromData(gl, roomResult); });
                    })).then(function (scenes) {
                        return new MultiScene(scenes);
                    });
                };
                return SceneDesc;
            }());
            exports_54("SceneDesc", SceneDesc);
        }
    };
});
System.register("oot3d/scenes", ["oot3d/render"], function (exports_55, context_55) {
    "use strict";
    var __moduleName = context_55 && context_55.id;
    var render_22, id, name, sceneDescs, sceneGroup;
    return {
        setters: [
            function (render_22_1) {
                render_22 = render_22_1;
            }
        ],
        execute: function () {
            id = "oot3d";
            name = "Ocarina of Time 3D";
            sceneDescs = [
                { name: "Inside the Deku Tree", filename: "ydan_info.zsi" },
                { name: "Inside the Deku Tree (Boss)", filename: "ydan_boss_info.zsi" },
                { name: "Dodongo's Cavern", filename: "ddan_info.zsi" },
                { name: "Dodongo's Cavern (Boss)", filename: "ddan_boss_info.zsi" },
                { name: "Jabu-Jabu's Belly", filename: 'bdan_info.zsi' },
                { name: "Jabu-Jabu's Belly (Boss)", filename: 'bdan_boss_info.zsi' },
                { name: "Forest Temple", filename: 'bmori1_info.zsi' },
                { name: "Forest Temple (Boss)", filename: "moriboss_info.zsi" },
                { name: "Fire Temple", filename: "hidan_info.zsi" },
                { name: "Fire Temple (Boss)", filename: "fire_bs_info.zsi" },
                { name: "Water Temple", filename: "mizusin_info.zsi" },
                { name: "Water Temple (Boss)", filename: "mizusin_boss_info.zsi" },
                { name: "Spirit Temple", filename: "jyasinzou_info.zsi" },
                { name: "Spirit Temple (Mid-Boss)", filename: "jyasinzou_boss_info.zsi" },
                { name: "Shadow Temple", filename: "hakadan_info.zsi" },
                { name: "Shadow Temple (Boss)", filename: "hakadan_boss_info.zsi" },
                { name: "Bottom of the Well", filename: "hakadan_ch_info.zsi" },
                { name: "Ice Cavern", filename: "ice_doukutu_info.zsi" },
                { name: "Gerudo Training Grounds", filename: "men_info.zsi" },
                { name: "Thieve's Hideout", filename: "gerudoway_info.zsi" },
                { name: "Ganon's Castle", filename: "ganontika_info.zsi" },
                { name: "Ganon's Castle (Crumbling)", filename: "ganontikasonogo_info.zsi" },
                { name: "Ganon's Castle (Outside)", filename: "ganon_tou_info.zsi" },
                { name: "Ganon's Castle Tower", filename: "ganon_info.zsi" },
                { name: "Ganon's Castle Tower (Crumbling)", filename: "ganon_sonogo_info.zsi" },
                { name: "Second-To-Last Boss Ganondorf", filename: "ganon_boss_info.zsi" },
                { name: "Final Battle Against Ganon", filename: "ganon_demo_info.zsi" },
                { name: "Ganondorf's Death", filename: "ganon_final_info.zsi" },
                { name: "Hyrule Field", filename: "spot00_info.zsi" },
                { name: "Kakariko Village", filename: "spot01_info.zsi" },
                { name: "Kakariko Graveyard", filename: "spot02_info.zsi" },
                { name: "Zora's River", filename: "spot03_info.zsi" },
                { name: "Kokiri Firest", filename: "spot04_info.zsi" },
                { name: "Sacred Forest Meadow", filename: "spot05_info.zsi" },
                { name: "Lake Hylia", filename: "spot06_info.zsi" },
                { name: "Zora's Domain", filename: "spot07_info.zsi" },
                { name: "Zora's Fountain", filename: "spot08_info.zsi" },
                { name: "Gerudo Valley", filename: "spot09_info.zsi" },
                { name: "Lost Woods", filename: "spot10_info.zsi" },
                { name: "Desert Colossus", filename: "spot11_info.zsi" },
                { name: "Gerudo's Fortress", filename: "spot12_info.zsi" },
                { name: "Haunted Wasteland", filename: "spot13_info.zsi" },
                { name: "Hyrule Castle", filename: "spot15_info.zsi" },
                { name: "Death Mountain", filename: "spot16_info.zsi" },
                { name: "Death Mountain Crater", filename: "spot17_info.zsi" },
                { name: "Goron City", filename: "spot18_info.zsi" },
                { name: "Lon Lon Ranch", filename: "spot20_info.zsi" },
                { name: "", filename: "spot99_info.zsi" },
                { name: "Market Entrance (Day)", filename: "entra_day_info.zsi" },
                { name: "Market Entrance (Night)", filename: "entra_night_info.zsi" },
                { name: "Market Entrance (Ruins)", filename: "entra_ruins_info.zsi" },
                { name: "Market (Day)", filename: "market_day_info.zsi" },
                { name: "Market (Night)", filename: "market_night_info.zsi" },
                { name: "Market (Ruins)", filename: "market_ruins_info.zsi" },
                { name: "Market Back-Alley (Day)", filename: "market_alley_info.zsi" },
                { name: "Market Back-Alley (Night)", filename: "market_alley_n_info.zsi" },
                { name: "Lots'o'Pots", filename: "miharigoya_info.zsi" },
                { name: "Bombchu Bowling Alley", filename: 'bowling_info.zsi' },
                { name: "Temple of Time (Outside, Day)", filename: "shrine_info.zsi" },
                { name: "Temple of Time (Outside, Night)", filename: "shrine_n_info.zsi" },
                { name: "Temple of Time (Outside, Adult)", filename: "shrine_r_info.zsi" },
                { name: "Temple of Time (Interior)", filename: "tokinoma_info.zsi" },
                { name: "Chamber of Sages", filename: "kenjyanoma_info.zsi" },
                { name: "Zora Shop", filename: "zoora_info.zsi" },
                { name: "Dampe's Hut", filename: "hut_info.zsi" },
                { name: "Great Fairy Fountain", filename: "daiyousei_izumi_info.zsi" },
                { name: "Small Fairy Fountain", filename: "yousei_izumi_tate_info.zsi" },
                { name: "Magic Fairy Fountain", filename: "yousei_izumi_yoko_info.zsi" },
                { name: "Castle Courtyard", filename: "hairal_niwa_info.zsi" },
                { name: "Castle Courtyard (Night)", filename: "hairal_niwa_n_info.zsi" },
                { name: '', filename: "hakaana_info.zsi" },
                { name: "Grottos", filename: "kakusiana_info.zsi" },
                { name: "Royal Family's Tomb", filename: "hakaana_ouke_info.zsi" },
                { name: "Dampe's Grave & Windmill Hut", filename: "hakasitarelay_info.zsi" },
                { name: "Cutscene Map", filename: "hiral_demo_info.zsi" },
                { name: "Hylia Lakeside Laboratory", filename: "hylia_labo_info.zsi" },
                { name: "Puppy Woman's House", filename: "kakariko_impa_info.zsi" },
                { name: "Skulltula House", filename: "kinsuta_info.zsi" },
                { name: "Impa's House", filename: "labo_info.zsi" },
                { name: "Granny's Potion Shop", filename: "mahouya_info.zsi" },
                { name: "Zelda's Courtyard", filename: "nakaniwa_info.zsi" },
                { name: "Market Potion Shop", filename: "shop_alley_info.zsi" },
                { name: "Kakariko Potion Shop", filename: "shop_drag_info.zsi" },
                { name: "Happy Mask Shop", filename: "shop_face_info.zsi" },
                { name: "Goron Shop", filename: "shop_golon_info.zsi" },
                { name: "Bombchu Shop", filename: "shop_night_info.zsi" },
                { name: "Talon's House", filename: "souko_info.zsi" },
                { name: "Stables", filename: "stable_info.zsi" },
                { name: "Shooting Gallery", filename: "syatekijyou_info.zsi" },
                { name: "Treasure Chest Game", filename: "takaraya_info.zsi" },
                { name: "Carpenter's Tent", filename: "tent_info.zsi" },
                { name: '', filename: "k_home_info.zsi" },
                { name: '', filename: "kakariko_info.zsi" },
                { name: '', filename: "kokiri_info.zsi" },
                { name: '', filename: "link_info.zsi" },
                { name: '', filename: "shop_info.zsi" },
                { name: "Fishing Pond", filename: "turibori_info.zsi" },
            ].map(function (entry) {
                var path = "data/oot3d/" + entry.filename;
                var name = entry.name || entry.filename;
                return new render_22.SceneDesc(name, path);
            });
            exports_55("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
// Nintendo SARC archive format.
System.register("fres/sarc", ["util"], function (exports_56, context_56) {
    "use strict";
    var __moduleName = context_56 && context_56.id;
    function parse(buffer) {
        var view = buffer.createDataView();
        util_32.assert(util_32.readString(buffer, 0x00, 0x04) === 'SARC');
        var littleEndian;
        switch (view.getUint16(0x06, false)) {
            case 0xFEFF:
                littleEndian = false;
                break;
            case 0xFFFE:
                littleEndian = true;
                break;
            default:
                throw new Error("Invalid BOM");
        }
        util_32.assert(view.getUint16(0x04, littleEndian) === 0x14); // Header length.
        var dataOffset = view.getUint32(0x0C, littleEndian);
        var version = view.getUint16(0x10, littleEndian);
        util_32.assert(version === 0x100);
        util_32.assert(util_32.readString(buffer, 0x14, 0x04) === 'SFAT');
        util_32.assert(view.getUint16(0x18, littleEndian) === 0x0C);
        var fileCount = view.getUint16(0x1A, littleEndian);
        var sfntTableOffs = 0x20 + 0x10 * fileCount;
        util_32.assert(util_32.readString(buffer, sfntTableOffs, 0x04) === 'SFNT');
        util_32.assert(view.getUint16(sfntTableOffs + 0x04, littleEndian) === 0x08);
        var sfntStringTableOffs = sfntTableOffs + 0x08;
        var files = [];
        var fileTableIdx = 0x20;
        for (var i = 0; i < fileCount; i++) {
            var nameHash = view.getUint32(fileTableIdx + 0x00, littleEndian);
            var flags = view.getUint16(fileTableIdx + 0x04, littleEndian);
            var name_12 = void 0;
            if (flags & 0x0100) {
                var nameOffs = (view.getUint16(fileTableIdx + 0x06, littleEndian) * 4);
                name_12 = util_32.readString(buffer, sfntStringTableOffs + nameOffs, 0xFF);
            }
            else {
                name_12 = null;
            }
            var fileStart = view.getUint32(fileTableIdx + 0x08, littleEndian);
            var fileEnd = view.getUint32(fileTableIdx + 0x0C, littleEndian);
            var startOffs = dataOffset + fileStart;
            var endOffs = dataOffset + fileEnd;
            files.push({ name: name_12, offset: startOffs, buffer: buffer.slice(startOffs, endOffs) });
            fileTableIdx += 0x10;
        }
        return { buffer: buffer, files: files };
    }
    exports_56("parse", parse);
    var util_32;
    return {
        setters: [
            function (util_32_1) {
                util_32 = util_32_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("worker_util", ["util"], function (exports_57, context_57) {
    "use strict";
    var __moduleName = context_57 && context_57.id;
    function makeWorkerFromSource(sources) {
        var blob = new Blob(sources, { type: 'application/javascript' });
        var url = window.URL.createObjectURL(blob);
        var w = new Worker(url);
        window.URL.revokeObjectURL(url);
        return w;
    }
    exports_57("makeWorkerFromSource", makeWorkerFromSource);
    var util_33, WorkerManager, WorkerPool;
    return {
        setters: [
            function (util_33_1) {
                util_33 = util_33_1;
            }
        ],
        execute: function () {
            WorkerManager = /** @class */ (function () {
                function WorkerManager(worker, onworkerdone) {
                    this.worker = worker;
                    this.onworkerdone = onworkerdone;
                    this.currentRequest = null;
                    this.worker.onmessage = this._workerOnMessage.bind(this);
                }
                WorkerManager.prototype._workerOnMessage = function (e) {
                    var resp = e.data;
                    this.currentRequest = util_33.assertExists(this.currentRequest);
                    this.currentRequest.resolve(resp);
                    this.currentRequest = null;
                    this.onworkerdone();
                };
                WorkerManager.prototype.execute = function (req) {
                    this.currentRequest = req;
                    this.worker.postMessage(req.request);
                };
                WorkerManager.prototype.isFree = function () {
                    return this.currentRequest === null;
                };
                WorkerManager.prototype.terminate = function () {
                    return this.worker.terminate();
                };
                return WorkerManager;
            }());
            WorkerPool = /** @class */ (function () {
                function WorkerPool(workerConstructor, numWorkers) {
                    if (numWorkers === void 0) { numWorkers = 8; }
                    this.workerConstructor = workerConstructor;
                    this.numWorkers = numWorkers;
                    this.outstandingRequests = [];
                    this.workers = [];
                }
                WorkerPool.prototype.terminate = function () {
                    try {
                        for (var _a = __values(this.workers), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var worker = _b.value;
                            worker.terminate();
                        }
                    }
                    catch (e_46_1) { e_46 = { error: e_46_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_46) throw e_46.error; }
                    }
                    this.workers = [];
                    var e_46, _c;
                };
                WorkerPool.prototype.build = function () {
                    if (this.workers.length > 0)
                        return;
                    var numWorkers = this.numWorkers;
                    while (numWorkers--) {
                        var manager = new WorkerManager(this.workerConstructor(), this._onWorkerDone.bind(this));
                        this.workers.push(manager);
                    }
                };
                WorkerPool.prototype.execute = function (request) {
                    var _this = this;
                    this.build();
                    var p = new Promise(function (resolve, reject) {
                        var workerManagerRequest = { request: request, resolve: resolve };
                        _this.insertRequest(workerManagerRequest);
                    });
                    this.pumpQueue();
                    return p;
                };
                WorkerPool.prototype.insertRequest = function (workerManagerRequest) {
                    var i;
                    for (i = 0; i < this.outstandingRequests.length; i++) {
                        if (this.outstandingRequests[i].request.priority > workerManagerRequest.request.priority)
                            break;
                    }
                    this.outstandingRequests.splice(i, 0, workerManagerRequest);
                };
                WorkerPool.prototype.pumpQueue = function () {
                    try {
                        for (var _a = __values(this.workers), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var worker = _b.value;
                            if (this.outstandingRequests.length === 0)
                                return;
                            if (worker.isFree()) {
                                var req = util_33.assertExists(this.outstandingRequests.shift());
                                worker.execute(req);
                            }
                        }
                    }
                    catch (e_47_1) { e_47 = { error: e_47_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_47) throw e_47.error; }
                    }
                    var e_47, _c;
                };
                WorkerPool.prototype._onWorkerDone = function () {
                    this.pumpQueue();
                };
                return WorkerPool;
            }());
            exports_57("WorkerPool", WorkerPool);
        }
    };
});
System.register("fres/gx2_swizzle", ["worker_util"], function (exports_58, context_58) {
    "use strict";
    var __moduleName = context_58 && context_58.id;
    // This is all contained in one function in order to make it easier to Worker-ize.
    function _deswizzle(inSurface, srcBuffer, mipLevel) {
        var numPipes = 2;
        var numBanks = 4;
        var microTileWidth = 8;
        var microTileHeight = 8;
        var macroTileWidth = 8 * numBanks;
        var macroTileHeight = 8 * numPipes;
        var microTilePixels = microTileWidth * microTileHeight;
        var pipeInterleaveBytes = 256;
        var numPipeBits = 1;
        var numBankBits = 2;
        var numGroupBits = 8;
        var rowSize = 2048;
        var swapSize = 256;
        var splitSize = 2048;
        function memcpy(dst, dstOffs, src, srcOffs, length) {
            dst.set(new Uint8Array(src, srcOffs, length), dstOffs);
        }
        function alignPow2(n) {
            var x = 1;
            while (x < n)
                x *= 2;
            return x;
        }
        function align(n, multiple) {
            var mask = (multiple - 1);
            return (n + mask) & ~mask;
        }
        function computeSurfaceMipLevelTileMode(surface, mipLevel) {
            // Level starts at 0.
            if (mipLevel > 0) {
                surface.width = Math.max(alignPow2(surface.width >> mipLevel), 1);
                surface.pitch = Math.max(alignPow2(surface.pitch >> mipLevel), 1);
                surface.height = Math.max(alignPow2(surface.height >> mipLevel), 1);
                var numSamples = 1 << surface.aaMode;
                var thickness = computeSurfaceThickness(surface.tileMode);
                var bytesPerBlock_1 = computeSurfaceBytesPerBlock(surface.format);
                var microTileThickness = computeSurfaceThickness(surface.tileMode);
                var bytesPerSample = bytesPerBlock_1 * microTileThickness * microTilePixels;
                var microTileBytes = bytesPerSample * numSamples;
                var pitchAlignFactor = Math.max(pipeInterleaveBytes / microTileBytes, 1) | 0;
                var macroTileHeightBlocks = macroTileHeight * computeSurfaceBlockWidth(surface.format);
                if (surface.tileMode === 4 /* _2D_TILED_THIN1 */ && (surface.pitch < pitchAlignFactor * macroTileWidth || surface.height < macroTileHeightBlocks))
                    surface.tileMode = 2 /* _1D_TILED_THIN1 */;
            }
        }
        function computePipeFromCoordWoRotation(x, y) {
            // NumPipes = 2
            var x3 = (x >>> 3) & 1;
            var y3 = (y >>> 3) & 1;
            var pipeBit0 = (y3 ^ x3);
            return (pipeBit0 << 0);
        }
        function computeBankFromCoordWoRotation(x, y) {
            var ty = (y / numPipes) | 0;
            var x3 = (x >>> 3) & 1;
            var x4 = (x >>> 4) & 1;
            var ty3 = (ty >>> 3) & 1;
            var ty4 = (ty >>> 4) & 1;
            var p0 = ty4 ^ x3;
            var p1 = ty3 ^ x4;
            return (p1 << 1) | (p0 << 0);
        }
        function computeSurfaceThickness(tileMode) {
            switch (tileMode) {
                case 2 /* _1D_TILED_THIN1 */:
                case 4 /* _2D_TILED_THIN1 */:
                    return 1;
            }
        }
        function computeSurfaceBlockWidth(format) {
            switch (format & 63 /* FMT_MASK */) {
                case 49 /* FMT_BC1 */:
                case 51 /* FMT_BC3 */:
                case 52 /* FMT_BC4 */:
                case 53 /* FMT_BC5 */:
                    return 4;
                default:
                    return 1;
            }
        }
        function computeSurfaceBytesPerBlock(format) {
            switch (format & 63 /* FMT_MASK */) {
                case 49 /* FMT_BC1 */:
                case 52 /* FMT_BC4 */:
                    return 8;
                case 51 /* FMT_BC3 */:
                case 53 /* FMT_BC5 */:
                    return 16;
                // For non-block formats, a "block" is a pixel.
                case 26 /* FMT_TCS_R8_G8_B8_A8 */:
                    return 4;
                default:
                    throw new Error("Unsupported surface format " + format);
            }
        }
        function computePixelIndexWithinMicroTile(x, y, bytesPerBlock) {
            var x0 = (x >>> 0) & 1;
            var x1 = (x >>> 1) & 1;
            var x2 = (x >>> 2) & 1;
            var y0 = (y >>> 0) & 1;
            var y1 = (y >>> 1) & 1;
            var y2 = (y >>> 2) & 1;
            var pixelBits;
            if (bytesPerBlock === 8) {
                pixelBits = [y2, y1, x2, x1, y0, x0];
            }
            else if (bytesPerBlock === 16) {
                pixelBits = [y2, y1, x2, x1, x0, y0];
            }
            else if (bytesPerBlock === 4) {
                pixelBits = [y2, y1, y0, x2, x1, x0];
            }
            else {
                throw new Error("Invalid bpp");
            }
            var p5 = pixelBits[0];
            var p4 = pixelBits[1];
            var p3 = pixelBits[2];
            var p2 = pixelBits[3];
            var p1 = pixelBits[4];
            var p0 = pixelBits[5];
            return (p5 << 5) | (p4 << 4) | (p3 << 3) | (p2 << 2) | (p1 << 1) | (p0 << 0);
        }
        function computeSurfaceRotationFromTileMode(tileMode) {
            switch (tileMode) {
                case 4 /* _2D_TILED_THIN1 */:
                    return numPipes * ((numBanks >> 1) - 1);
                default:
                    throw new Error("Unsupported tile mode " + tileMode);
            }
        }
        function computeTileModeAspectRatio(tileMode) {
            switch (tileMode) {
                case 4 /* _2D_TILED_THIN1 */:
                    return 1;
                default:
                    throw new Error("Unsupported tile mode " + tileMode);
            }
        }
        function computeMacroTilePitch(tileMode) {
            return macroTileWidth / computeTileModeAspectRatio(tileMode);
        }
        function computeMacroTileHeight(tileMode) {
            return macroTileHeight / computeTileModeAspectRatio(tileMode);
        }
        function computeSurfaceAddrFromCoordMicroTiled(x, y, surface) {
            // XXX(jstpierre): 3D Textures
            var slice = 0;
            var bytesPerBlock = computeSurfaceBytesPerBlock(surface.format);
            var microTileThickness = computeSurfaceThickness(surface.tileMode);
            var microTileBytes = bytesPerBlock * microTileThickness * microTilePixels;
            var microTilesPerRow = surface.pitch / microTileWidth;
            var microTileIndexX = (x / microTileWidth) | 0;
            var microTileIndexY = (y / microTileHeight) | 0;
            var microTileIndexZ = (slice / microTileThickness) | 0;
            var microTileOffset = microTileBytes * (microTileIndexX + microTileIndexY * microTilesPerRow);
            var sliceBytes = surface.pitch * surface.height * microTileThickness * bytesPerBlock;
            var sliceOffset = microTileIndexZ * sliceBytes;
            var pixelIndex = computePixelIndexWithinMicroTile(x, y, bytesPerBlock);
            var pixelOffset = bytesPerBlock * pixelIndex;
            return pixelOffset + microTileOffset + sliceOffset;
        }
        function computeSurfaceAddrFromCoordMacroTiled(x, y, surface) {
            // XXX(jstpierre): AA textures
            var sample = 0;
            // XXX(jstpierre): 3D Textures
            var slice = 0;
            var numSamples = 1 << surface.aaMode;
            var pipeSwizzle = (surface.swizzle >> 8) & 0x01;
            var bankSwizzle = (surface.swizzle >> 9) & 0x03;
            var bytesPerBlock = computeSurfaceBytesPerBlock(surface.format);
            var microTileThickness = computeSurfaceThickness(surface.tileMode);
            var bytesPerSample = bytesPerBlock * microTileThickness * microTilePixels;
            var microTileBytes = bytesPerSample * numSamples;
            var isSamplesSplit = numSamples > 1 && (microTileBytes > splitSize);
            var samplesPerSlice = Math.max(isSamplesSplit ? (splitSize / bytesPerSample) : numSamples, 1);
            var numSampleSplits = isSamplesSplit ? (numSamples / samplesPerSlice) : 1;
            var numSurfaceSamples = isSamplesSplit ? samplesPerSlice : numSamples;
            var rotation = computeSurfaceRotationFromTileMode(surface.tileMode);
            var macroTilePitch = computeMacroTilePitch(surface.tileMode);
            var macroTileHeight = computeMacroTileHeight(surface.tileMode);
            var groupMask = (1 << numGroupBits) - 1;
            var pixelIndex = computePixelIndexWithinMicroTile(x, y, bytesPerBlock);
            var pixelOffset = pixelIndex * bytesPerBlock;
            var sampleOffset = sample * (microTileBytes / numSamples);
            var elemOffset = pixelOffset + sampleOffset;
            var sampleSlice;
            if (isSamplesSplit) {
                var tileSliceBytes = microTileBytes / numSampleSplits;
                sampleSlice = (elemOffset / tileSliceBytes) | 0;
                elemOffset = elemOffset % tileSliceBytes;
            }
            else {
                sampleSlice = 0;
            }
            var pipe1 = computePipeFromCoordWoRotation(x, y);
            var bank1 = computeBankFromCoordWoRotation(x, y);
            var bankPipe = pipe1 + numPipes * bank1;
            var sliceIn = slice / (microTileThickness > 1 ? 4 : 1);
            var swizzle = pipeSwizzle + numPipes * bankSwizzle;
            bankPipe = bankPipe ^ (numPipes * sampleSlice * ((numBanks >> 1) + 1) ^ (swizzle + sliceIn * rotation));
            bankPipe = bankPipe % (numPipes * numBanks);
            var pipe = (bankPipe % numPipes) | 0;
            var bank = (bankPipe / numPipes) | 0;
            var sliceBytes = surface.height * surface.pitch * microTileThickness * bytesPerBlock * numSamples;
            var sliceOffset = sliceBytes * ((sampleSlice / microTileThickness) | 0);
            var numSwizzleBits = numBankBits + numPipeBits;
            var macroTilesPerRow = (surface.pitch / macroTilePitch) | 0;
            var macroTileBytes = (numSamples * microTileThickness * bytesPerBlock * macroTileHeight * macroTilePitch);
            var macroTileIndexX = (x / macroTilePitch) | 0;
            var macroTileIndexY = (y / macroTileHeight) | 0;
            var macroTileOffset = (macroTileIndexX + macroTilesPerRow * macroTileIndexY) * macroTileBytes;
            var totalOffset = (elemOffset + ((macroTileOffset + sliceOffset) >> numSwizzleBits));
            var offsetHigh = (totalOffset & ~groupMask) << numSwizzleBits;
            var offsetLow = (totalOffset & groupMask);
            var pipeBits = pipe << (numGroupBits);
            var bankBits = bank << (numPipeBits + numGroupBits);
            var addr = (bankBits | pipeBits | offsetLow | offsetHigh);
            return addr;
        }
        // Have to spell this thing out the long way...
        var surface = {
            format: inSurface.format,
            tileMode: inSurface.tileMode,
            aaMode: inSurface.aaMode,
            swizzle: inSurface.swizzle,
            width: inSurface.width,
            height: inSurface.height,
            depth: inSurface.depth,
            pitch: inSurface.pitch,
            numMips: inSurface.numMips,
            texDataSize: inSurface.texDataSize,
            mipDataSize: inSurface.mipDataSize,
            mipDataOffsets: inSurface.mipDataOffsets,
        };
        computeSurfaceMipLevelTileMode(surface, mipLevel);
        // For non-BC formats, "block" = 1 pixel.
        var blockSize = computeSurfaceBlockWidth(surface.format);
        var srcWidthBlocks = ((surface.width + blockSize - 1) / blockSize) | 0;
        var srcHeightBlocks = ((surface.height + blockSize - 1) / blockSize) | 0;
        var dstWidth = inSurface.width >>> mipLevel;
        var dstHeight = inSurface.height >>> mipLevel;
        var dstWidthBlocks = ((dstWidth + blockSize - 1) / blockSize) | 0;
        var dstHeightBlocks = ((dstHeight + blockSize - 1) / blockSize) | 0;
        var bytesPerBlock = computeSurfaceBytesPerBlock(surface.format);
        var dst = new Uint8Array(dstWidthBlocks * dstHeightBlocks * bytesPerBlock);
        for (var y = 0; y < dstHeightBlocks; y++) {
            for (var x = 0; x < dstWidthBlocks; x++) {
                var srcIdx = void 0;
                switch (surface.tileMode) {
                    case 2 /* _1D_TILED_THIN1 */:
                        srcIdx = computeSurfaceAddrFromCoordMicroTiled(x, y, surface);
                        break;
                    case 4 /* _2D_TILED_THIN1 */:
                        srcIdx = computeSurfaceAddrFromCoordMacroTiled(x, y, surface);
                        break;
                    default:
                        var tileMode_ = surface.tileMode;
                        throw new Error("Unsupported tile mode " + tileMode_.toString(16));
                }
                var dstIdx = (y * dstWidthBlocks + x) * bytesPerBlock;
                memcpy(dst, dstIdx, srcBuffer, srcIdx, bytesPerBlock);
            }
        }
        var pixels = dst.buffer;
        var width = dstWidth;
        var height = dstHeight;
        return { width: width, height: height, pixels: pixels };
    }
    function deswizzleWorker(global) {
        global.onmessage = function (e) {
            var req = e.data;
            var deswizzledSurface = _deswizzle(req.surface, req.buffer, req.mipLevel);
            global.postMessage(deswizzledSurface, [deswizzledSurface.pixels]);
        };
    }
    function makeDeswizzleWorker() {
        return worker_util_1.makeWorkerFromSource([
            _deswizzle.toString(),
            deswizzleWorker.toString(),
            'deswizzleWorker(this)',
        ]);
    }
    var worker_util_1, Deswizzler, deswizzler;
    return {
        setters: [
            function (worker_util_1_1) {
                worker_util_1 = worker_util_1_1;
            }
        ],
        execute: function () {
            Deswizzler = /** @class */ (function () {
                function Deswizzler() {
                    this.pool = new worker_util_1.WorkerPool(makeDeswizzleWorker);
                }
                Deswizzler.prototype.deswizzle = function (surface, buffer, mipLevel) {
                    var req = { surface: surface, buffer: buffer, mipLevel: mipLevel, priority: mipLevel };
                    return this.pool.execute(req);
                };
                Deswizzler.prototype.terminate = function () {
                    this.pool.terminate();
                };
                Deswizzler.prototype.build = function () {
                    this.pool.build();
                };
                return Deswizzler;
            }());
            exports_58("deswizzler", deswizzler = new Deswizzler());
        }
    };
});
System.register("fres/gx2_texture", ["fres/gx2_swizzle"], function (exports_59, context_59) {
    "use strict";
    var __moduleName = context_59 && context_59.id;
    // #region Texture Decode
    function expand5to8(n) {
        return (n << (8 - 5)) | (n >>> (10 - 8));
    }
    function expand6to8(n) {
        return (n << (8 - 6)) | (n >>> (12 - 8));
    }
    // Use the fast GX approximation.
    function s3tcblend(a, b) {
        // return (a*3 + b*5) / 8;
        return (((a << 1) + a) + ((b << 2) + b)) >>> 3;
    }
    // Software decompresses from standard BC1 (DXT1) to RGBA.
    function decompressBC1Surface(surface) {
        var bytesPerPixel = 4;
        var width = surface.width;
        var height = surface.height;
        var dst = new Uint8Array(width * height * bytesPerPixel);
        var view = new DataView(surface.pixels);
        var colorTable = new Uint8Array(16);
        var srcOffs = 0;
        for (var yy = 0; yy < height; yy += 4) {
            for (var xx = 0; xx < width; xx += 4) {
                var color1 = view.getUint16(srcOffs + 0x00, true);
                var color2 = view.getUint16(srcOffs + 0x02, true);
                // Fill in first two colors in color table.
                // TODO(jstpierre): SRGB-correct blending.
                colorTable[0] = expand5to8((color1 >> 11) & 0x1F);
                colorTable[1] = expand6to8((color1 >> 5) & 0x3F);
                colorTable[2] = expand5to8(color1 & 0x1F);
                colorTable[3] = 0xFF;
                colorTable[4] = expand5to8((color2 >> 11) & 0x1F);
                colorTable[5] = expand6to8((color2 >> 5) & 0x3F);
                colorTable[6] = expand5to8(color2 & 0x1F);
                colorTable[7] = 0xFF;
                if (color1 > color2) {
                    // Predict gradients.
                    colorTable[8] = s3tcblend(colorTable[4], colorTable[0]);
                    colorTable[9] = s3tcblend(colorTable[5], colorTable[1]);
                    colorTable[10] = s3tcblend(colorTable[6], colorTable[2]);
                    colorTable[11] = 0xFF;
                    colorTable[12] = s3tcblend(colorTable[0], colorTable[4]);
                    colorTable[13] = s3tcblend(colorTable[1], colorTable[5]);
                    colorTable[14] = s3tcblend(colorTable[2], colorTable[6]);
                    colorTable[15] = 0xFF;
                }
                else {
                    colorTable[8] = (colorTable[0] + colorTable[4]) >>> 1;
                    colorTable[9] = (colorTable[1] + colorTable[5]) >>> 1;
                    colorTable[10] = (colorTable[2] + colorTable[6]) >>> 1;
                    colorTable[11] = 0xFF;
                    colorTable[12] = 0x00;
                    colorTable[13] = 0x00;
                    colorTable[14] = 0x00;
                    colorTable[15] = 0x00;
                }
                var bits = view.getUint32(srcOffs + 0x04, true);
                for (var y = 0; y < 4; y++) {
                    for (var x = 0; x < 4; x++) {
                        var dstPx = (yy + y) * width + xx + x;
                        var dstOffs = dstPx * 4;
                        var colorIdx = bits & 0x03;
                        dst[dstOffs + 0] = colorTable[colorIdx * 4 + 0];
                        dst[dstOffs + 1] = colorTable[colorIdx * 4 + 1];
                        dst[dstOffs + 2] = colorTable[colorIdx * 4 + 2];
                        dst[dstOffs + 3] = colorTable[colorIdx * 4 + 3];
                        bits >>= 2;
                    }
                }
                srcOffs += 0x08;
            }
        }
        var pixels = dst.buffer;
        return { type: 'RGBA', flag: surface.flag, width: width, height: height, pixels: pixels };
    }
    // Software decompresses from standard BC3 (DXT5) to RGBA.
    function decompressBC3Surface(surface) {
        var bytesPerPixel = 4;
        var width = surface.width;
        var height = surface.height;
        var dst = new Uint8Array(width * height * bytesPerPixel);
        var view = new DataView(surface.pixels);
        var colorTable = new Uint8Array(16);
        var alphaTable = new Uint8Array(8);
        var srcOffs = 0;
        for (var yy = 0; yy < height; yy += 4) {
            for (var xx = 0; xx < width; xx += 4) {
                var alpha1 = view.getUint8(srcOffs + 0x00);
                var alpha2 = view.getUint8(srcOffs + 0x01);
                alphaTable[0] = alpha1;
                alphaTable[1] = alpha2;
                if (alpha1 > alpha2) {
                    alphaTable[2] = (6 * alpha1 + 1 * alpha2) / 7;
                    alphaTable[3] = (5 * alpha1 + 2 * alpha2) / 7;
                    alphaTable[4] = (4 * alpha1 + 3 * alpha2) / 7;
                    alphaTable[5] = (3 * alpha1 + 4 * alpha2) / 7;
                    alphaTable[6] = (2 * alpha1 + 5 * alpha2) / 7;
                    alphaTable[7] = (1 * alpha1 + 6 * alpha2) / 7;
                }
                else {
                    alphaTable[2] = (4 * alpha1 + 1 * alpha2) / 5;
                    alphaTable[3] = (3 * alpha1 + 2 * alpha2) / 5;
                    alphaTable[4] = (2 * alpha1 + 3 * alpha2) / 5;
                    alphaTable[5] = (1 * alpha1 + 4 * alpha2) / 5;
                    alphaTable[6] = 0;
                    alphaTable[7] = 255;
                }
                var alphaBits0 = view.getUint32(srcOffs + 0x02, true) & 0x00FFFFFF;
                var alphaBits1 = view.getUint32(srcOffs + 0x04, true) >>> 8;
                for (var y = 0; y < 4; y++) {
                    for (var x = 0; x < 4; x++) {
                        var dstIdx = ((yy + y) * width) + xx + x;
                        var dstOffs = (dstIdx * bytesPerPixel);
                        var fullShift = (y * 4 + x) * 3;
                        var alphaBits = fullShift < 24 ? alphaBits0 : alphaBits1;
                        var shift = fullShift % 24;
                        var index = (alphaBits >>> shift) & 0x07;
                        dst[dstOffs + 3] = alphaTable[index];
                    }
                }
                srcOffs += 0x08;
                var color1 = view.getUint16(srcOffs + 0x00, true);
                var color2 = view.getUint16(srcOffs + 0x02, true);
                // Fill in first two colors in color table.
                // TODO(jstpierre): SRGB-correct blending.
                colorTable[0] = expand5to8((color1 >> 11) & 0x1F);
                colorTable[1] = expand6to8((color1 >> 5) & 0x3F);
                colorTable[2] = expand5to8(color1 & 0x1F);
                colorTable[3] = 0xFF;
                colorTable[4] = expand5to8((color2 >> 11) & 0x1F);
                colorTable[5] = expand6to8((color2 >> 5) & 0x3F);
                colorTable[6] = expand5to8(color2 & 0x1F);
                colorTable[7] = 0xFF;
                if (color1 > color2) {
                    // Predict gradients.
                    colorTable[8] = s3tcblend(colorTable[4], colorTable[0]);
                    colorTable[9] = s3tcblend(colorTable[5], colorTable[1]);
                    colorTable[10] = s3tcblend(colorTable[6], colorTable[2]);
                    colorTable[11] = 0xFF;
                    colorTable[12] = s3tcblend(colorTable[0], colorTable[4]);
                    colorTable[13] = s3tcblend(colorTable[1], colorTable[5]);
                    colorTable[14] = s3tcblend(colorTable[2], colorTable[6]);
                    colorTable[15] = 0xFF;
                }
                else {
                    colorTable[8] = (colorTable[0] + colorTable[4]) >>> 1;
                    colorTable[9] = (colorTable[1] + colorTable[5]) >>> 1;
                    colorTable[10] = (colorTable[2] + colorTable[6]) >>> 1;
                    colorTable[11] = 0xFF;
                    colorTable[12] = 0x00;
                    colorTable[13] = 0x00;
                    colorTable[14] = 0x00;
                    colorTable[15] = 0xFF;
                }
                var colorBits = view.getUint32(srcOffs + 0x04, true);
                for (var y = 0; y < 4; y++) {
                    for (var x = 0; x < 4; x++) {
                        var dstIdx = (yy + y) * width + xx + x;
                        var dstOffs = (dstIdx * bytesPerPixel);
                        var colorIdx = colorBits & 0x03;
                        dst[dstOffs + 0] = colorTable[colorIdx * 4 + 0];
                        dst[dstOffs + 1] = colorTable[colorIdx * 4 + 1];
                        dst[dstOffs + 2] = colorTable[colorIdx * 4 + 2];
                        colorBits >>= 2;
                    }
                }
                srcOffs += 0x08;
            }
        }
        var pixels = dst.buffer;
        return { type: 'RGBA', flag: surface.flag, width: width, height: height, pixels: pixels };
    }
    // Software decompresses from standard BC4/BC5 to RGBA.
    function decompressBC45Surface(surface) {
        var bytesPerPixel = 4;
        var width = surface.width;
        var height = surface.height;
        var signed = surface.flag === 'SNORM';
        var view = new DataView(surface.pixels);
        var dst;
        var colorTable;
        var srcBytesPerPixel;
        if (surface.type === 'BC4')
            srcBytesPerPixel = 1;
        else
            srcBytesPerPixel = 2;
        if (signed) {
            dst = new Int8Array(width * height * bytesPerPixel);
            colorTable = new Int8Array(8);
        }
        else {
            dst = new Uint8Array(width * height * bytesPerPixel);
            colorTable = new Uint8Array(8);
        }
        var srcOffs = 0;
        for (var yy = 0; yy < height; yy += 4) {
            for (var xx = 0; xx < width; xx += 4) {
                for (var ch = 0; ch < srcBytesPerPixel; ch++) {
                    var red0 = void 0;
                    var red1 = void 0;
                    if (signed) {
                        red0 = view.getInt8(srcOffs + 0x00);
                        red1 = view.getInt8(srcOffs + 0x01);
                    }
                    else {
                        red0 = view.getUint8(srcOffs + 0x00);
                        red1 = view.getUint8(srcOffs + 0x01);
                    }
                    colorTable[0] = red0;
                    colorTable[1] = red1;
                    if (red0 > red1) {
                        colorTable[2] = (6 * red0 + 1 * red1) / 7;
                        colorTable[3] = (5 * red0 + 2 * red1) / 7;
                        colorTable[4] = (4 * red0 + 3 * red1) / 7;
                        colorTable[5] = (3 * red0 + 4 * red1) / 7;
                        colorTable[6] = (2 * red0 + 5 * red1) / 7;
                        colorTable[7] = (1 * red0 + 6 * red1) / 7;
                    }
                    else {
                        colorTable[2] = (4 * red0 + 1 * red1) / 5;
                        colorTable[3] = (3 * red0 + 2 * red1) / 5;
                        colorTable[4] = (2 * red0 + 3 * red1) / 5;
                        colorTable[5] = (1 * red0 + 4 * red1) / 5;
                        colorTable[6] = signed ? -128 : 0;
                        colorTable[7] = signed ? 127 : 255;
                    }
                    var colorBits0 = view.getUint32(srcOffs + 0x02, true) & 0x00FFFFFF;
                    var colorBits1 = view.getUint32(srcOffs + 0x04, true) >>> 8;
                    for (var y = 0; y < 4; y++) {
                        for (var x = 0; x < 4; x++) {
                            var dstIdx = ((yy + y) * width) + xx + x;
                            var dstOffs = (dstIdx * bytesPerPixel);
                            var fullShift = (y * 4 + x) * 3;
                            var colorBits = fullShift < 24 ? colorBits0 : colorBits1;
                            var shift = fullShift % 24;
                            var index = (colorBits >>> shift) & 0x07;
                            if (srcBytesPerPixel === 1) {
                                dst[dstOffs + 0] = colorTable[index];
                                dst[dstOffs + 1] = colorTable[index];
                                dst[dstOffs + 2] = colorTable[index];
                                dst[dstOffs + 3] = signed ? 127 : 255;
                            }
                            else {
                                if (ch === 0) {
                                    dst[dstOffs + 0] = colorTable[index];
                                }
                                else if (ch === 1) {
                                    dst[dstOffs + 1] = colorTable[index];
                                    dst[dstOffs + 2] = signed ? 127 : 255;
                                    dst[dstOffs + 3] = signed ? 127 : 255;
                                }
                            }
                        }
                    }
                    srcOffs += 0x08;
                }
            }
        }
        var pixels = dst.buffer;
        return { type: 'RGBA', flag: surface.flag, width: width, height: height, pixels: pixels };
    }
    function decompressBC(surface) {
        switch (surface.type) {
            case 'BC1':
                return decompressBC1Surface(surface);
            case 'BC3':
                return decompressBC3Surface(surface);
            case 'BC4':
            case 'BC5':
                return decompressBC45Surface(surface);
        }
    }
    exports_59("decompressBC", decompressBC);
    function deswizzleSurface(surface, texData, mipLevel) {
        return gx2_swizzle_1.deswizzler.deswizzle(surface, texData.castToBuffer(), mipLevel);
    }
    exports_59("deswizzleSurface", deswizzleSurface);
    function decodeSurface(surface, texData, mipData, mipLevel) {
        var levelData;
        if (mipLevel === 0) {
            levelData = texData;
        }
        else if (mipLevel === 1) {
            levelData = mipData;
        }
        else {
            var offset = surface.mipDataOffsets[mipLevel - 1];
            levelData = mipData.slice(offset);
        }
        var width = surface.width;
        var height = surface.height;
        return deswizzleSurface(surface, levelData, mipLevel).then(function (deswizzledSurface) {
            switch (surface.format) {
                case 49 /* BC1_UNORM */:
                    return __assign({ type: 'BC1', flag: 'UNORM' }, deswizzledSurface);
                case 1073 /* BC1_SRGB */:
                    return __assign({ type: 'BC1', flag: 'SRGB' }, deswizzledSurface);
                case 51 /* BC3_UNORM */:
                    return __assign({ type: 'BC3', flag: 'UNORM' }, deswizzledSurface);
                case 1075 /* BC3_SRGB */:
                    return __assign({ type: 'BC3', flag: 'SRGB' }, deswizzledSurface);
                case 52 /* BC4_UNORM */:
                    return __assign({ type: 'BC4', flag: 'UNORM' }, deswizzledSurface);
                case 564 /* BC4_SNORM */:
                    return __assign({ type: 'BC4', flag: 'SNORM' }, deswizzledSurface);
                case 53 /* BC5_UNORM */:
                    return __assign({ type: 'BC5', flag: 'UNORM' }, deswizzledSurface);
                case 565 /* BC5_SNORM */:
                    return __assign({ type: 'BC5', flag: 'SNORM' }, deswizzledSurface);
                case 26 /* TCS_R8_G8_B8_A8_UNORM */:
                    return __assign({ type: 'RGBA', flag: 'UNORM' }, deswizzledSurface);
                case 1050 /* TCS_R8_G8_B8_A8_SRGB */:
                    return __assign({ type: 'RGBA', flag: 'SRGB' }, deswizzledSurface);
                default:
                    throw new Error("Bad format in decodeSurface: " + surface.format.toString(16));
            }
        });
    }
    exports_59("decodeSurface", decodeSurface);
    function surfaceToCanvas(canvas, surface) {
        var ctx = canvas.getContext('2d');
        var width = surface.width;
        var height = surface.height;
        var imageData = new ImageData(width, height);
        switch (surface.type) {
            case 'RGBA':
                if (surface.flag === 'UNORM') {
                    var src = new Uint8Array(surface.pixels);
                    imageData.data.set(src);
                }
                else if (surface.flag === 'SRGB') {
                    // XXX(jstpierre): SRGB
                    var src = new Uint8Array(surface.pixels);
                    imageData.data.set(src);
                }
                else if (surface.flag === 'SNORM') {
                    var src = new Int8Array(surface.pixels);
                    var data = new Uint8Array(surface.pixels.byteLength);
                    for (var i = 0; i < src.length; i++) {
                        data[i] = src[i] + 128;
                    }
                    imageData.data.set(data);
                }
                break;
        }
        ctx.putImageData(imageData, 0, 0);
    }
    exports_59("surfaceToCanvas", surfaceToCanvas);
    function decompressSurface(texture) {
        switch (texture.type) {
            case 'RGBA':
                return texture;
            case 'BC1':
            case 'BC3':
            case 'BC4':
            case 'BC5':
                return decompressBC(texture);
        }
    }
    exports_59("decompressSurface", decompressSurface);
    var gx2_swizzle_1;
    return {
        setters: [
            function (gx2_swizzle_1_1) {
                gx2_swizzle_1 = gx2_swizzle_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("fres/render", ["fres/gx2_swizzle", "fres/gx2_texture", "render", "Program", "RenderArena", "util", "ArrayBufferSlice", "BufferCoalescer"], function (exports_60, context_60) {
    "use strict";
    var __moduleName = context_60 && context_60.id;
    function getAttribFormatInfo(format) {
        switch (format) {
            case 768 /* _8_SINT */:
                return { compCount: 1, elemSize: 1, type: WebGL2RenderingContext.BYTE, normalized: false };
            case 512 /* _8_SNORM */:
                return { compCount: 1, elemSize: 1, type: WebGL2RenderingContext.BYTE, normalized: true };
            case 256 /* _8_UINT */:
                return { compCount: 1, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: false };
            case 0 /* _8_UNORM */:
                return { compCount: 1, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: true };
            case 4 /* _8_8_UNORM */:
                return { compCount: 2, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: true };
            case 516 /* _8_8_SNORM */:
                return { compCount: 2, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: true };
            case 10 /* _8_8_8_8_UNORM */:
                return { compCount: 4, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: true };
            case 522 /* _8_8_8_8_SNORM */:
                return { compCount: 4, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: true };
            case 7 /* _16_16_UNORM */:
                return { compCount: 2, elemSize: 2, type: WebGL2RenderingContext.UNSIGNED_SHORT, normalized: true };
            case 519 /* _16_16_SNORM */:
                return { compCount: 2, elemSize: 2, type: WebGL2RenderingContext.SHORT, normalized: true };
            case 2056 /* _16_16_FLOAT */:
                return { compCount: 2, elemSize: 2, type: WebGL2RenderingContext.HALF_FLOAT, normalized: false };
            case 2063 /* _16_16_16_16_FLOAT */:
                return { compCount: 4, elemSize: 2, type: WebGL2RenderingContext.HALF_FLOAT, normalized: false };
            case 14 /* _16_16_16_16_UNORM */:
                return { compCount: 4, elemSize: 2, type: WebGL2RenderingContext.UNSIGNED_SHORT, normalized: true };
            case 526 /* _16_16_16_16_SNORM */:
                return { compCount: 4, elemSize: 2, type: WebGL2RenderingContext.SHORT, normalized: true };
            case 2061 /* _32_32_FLOAT */:
                return { compCount: 2, elemSize: 4, type: WebGL2RenderingContext.FLOAT, normalized: false };
            case 2065 /* _32_32_32_FLOAT */:
                return { compCount: 4, elemSize: 4, type: WebGL2RenderingContext.FLOAT, normalized: false };
            case 11 /* _10_10_10_2_UNORM */:
            case 523 /* _10_10_10_2_SNORM */:
                // Should be handled during the buffer load case.
                return null;
            default:
                throw new Error("Unsupported attribute format " + format);
        }
    }
    function convertVertexBufferCopy(buffer, attrib, vtxCount) {
        var stride = buffer.stride;
        util_34.assert(stride !== 0);
        var formatInfo = getAttribFormatInfo(attrib.format);
        util_34.assert(formatInfo !== null);
        var numValues = vtxCount * formatInfo.compCount;
        function getOutputBuffer() {
            if (formatInfo.elemSize === 1)
                return new Uint8Array(numValues);
            else if (formatInfo.elemSize === 2)
                return new Uint16Array(numValues);
            else if (formatInfo.elemSize === 4)
                return new Uint32Array(numValues);
            else
                throw new Error();
        }
        var dataView = buffer.data.createDataView();
        var out = getOutputBuffer();
        var offs = attrib.bufferStart;
        var dst = 0;
        for (var i = 0; i < vtxCount; i++) {
            for (var j = 0; j < formatInfo.compCount; j++) {
                var srcOffs = offs + j * formatInfo.elemSize;
                if (formatInfo.elemSize === 1)
                    out[dst] = dataView.getUint8(srcOffs);
                else if (formatInfo.elemSize === 2)
                    out[dst] = dataView.getUint16(srcOffs);
                else if (formatInfo.elemSize === 4)
                    out[dst] = dataView.getUint32(srcOffs);
                dst++;
            }
            offs += stride;
        }
        return new ArrayBufferSlice_6.default(out.buffer);
    }
    function convertVertexBuffer_10_10_10_2(buffer, attrib, vtxCount) {
        util_34.assert(buffer.stride !== 0);
        var elemSize = 4;
        var compCount = 4;
        var numValues = vtxCount * compCount;
        var signed;
        function getOutputBuffer() {
            if (attrib.format === 523 /* _10_10_10_2_SNORM */) {
                attrib.format = 526 /* _16_16_16_16_SNORM */;
                signed = true;
                return new Int16Array(numValues);
            }
            else if (attrib.format === 11 /* _10_10_10_2_UNORM */) {
                attrib.format = 14 /* _16_16_16_16_UNORM */;
                signed = false;
                return new Uint16Array(numValues);
            }
            else {
                throw new Error("whoops");
            }
        }
        var view = buffer.data.createDataView();
        var out = getOutputBuffer();
        function signExtend10(n) {
            if (signed)
                return (n << 22) >> 22;
            else
                return n;
        }
        var offs = attrib.bufferStart;
        var dst = 0;
        for (var i = 0; i < vtxCount; i++) {
            var n = view.getUint32(offs, false);
            out[dst++] = signExtend10((n >>> 0) & 0x3FF) << 4;
            out[dst++] = signExtend10((n >>> 10) & 0x3FF) << 4;
            out[dst++] = signExtend10((n >>> 20) & 0x3FF) << 4;
            out[dst++] = ((n >>> 30) & 0x03) << 14;
            offs += buffer.stride;
        }
        return new ArrayBufferSlice_6.default(out.buffer);
    }
    function convertVertexBuffer(buffer, attrib, vtxCount) {
        var formatInfo = getAttribFormatInfo(attrib.format);
        if (formatInfo !== null) {
            var byteSize = formatInfo.compCount * formatInfo.elemSize;
            if (buffer.stride <= byteSize && attrib.bufferStart === 0) {
                // Fastest path -- just endian swap.
                return buffer.data.convertFromEndianness(1 /* BIG_ENDIAN */, formatInfo.elemSize);
            }
            else {
                // Has a native WebGL equivalent, just requires us to convert strides.
                return convertVertexBufferCopy(buffer, attrib, vtxCount);
            }
        }
        else {
            // No native WebGL equivalent. Let's see what we can do...
            switch (attrib.format) {
                case 523 /* _10_10_10_2_SNORM */:
                case 11 /* _10_10_10_2_UNORM */:
                    return convertVertexBuffer_10_10_10_2(buffer, attrib, vtxCount);
            }
        }
        throw new Error("whoops");
    }
    var gx2_swizzle_2, GX2Texture, render_23, Program_10, RenderArena_3, util_34, ArrayBufferSlice_6, BufferCoalescer_2, ProgramGambit_UBER, Scene;
    return {
        setters: [
            function (gx2_swizzle_2_1) {
                gx2_swizzle_2 = gx2_swizzle_2_1;
            },
            function (GX2Texture_1) {
                GX2Texture = GX2Texture_1;
            },
            function (render_23_1) {
                render_23 = render_23_1;
            },
            function (Program_10_1) {
                Program_10 = Program_10_1;
            },
            function (RenderArena_3_1) {
                RenderArena_3 = RenderArena_3_1;
            },
            function (util_34_1) {
                util_34 = util_34_1;
            },
            function (ArrayBufferSlice_6_1) {
                ArrayBufferSlice_6 = ArrayBufferSlice_6_1;
            },
            function (BufferCoalescer_2_1) {
                BufferCoalescer_2 = BufferCoalescer_2_1;
            }
        ],
        execute: function () {
            ProgramGambit_UBER = /** @class */ (function (_super) {
                __extends(ProgramGambit_UBER, _super);
                function ProgramGambit_UBER() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.$a = ProgramGambit_UBER.attribLocations;
                    _this.vert = "\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nuniform mat4 u_view;\nlayout(location = " + _this.$a._p0 + ") in vec3 a_p0;\nlayout(location = " + _this.$a._n0 + ") in vec3 a_n0;\nlayout(location = " + _this.$a._t0 + ") in vec4 a_t0;\nlayout(location = " + _this.$a._u0 + ") in vec2 a_u0;\nlayout(location = " + _this.$a._u1 + ") in vec2 a_u1;\n\nout vec3 v_PositionWorld;\nout vec2 v_TexCoord0;\nout vec3 v_NormalWorld;\nout vec4 v_TangentWorld;\n\nout vec3 v_CameraWorld;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_p0, 1.0);\n    v_PositionWorld = a_p0.xyz;\n    v_TexCoord0 = a_u0;\n    v_NormalWorld = a_n0;\n    v_TangentWorld = a_t0;\n    // TODO(jstpierre): Don't be dumb.\n    v_CameraWorld = inverse(u_view)[3].xyz;\n}\n";
                    _this.frag = "\nuniform mat4 u_view;\n\nuniform sampler2D s_a0;\nuniform sampler2D s_n0;\nuniform sampler2D s_e0;\nuniform sampler2D s_s0;\n\nin vec3 v_PositionWorld;\nin vec2 v_TexCoord0;\nin vec3 v_NormalWorld;\nin vec4 v_TangentWorld;\n\nin vec3 v_CameraWorld;\n\nvec4 textureSRGB(sampler2D s, vec2 uv) {\n    vec4 srgba = texture(s, uv);\n    vec3 srgb = srgba.rgb;\n    // XXX(jstpierre): Turn sRGB texturing back on at some point...\n#ifndef NOPE_HAS_WEBGL_compressed_texture_s3tc_srgb\n    vec3 rgb = srgb;\n#else\n    // http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\n    vec3 rgb = srgb * (srgb * (srgb * 0.305306011 + 0.682171111) + 0.012522878);\n#endif\n    return vec4(rgb, srgba.a);\n}\n\nvoid main() {\n    vec4 tx_albedo0  = textureSRGB(s_a0, v_TexCoord0);\n    vec4 tx_emissive = textureSRGB(s_e0, v_TexCoord0);\n    vec4 tx_normal   = textureSRGB(s_n0, v_TexCoord0);\n    vec4 tx_specular = textureSRGB(s_s0, v_TexCoord0);\n\n    // Perturb normal with map.\n    vec3 nrm = v_NormalWorld.xyz;\n    vec3 tan = normalize(v_TangentWorld.xyz);\n    vec3 btn = cross(nrm, tan) * v_TangentWorld.w;\n\n    vec3 local_nrm = vec3(tx_normal.xy, 0);\n    float len2 = 1.0 - local_nrm.x*local_nrm.x - local_nrm.y*local_nrm.y;\n    local_nrm.z = sqrt(clamp(len2, 0.0, 1.0));\n    vec3 normal_dir = (local_nrm.x * tan + local_nrm.y * btn + local_nrm.z * nrm);\n\n    vec3 view_dir = normalize(v_PositionWorld.xyz - v_CameraWorld);\n    vec3 refl_dir = reflect(-view_dir, normal_dir);\n\n    // Calulate incident light.\n    float diffuse = 0.0;\n    float specular = 0.0;\n\n    // Basic directional lighting.\n    vec3 d_light_dir = normalize(vec3(-u_view[2].x, 0.0, u_view[2].z));\n    // Sky-ish color. If we were better we would use a cubemap...\n    const vec3 d_light_col = vec3(0.9, 0.9, 1.4);\n    const float spec_power = 35.0;\n\n    diffuse += clamp(dot(normal_dir, d_light_dir), 0.0, 1.0);\n    specular += pow(clamp(dot(refl_dir, d_light_dir), 0.0, 1.0), spec_power);\n\n    // Dumb constant ambient.\n    diffuse += 0.6;\n    specular += 0.012;\n\n    vec3 diffuse_light = d_light_col * diffuse;\n    vec3 specular_light = d_light_col * specular * tx_specular.x;\n\n    vec4 albedo = tx_albedo0;\n    // TODO(jstpierre): Multitex?\n\n    o_color = vec4(0, 0, 0, 0);\n    o_color.rgb += albedo.rgb * diffuse_light;\n    o_color.rgb += specular_light;\n    o_color.a = albedo.a;\n\n    // TODO(jstpierre): Configurable alpha test\n    if (o_color.a < 0.5)\n        discard;\n\n    o_color.rgb += tx_emissive.rgb;\n\n    // Gamma correction.\n    o_color.rgb = pow(o_color.rgb, vec3(1.0 / 2.2));\n}\n";
                    return _this;
                }
                ProgramGambit_UBER.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.u_view = gl.getUniformLocation(prog, "u_view");
                    this.s_a0 = gl.getUniformLocation(prog, "s_a0");
                    this.s_e0 = gl.getUniformLocation(prog, "s_e0");
                    this.s_n0 = gl.getUniformLocation(prog, "s_n0");
                    this.s_s0 = gl.getUniformLocation(prog, "s_s0");
                };
                ProgramGambit_UBER.prototype.getTextureUniformLocation = function (name) {
                    if (name === "_a0")
                        return this.s_a0;
                    else if (name === "_e0")
                        return this.s_e0;
                    else if (name === "_n0")
                        return this.s_n0;
                    else if (name === "_s0")
                        return this.s_s0;
                    else
                        return null;
                };
                ProgramGambit_UBER.attribLocations = {
                    _p0: 0,
                    _n0: 1,
                    _t0: 2,
                    _u0: 3,
                    _u1: 4,
                };
                return ProgramGambit_UBER;
            }(Program_10.default));
            Scene = /** @class */ (function () {
                function Scene(gl, fres, isSkybox) {
                    this.fres = fres;
                    this.isSkybox = isSkybox;
                    this.prog = new ProgramGambit_UBER();
                    this.fres = fres;
                    this.arena = new RenderArena_3.default();
                    this.blankTexture = this.arena.createTexture(gl);
                    gl.bindTexture(gl.TEXTURE_2D, this.blankTexture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
                    this.textures = [];
                    this.modelFuncs = this.translateFRES(gl, this.fres);
                }
                Scene.prototype.translateFVTXBuffers = function (fvtx, vertexDatas) {
                    for (var i = 0; i < fvtx.attribs.length; i++) {
                        var attrib = fvtx.attribs[i];
                        var location_1 = ProgramGambit_UBER.attribLocations[attrib.name];
                        if (location_1 === undefined)
                            continue;
                        var buffer = fvtx.buffers[attrib.bufferIndex];
                        // Convert the vertex buffer data into a loadable format... might edit "attrib"
                        // if it has to load a non-WebGL-native format...
                        var vertexData = convertVertexBuffer(buffer, attrib, fvtx.vtxCount);
                        vertexDatas.push(vertexData);
                    }
                };
                Scene.prototype.translateFVTX = function (gl, fvtx, coalescedVertex) {
                    var vao = this.arena.createVertexArray(gl);
                    gl.bindVertexArray(vao);
                    for (var i = 0; i < fvtx.attribs.length; i++) {
                        var attrib = fvtx.attribs[i];
                        var location_2 = ProgramGambit_UBER.attribLocations[attrib.name];
                        if (location_2 === undefined)
                            continue;
                        var formatInfo = getAttribFormatInfo(attrib.format);
                        var buffer = coalescedVertex.shift();
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer);
                        gl.vertexAttribPointer(location_2, formatInfo.compCount, formatInfo.type, formatInfo.normalized, 0, buffer.offset);
                        gl.enableVertexAttribArray(location_2);
                    }
                    return vao;
                };
                Scene.prototype.translateTexClamp = function (gl, clampMode) {
                    switch (clampMode) {
                        case 2 /* CLAMP */:
                            return gl.CLAMP_TO_EDGE;
                        case 0 /* WRAP */:
                            return gl.REPEAT;
                        case 1 /* MIRROR */:
                            return gl.MIRRORED_REPEAT;
                        default:
                            throw new Error("Unknown tex clamp mode " + clampMode);
                    }
                };
                Scene.prototype.translateTexFilter = function (gl, filter, mipFilter) {
                    if (mipFilter === 2 /* LINEAR */ && filter === 1 /* BILINEAR */)
                        return gl.LINEAR_MIPMAP_LINEAR;
                    if (mipFilter === 2 /* LINEAR */ && filter === 0 /* POINT */)
                        return gl.NEAREST_MIPMAP_LINEAR;
                    if (mipFilter === 1 /* POINT */ && filter === 1 /* BILINEAR */)
                        return gl.LINEAR_MIPMAP_NEAREST;
                    if (mipFilter === 1 /* POINT */ && filter === 0 /* POINT */)
                        return gl.NEAREST_MIPMAP_LINEAR;
                    if (mipFilter === 0 /* NO_MIP */ && filter === 1 /* BILINEAR */)
                        return gl.LINEAR;
                    if (mipFilter === 0 /* NO_MIP */ && filter === 0 /* POINT */)
                        return gl.NEAREST;
                    throw new Error("Unknown texture filter mode");
                };
                Scene.prototype.translateFrontFaceMode = function (frontFaceMode) {
                    switch (frontFaceMode) {
                        case 0 /* CCW */:
                            return render_23.FrontFaceMode.CCW;
                        case 1 /* CW */:
                            return render_23.FrontFaceMode.CW;
                    }
                };
                Scene.prototype.translateCompareFunction = function (compareFunc) {
                    switch (compareFunc) {
                        case 0 /* NEVER */:
                            return render_23.CompareMode.NEVER;
                        case 1 /* LESS */:
                            return render_23.CompareMode.LESS;
                        case 2 /* EQUAL */:
                            return render_23.CompareMode.EQUAL;
                        case 3 /* LEQUAL */:
                            return render_23.CompareMode.LEQUAL;
                        case 4 /* GREATER */:
                            return render_23.CompareMode.GREATER;
                        case 5 /* NOTEQUAL */:
                            return render_23.CompareMode.NEQUAL;
                        case 6 /* GEQUAL */:
                            return render_23.CompareMode.GEQUAL;
                        case 7 /* ALWAYS */:
                            return render_23.CompareMode.ALWAYS;
                    }
                };
                Scene.prototype.translateCullMode = function (cullFront, cullBack) {
                    if (cullFront && cullBack)
                        return render_23.CullMode.FRONT_AND_BACK;
                    else if (cullFront)
                        return render_23.CullMode.FRONT;
                    else if (cullBack)
                        return render_23.CullMode.BACK;
                    else
                        return render_23.CullMode.NONE;
                };
                Scene.prototype.translateRenderState = function (renderState) {
                    var renderFlags = new render_23.RenderFlags();
                    renderFlags.frontFace = this.translateFrontFaceMode(renderState.frontFaceMode);
                    renderFlags.depthTest = renderState.depthTest;
                    renderFlags.depthFunc = this.translateCompareFunction(renderState.depthCompareFunc);
                    renderFlags.depthWrite = renderState.depthWrite;
                    renderFlags.cullMode = this.translateCullMode(renderState.cullFront, renderState.cullBack);
                    return renderFlags;
                };
                Scene.prototype.translateFMAT = function (gl, fmat) {
                    var _this = this;
                    var attribNames = ['_a0', '_e0', '_n0', '_s0'];
                    var textureAssigns = fmat.textureAssigns.filter(function (textureAssign) {
                        return attribNames.includes(textureAssign.attribName);
                    });
                    var samplers = [];
                    try {
                        for (var textureAssigns_1 = __values(textureAssigns), textureAssigns_1_1 = textureAssigns_1.next(); !textureAssigns_1_1.done; textureAssigns_1_1 = textureAssigns_1.next()) {
                            var textureAssign = textureAssigns_1_1.value;
                            var sampler = this.arena.createSampler(gl);
                            gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, this.translateTexClamp(gl, textureAssign.texClampU));
                            gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, this.translateTexClamp(gl, textureAssign.texClampV));
                            // XXX(jstpierre): Introduce this when we start decoding mipmaps.
                            var texFilterMip = 0 /* NO_MIP */;
                            gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, this.translateTexFilter(gl, textureAssign.texFilterMag, texFilterMip));
                            gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, this.translateTexFilter(gl, textureAssign.texFilterMin, texFilterMip));
                            samplers.push(sampler);
                        }
                    }
                    catch (e_48_1) { e_48 = { error: e_48_1 }; }
                    finally {
                        try {
                            if (textureAssigns_1_1 && !textureAssigns_1_1.done && (_a = textureAssigns_1.return)) _a.call(textureAssigns_1);
                        }
                        finally { if (e_48) throw e_48.error; }
                    }
                    // const prog = new ProgramGambit_UBER();
                    // this.arena.trackProgram(prog);
                    var prog = this.prog;
                    var renderFlags = this.translateRenderState(fmat.renderState);
                    return function (state) {
                        state.useProgram(prog);
                        state.bindModelView(_this.isSkybox);
                        gl.uniformMatrix4fv(prog.u_view, false, state.view);
                        state.useFlags(renderFlags);
                        var _loop_10 = function (i) {
                            var attribName = attribNames[i];
                            gl.activeTexture(gl.TEXTURE0 + i);
                            var uniformLocation = prog.getTextureUniformLocation(attribName);
                            gl.uniform1i(uniformLocation, i);
                            var textureAssignIndex = textureAssigns.findIndex(function (textureAssign) { return textureAssign.attribName === attribName; });
                            var bound = false;
                            if (textureAssignIndex >= 0) {
                                var textureAssign_1 = textureAssigns[textureAssignIndex];
                                var ftexIndex = _this.fres.textures.findIndex(function (textureEntry) { return textureEntry.entry.offs === textureAssign_1.ftexOffs; });
                                if (ftexIndex >= 0) {
                                    var ftex = _this.fres.textures[ftexIndex];
                                    util_34.assert(ftex.entry.name === textureAssign_1.textureName);
                                    var glTexture = _this.glTextures[ftexIndex];
                                    gl.bindTexture(gl.TEXTURE_2D, glTexture);
                                    var sampler = samplers[textureAssignIndex];
                                    gl.bindSampler(i, sampler);
                                    bound = true;
                                }
                            }
                            if (!bound) {
                                // If we have no binding for this texture, replace it with something harmless...
                                gl.bindTexture(gl.TEXTURE_2D, _this.blankTexture);
                            }
                        };
                        // Textures.
                        for (var i = 0; i < attribNames.length; i++) {
                            _loop_10(i);
                        }
                    };
                    var e_48, _a;
                };
                Scene.prototype.translateIndexBuffer = function (indexFormat, indexBufferData) {
                    switch (indexFormat) {
                        case 0 /* U16_LE */:
                        case 1 /* U32_LE */:
                            return indexBufferData;
                        case 4 /* U16 */:
                            return indexBufferData.convertFromEndianness(1 /* BIG_ENDIAN */, 2);
                        case 9 /* U32 */:
                            return indexBufferData.convertFromEndianness(1 /* BIG_ENDIAN */, 4);
                    }
                };
                Scene.prototype.translateFSHPBuffers = function (fshp, indexDatas) {
                    try {
                        for (var _a = __values(fshp.meshes), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var mesh = _b.value;
                            util_34.assert(mesh.indexBufferData.stride === 0);
                            var indexData = this.translateIndexBuffer(mesh.indexFormat, mesh.indexBufferData.data);
                            indexDatas.push(indexData);
                        }
                    }
                    catch (e_49_1) { e_49 = { error: e_49_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_49) throw e_49.error; }
                    }
                    var e_49, _c;
                };
                Scene.prototype.translateIndexFormat = function (gl, indexFormat) {
                    // Little-endian translation was done above.
                    switch (indexFormat) {
                        case 4 /* U16 */:
                        case 0 /* U16_LE */:
                            return gl.UNSIGNED_SHORT;
                        case 9 /* U32 */:
                        case 1 /* U32_LE */:
                            return gl.UNSIGNED_INT;
                        default:
                            throw new Error("Unsupported index format " + indexFormat);
                    }
                };
                Scene.prototype.translatePrimType = function (gl, primType) {
                    switch (primType) {
                        case 4 /* TRIANGLES */:
                            return gl.TRIANGLES;
                        default:
                            throw new Error("Unsupported primitive type " + primType);
                    }
                };
                Scene.prototype.translateFSHP = function (gl, fshp, coalescedIndex) {
                    var _this = this;
                    var glIndexBuffers = [];
                    try {
                        for (var _a = __values(fshp.meshes), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var mesh = _b.value;
                            glIndexBuffers.push(coalescedIndex.shift());
                        }
                    }
                    catch (e_50_1) { e_50 = { error: e_50_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_50) throw e_50.error; }
                    }
                    return function (state) {
                        var lod = 0;
                        var mesh = fshp.meshes[lod];
                        var glIndexBuffer = glIndexBuffers[lod];
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glIndexBuffer.buffer);
                        try {
                            for (var _a = __values(mesh.submeshes), _b = _a.next(); !_b.done; _b = _a.next()) {
                                var submesh = _b.value;
                                gl.drawElements(_this.translatePrimType(gl, mesh.primType), submesh.indexBufferCount, _this.translateIndexFormat(gl, mesh.indexFormat), glIndexBuffer.offset + submesh.indexBufferOffset);
                            }
                        }
                        catch (e_51_1) { e_51 = { error: e_51_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                            }
                            finally { if (e_51) throw e_51.error; }
                        }
                        var e_51, _c;
                    };
                    var e_50, _c;
                };
                Scene.prototype.translateModel = function (gl, model, coalescedVertex, coalescedIndex) {
                    var _this = this;
                    var fmdl = model.fmdl;
                    var fvtxVaos = fmdl.fvtx.map(function (fvtx) { return _this.translateFVTX(gl, fvtx, coalescedVertex); });
                    var fmatFuncs = fmdl.fmat.map(function (fmat) { return _this.translateFMAT(gl, fmat); });
                    var fshpFuncs = fmdl.fshp.map(function (fshp) { return _this.translateFSHP(gl, fshp, coalescedIndex); });
                    return function (state) {
                        // _drcmap is the map used for the Gamepad. It does nothing but cause Z-fighting.
                        if (model.entry.name.endsWith('_drcmap'))
                            return;
                        // "_DV" seems to be the skybox. There are additional models which are powered
                        // by skeleton animation, which we don't quite support yet. Kill them for now.
                        if (model.entry.name.indexOf('_DV_') !== -1)
                            return;
                        var gl = state.gl;
                        for (var i = 0; i < fmdl.fshp.length; i++) {
                            var fshp = fmdl.fshp[i];
                            // XXX(jstpierre): Sun is dynamically moved by the game engine, I think...
                            // ... unless it's SKL animation. For now, skip it.
                            if (fshp.name === 'Sun__VRL_Sun')
                                continue;
                            gl.bindVertexArray(fvtxVaos[fshp.fvtxIndex]);
                            // Set up our material state.
                            fmatFuncs[fshp.fmatIndex](state);
                            // Draw our meshes.
                            fshpFuncs[i](state);
                        }
                    };
                };
                Scene.prototype.getCompressedFormat = function (gl, tex) {
                    switch (tex.type) {
                        case 'BC4':
                        case 'BC5':
                            return null;
                    }
                    var ext_compressed_texture_s3tc = gl.getExtension('WEBGL_compressed_texture_s3tc');
                    // const ext_compressed_texture_s3tc_srgb = gl.getExtension('WEBGL_compressed_texture_s3tc_srgb');
                    // XXX(jstpierre): Don't use sRGB for now since we sometimes fall back to SW decode.
                    /*
                    if (tex.flag === 'SRGB' && ext_compressed_texture_s3tc_srgb) {
                        switch (tex.type) {
                        case 'BC1':
                            return ext_compressed_texture_s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        case 'BC3':
                            return ext_compressed_texture_s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                        }
                    }
                    */
                    if (ext_compressed_texture_s3tc) {
                        switch (tex.type) {
                            case 'BC1':
                                return ext_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            case 'BC3':
                                return ext_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                        }
                    }
                    return null;
                };
                Scene.prototype.translateTexture = function (gl, textureEntry) {
                    var _this = this;
                    var glTexture = this.arena.createTexture(gl);
                    gl.bindTexture(gl.TEXTURE_2D, glTexture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAX_LEVEL, 0);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
                    var texture = textureEntry.texture;
                    var surface = texture.surface;
                    var canvases = [];
                    var _loop_11 = function (i) {
                        var mipLevel = i;
                        var canvas = document.createElement('canvas');
                        canvas.width = 0;
                        canvas.height = 0;
                        canvases.push(canvas);
                        GX2Texture.decodeSurface(surface, texture.texData, texture.mipData, mipLevel).then(function (decodedSurface) {
                            // Sometimes the surfaces appear to have garbage sizes.
                            if (decodedSurface.width === 0 || decodedSurface.height === 0)
                                return;
                            gl.bindTexture(gl.TEXTURE_2D, glTexture);
                            // Decodes should show up in order, thanks to priority. Change this if we ever
                            // change the logic, because it is indeed sketchy...
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAX_LEVEL, mipLevel);
                            // XXX(jstpierre): Sometimes Splatoon uses non-block-sized textures. OpenGL does
                            // not like this one bit. If this is the case, decompress in software.
                            var isBlockSized = !!(texture.surface.width & 0x03) || !!(texture.surface.height & 0x03);
                            // First check if we have to decompress compressed textures.
                            switch (decodedSurface.type) {
                                case "BC1":
                                case "BC3":
                                case "BC4":
                                case "BC5":
                                    var compressedFormat = _this.getCompressedFormat(gl, decodedSurface);
                                    if (compressedFormat === null || !isBlockSized)
                                        decodedSurface = GX2Texture.decompressBC(decodedSurface);
                                    break;
                            }
                            var pixels = decodedSurface.pixels;
                            var width = decodedSurface.width;
                            var height = decodedSurface.height;
                            util_34.assert(pixels.byteLength > 0);
                            switch (decodedSurface.type) {
                                case "RGBA": {
                                    var internalFormat = decodedSurface.flag === 'SRGB' ? gl.SRGB8_ALPHA8 : decodedSurface.flag === 'SNORM' ? gl.RGBA8_SNORM : gl.RGBA8;
                                    var type = decodedSurface.flag === 'SNORM' ? gl.BYTE : gl.UNSIGNED_BYTE;
                                    var data = decodedSurface.flag === 'SNORM' ? new Int8Array(pixels) : new Uint8Array(pixels);
                                    gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, width, height, 0, gl.RGBA, type, data);
                                    break;
                                }
                                case "BC1":
                                case "BC3":
                                case "BC4":
                                case "BC5": {
                                    var compressedFormat = _this.getCompressedFormat(gl, decodedSurface);
                                    util_34.assert(compressedFormat !== null);
                                    gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, compressedFormat, width, height, 0, new Uint8Array(pixels));
                                    break;
                                }
                            }
                            // XXX(jstpierre): Do this on a worker as well?
                            var canvas = canvases[mipLevel];
                            var decompressedSurface = GX2Texture.decompressSurface(decodedSurface);
                            canvas.width = decompressedSurface.width;
                            canvas.height = decompressedSurface.height;
                            canvas.title = textureEntry.entry.name + " " + surface.format + " (" + surface.width + "x" + surface.height + ")";
                            GX2Texture.surfaceToCanvas(canvas, decompressedSurface);
                        });
                    };
                    for (var i = 0; i < surface.numMips; i++) {
                        _loop_11(i);
                    }
                    this.textures.push({ name: textureEntry.entry.name, surfaces: canvases });
                    return glTexture;
                };
                Scene.prototype.translateModelBuffers = function (modelEntry, vertexDatas, indexDatas) {
                    var _this = this;
                    // Translate vertex data.
                    modelEntry.fmdl.fvtx.forEach(function (fvtx) { return _this.translateFVTXBuffers(fvtx, vertexDatas); });
                    modelEntry.fmdl.fshp.forEach(function (fshp) { return _this.translateFSHPBuffers(fshp, indexDatas); });
                };
                Scene.prototype.translateFRES = function (gl, fres) {
                    var _this = this;
                    this.glTextures = fres.textures.map(function (ftex) { return _this.translateTexture(gl, ftex); });
                    // Gather buffers.
                    var vertexDatas = [];
                    var indexDatas = [];
                    fres.models.forEach(function (modelEntry) {
                        _this.translateModelBuffers(modelEntry, vertexDatas, indexDatas);
                    });
                    var coalescedVertex = BufferCoalescer_2.coalesceBuffer(gl, gl.ARRAY_BUFFER, vertexDatas);
                    var coalescedIndex = BufferCoalescer_2.coalesceBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, indexDatas);
                    this.arena.buffers.push(coalescedVertex[0].buffer);
                    this.arena.buffers.push(coalescedIndex[0].buffer);
                    return fres.models.map(function (modelEntry) { return _this.translateModel(gl, modelEntry, coalescedVertex, coalescedIndex); });
                };
                Scene.prototype.render = function (state) {
                    this.modelFuncs.forEach(function (func) {
                        func(state);
                    });
                };
                Scene.prototype.destroy = function (gl) {
                    // Tear down the deswizzle workers.
                    gx2_swizzle_2.deswizzler.terminate();
                    this.arena.destroy(gl);
                };
                return Scene;
            }());
            exports_60("Scene", Scene);
        }
    };
});
System.register("fres/scenes", ["fres/bfres", "fres/sarc", "compression/Yaz0", "fres/render", "util"], function (exports_61, context_61) {
    "use strict";
    var __moduleName = context_61 && context_61.id;
    function collectTextures(scenes) {
        var textures = [];
        try {
            for (var scenes_5 = __values(scenes), scenes_5_1 = scenes_5.next(); !scenes_5_1.done; scenes_5_1 = scenes_5.next()) {
                var scene = scenes_5_1.value;
                if (scene)
                    textures.push.apply(textures, scene.textures);
            }
        }
        catch (e_52_1) { e_52 = { error: e_52_1 }; }
        finally {
            try {
                if (scenes_5_1 && !scenes_5_1.done && (_a = scenes_5.return)) _a.call(scenes_5);
            }
            finally { if (e_52) throw e_52.error; }
        }
        return textures;
        var e_52, _a;
    }
    function createSceneFromFRESBuffer(gl, buffer, isSkybox) {
        if (isSkybox === void 0) { isSkybox = false; }
        var fres = BFRES.parse(buffer);
        return new FRESRenderer(new render_24.Scene(gl, fres, isSkybox));
    }
    exports_61("createSceneFromFRESBuffer", createSceneFromFRESBuffer);
    function createSceneFromSARCBuffer(gl, buffer, isSkybox) {
        if (isSkybox === void 0) { isSkybox = false; }
        return Promise.resolve(buffer).then(function (buffer) {
            if (util_35.readString(buffer, 0, 4) === 'Yaz0')
                return Yaz0.decompress(buffer);
            else
                return buffer;
        }).then(function (buffer) {
            var sarc = SARC.parse(buffer);
            var file = sarc.files.find(function (file) { return file.name.endsWith('.bfres'); });
            return createSceneFromFRESBuffer(gl, file.buffer, isSkybox);
        });
    }
    exports_61("createSceneFromSARCBuffer", createSceneFromSARCBuffer);
    var BFRES, SARC, Yaz0, render_24, util_35, FRESRenderer;
    return {
        setters: [
            function (BFRES_1) {
                BFRES = BFRES_1;
            },
            function (SARC_1) {
                SARC = SARC_1;
            },
            function (Yaz0_5) {
                Yaz0 = Yaz0_5;
            },
            function (render_24_1) {
                render_24 = render_24_1;
            },
            function (util_35_1) {
                util_35 = util_35_1;
            }
        ],
        execute: function () {
            FRESRenderer = /** @class */ (function () {
                function FRESRenderer(mainScene) {
                    this.mainScene = mainScene;
                    this.textures = collectTextures([this.mainScene]);
                }
                FRESRenderer.prototype.render = function (state) {
                    var gl = state.gl;
                    state.setClipPlanes(0.2, 500000);
                    if (this.mainScene) {
                        this.mainScene.render(state);
                    }
                };
                FRESRenderer.prototype.destroy = function (gl) {
                    if (this.mainScene)
                        this.mainScene.destroy(gl);
                };
                return FRESRenderer;
            }());
        }
    };
});
System.register("fres/splatoon_scenes", ["fres/scenes", "Progressable", "util"], function (exports_62, context_62) {
    "use strict";
    var __moduleName = context_62 && context_62.id;
    function collectTextures(scenes) {
        var textures = [];
        try {
            for (var scenes_6 = __values(scenes), scenes_6_1 = scenes_6.next(); !scenes_6_1.done; scenes_6_1 = scenes_6.next()) {
                var scene = scenes_6_1.value;
                if (scene)
                    textures.push.apply(textures, scene.textures);
            }
        }
        catch (e_53_1) { e_53 = { error: e_53_1 }; }
        finally {
            try {
                if (scenes_6_1 && !scenes_6_1.done && (_a = scenes_6.return)) _a.call(scenes_6);
            }
            finally { if (e_53) throw e_53.error; }
        }
        return textures;
        var e_53, _a;
    }
    var scenes_7, Progressable_6, util_36, SplatoonRenderer, SplatoonSceneDesc, name, id, sceneDescs, sceneGroup;
    return {
        setters: [
            function (scenes_7_1) {
                scenes_7 = scenes_7_1;
            },
            function (Progressable_6_1) {
                Progressable_6 = Progressable_6_1;
            },
            function (util_36_1) {
                util_36 = util_36_1;
            }
        ],
        execute: function () {
            SplatoonRenderer = /** @class */ (function () {
                function SplatoonRenderer(mainScene, skyScene) {
                    this.mainScene = mainScene;
                    this.skyScene = skyScene;
                    this.textures = collectTextures([this.mainScene, this.skyScene]);
                }
                SplatoonRenderer.prototype.render = function (state) {
                    var gl = state.gl;
                    state.setClipPlanes(0.2, 500000);
                    if (this.skyScene) {
                        this.skyScene.render(state);
                    }
                    gl.clear(gl.DEPTH_BUFFER_BIT);
                    if (this.mainScene) {
                        this.mainScene.render(state);
                    }
                };
                SplatoonRenderer.prototype.destroy = function (gl) {
                    if (this.skyScene)
                        this.skyScene.destroy(gl);
                    if (this.mainScene)
                        this.mainScene.destroy(gl);
                };
                return SplatoonRenderer;
            }());
            SplatoonSceneDesc = /** @class */ (function () {
                function SplatoonSceneDesc(name, path) {
                    this.name = name;
                    this.path = path;
                    this.id = this.path;
                }
                SplatoonSceneDesc.prototype.createScene = function (gl) {
                    return Progressable_6.default.all([
                        this._createSceneFromPath(gl, "data/spl/" + this.path, false),
                        this._createSceneFromPath(gl, 'data/spl/VR_SkyDayCumulonimbus.szs', true),
                    ]).then(function (scenes) {
                        var _a = __read(scenes, 2), mainScene = _a[0], skyScene = _a[1];
                        return new SplatoonRenderer(mainScene, skyScene);
                    });
                };
                SplatoonSceneDesc.prototype._createSceneFromPath = function (gl, path, isSkybox) {
                    return util_36.fetch(path).then(function (result) {
                        return scenes_7.createSceneFromSARCBuffer(gl, result, isSkybox);
                    });
                };
                return SplatoonSceneDesc;
            }());
            // Splatoon Models
            name = "Splatoon";
            id = "splatoon";
            sceneDescs = [
                new SplatoonSceneDesc('Inkopolis Plaza', 'Fld_Plaza00.szs'),
                new SplatoonSceneDesc('Inkopolis Plaza Lobby', 'Fld_PlazaLobby.szs'),
                new SplatoonSceneDesc('Ancho-V Games', 'Fld_Office00.szs'),
                new SplatoonSceneDesc('Arrowana Mall', 'Fld_UpDown00.szs'),
                new SplatoonSceneDesc('Blackbelly Skatepark', 'Fld_SkatePark00.szs'),
                new SplatoonSceneDesc('Bluefin Depot', 'Fld_Ruins00.szs'),
                new SplatoonSceneDesc('Camp Triggerfish', 'Fld_Athletic00.szs'),
                new SplatoonSceneDesc('Flounder Heights', 'Fld_Jyoheki00.szs'),
                new SplatoonSceneDesc('Hammerhead Bridge', 'Fld_Kaisou00.szs'),
                new SplatoonSceneDesc('Kelp Dome', 'Fld_Maze00.szs'),
                new SplatoonSceneDesc('Mahi-Mahi Resort', 'Fld_Hiagari00.szs'),
                new SplatoonSceneDesc('Moray Towers', 'Fld_Tuzura00.szs'),
                new SplatoonSceneDesc('Museum d\'Alfonsino', 'Fld_Pivot00.szs'),
                new SplatoonSceneDesc('Pirahna Pit', 'Fld_Quarry00.szs'),
                new SplatoonSceneDesc('Port Mackerel', 'Fld_Amida00.szs'),
                new SplatoonSceneDesc('Saltspray Rig', 'Fld_SeaPlant00.szs'),
                new SplatoonSceneDesc('Urchin Underpass (New)', 'Fld_Crank01.szs'),
                new SplatoonSceneDesc('Urchin Underpass (Old)', 'Fld_Crank00.szs'),
                new SplatoonSceneDesc('Walleye Warehouse', 'Fld_Warehouse00.szs'),
                new SplatoonSceneDesc('Octo Valley', 'Fld_World00.szs'),
                new SplatoonSceneDesc('Object: Tree', 'Obj_Tree02.szs'),
            ];
            exports_62("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
System.register("dksiv/iv", [], function (exports_63, context_63) {
    "use strict";
    var __moduleName = context_63 && context_63.id;
    function parseIV(buffer) {
        var view = buffer.createDataView();
        var numChunks = view.getUint32(0x00, true);
        var r = view.getFloat32(0x04, true);
        var g = view.getFloat32(0x08, true);
        var b = view.getFloat32(0x0C, true);
        var color = new Float32Array([r, g, b]);
        var chunks = [];
        var chunkTableIdx = 0x10;
        for (var i = 0; i < numChunks; i++) {
            var idxDataOffs = view.getUint32(chunkTableIdx + 0x00, true);
            var idxDataCount = view.getUint32(chunkTableIdx + 0x04, true);
            var posDataOffs = view.getUint32(chunkTableIdx + 0x08, true);
            var posDataCount = view.getUint32(chunkTableIdx + 0x0C, true);
            var indexData = buffer.createTypedArray(Uint16Array, idxDataOffs, idxDataCount);
            var positionData = buffer.createTypedArray(Float32Array, posDataOffs, posDataCount * 3);
            chunks.push({ indexData: indexData, positionData: positionData });
            chunkTableIdx += 0x10;
        }
        return { color: color, chunks: chunks };
    }
    exports_63("parseIV", parseIV);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("dksiv/render", ["gl-matrix", "render", "Program"], function (exports_64, context_64) {
    "use strict";
    var __moduleName = context_64 && context_64.id;
    var gl_matrix_14, render_25, Program_11, IVProgram, Chunk, Scene;
    return {
        setters: [
            function (gl_matrix_14_1) {
                gl_matrix_14 = gl_matrix_14_1;
            },
            function (render_25_1) {
                render_25 = render_25_1;
            },
            function (Program_11_1) {
                Program_11 = Program_11_1;
            }
        ],
        execute: function () {
            IVProgram = /** @class */ (function (_super) {
                __extends(IVProgram, _super);
                function IVProgram() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.vert = "\nprecision mediump float;\n\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\n\nlayout(location = " + IVProgram.a_Position + ") attribute vec3 a_Position;\nlayout(location = " + IVProgram.a_Normal + ") attribute vec3 a_Normal;\n\nout vec3 v_Normal;\n\nvoid main() {\n    const float t_ModelScale = 20.0;\n    gl_Position = u_projection * u_modelView * vec4(a_Position * t_ModelScale, 1.0);\n    v_Normal = a_Normal;\n}\n";
                    _this.frag = "\nprecision mediump float;\n\nuniform vec3 u_Color;\n\nin vec3 v_Normal;\n\nvoid main() {\n    vec3 u_LightDirection = normalize(vec3(.2, -1, .5));\n    float t_LightIntensity = dot(-v_Normal, u_LightDirection);\n    vec3 t_LightColor = t_LightIntensity * vec3(0.3);\n    gl_FragColor = vec4(u_Color + t_LightColor, 1.0);\n}\n";
                    return _this;
                }
                IVProgram.prototype.bind = function (gl, prog) {
                    _super.prototype.bind.call(this, gl, prog);
                    this.u_Color = gl.getUniformLocation(prog, 'u_Color');
                };
                IVProgram.a_Position = 0;
                IVProgram.a_Normal = 1;
                return IVProgram;
            }(Program_11.default));
            Chunk = /** @class */ (function () {
                function Chunk(gl, chunk) {
                    this.chunk = chunk;
                    this.createTopology(gl, chunk);
                }
                Chunk.prototype.createTopology = function (gl, chunk) {
                    // Run through our data, calculate normals and such.
                    var t = gl_matrix_14.vec3.create();
                    var posData = new Float32Array(chunk.indexData.length * 3);
                    var nrmData = new Float32Array(chunk.indexData.length * 3);
                    for (var i = 0; i < chunk.indexData.length; i += 3) {
                        var i0 = chunk.indexData[i + 0];
                        var i1 = chunk.indexData[i + 1];
                        var i2 = chunk.indexData[i + 2];
                        var t0x = chunk.positionData[i0 * 3 + 0];
                        var t0y = chunk.positionData[i0 * 3 + 1];
                        var t0z = chunk.positionData[i0 * 3 + 2];
                        var t1x = chunk.positionData[i1 * 3 + 0];
                        var t1y = chunk.positionData[i1 * 3 + 1];
                        var t1z = chunk.positionData[i1 * 3 + 2];
                        var t2x = chunk.positionData[i2 * 3 + 0];
                        var t2y = chunk.positionData[i2 * 3 + 1];
                        var t2z = chunk.positionData[i2 * 3 + 2];
                        gl_matrix_14.vec3.cross(t, [t0x - t1x, t0y - t1y, t0z - t1z], [t0x - t2x, t0y - t2y, t0z - t2z]);
                        gl_matrix_14.vec3.normalize(t, t);
                        posData[(i + 0) * 3 + 0] = t0x;
                        posData[(i + 0) * 3 + 1] = t0y;
                        posData[(i + 0) * 3 + 2] = t0z;
                        posData[(i + 1) * 3 + 0] = t1x;
                        posData[(i + 1) * 3 + 1] = t1y;
                        posData[(i + 1) * 3 + 2] = t1z;
                        posData[(i + 2) * 3 + 0] = t2x;
                        posData[(i + 2) * 3 + 1] = t2y;
                        posData[(i + 2) * 3 + 2] = t2z;
                        nrmData[(i + 0) * 3 + 0] = t[0];
                        nrmData[(i + 0) * 3 + 1] = t[1];
                        nrmData[(i + 0) * 3 + 2] = t[2];
                        nrmData[(i + 1) * 3 + 0] = t[0];
                        nrmData[(i + 1) * 3 + 1] = t[1];
                        nrmData[(i + 1) * 3 + 2] = t[2];
                        nrmData[(i + 2) * 3 + 0] = t[0];
                        nrmData[(i + 2) * 3 + 1] = t[1];
                        nrmData[(i + 2) * 3 + 2] = t[2];
                    }
                    this.vao = gl.createVertexArray();
                    gl.bindVertexArray(this.vao);
                    this.posBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, posData, gl.STATIC_DRAW);
                    gl.vertexAttribPointer(IVProgram.a_Position, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(IVProgram.a_Position);
                    this.nrmBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.nrmBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, nrmData, gl.STATIC_DRAW);
                    gl.vertexAttribPointer(IVProgram.a_Normal, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(IVProgram.a_Normal);
                    this.numVertices = chunk.indexData.length;
                };
                Chunk.prototype.render = function (state) {
                    var gl = state.gl;
                    gl.bindVertexArray(this.vao);
                    gl.drawArrays(gl.TRIANGLES, 0, this.numVertices);
                };
                Chunk.prototype.destroy = function (gl) {
                    gl.deleteVertexArray(this.vao);
                    gl.deleteBuffer(this.posBuffer);
                    gl.deleteBuffer(this.nrmBuffer);
                };
                return Chunk;
            }());
            Scene = /** @class */ (function () {
                function Scene(gl, name, iv) {
                    this.name = name;
                    this.iv = iv;
                    this.textures = [];
                    this.visible = true;
                    this.chunks = this.iv.chunks.map(function (chunk) { return new Chunk(gl, chunk); });
                    this.program = new IVProgram();
                    this.renderFlags = new render_25.RenderFlags();
                    this.renderFlags.cullMode = render_25.CullMode.BACK;
                    this.renderFlags.depthTest = true;
                }
                Scene.prototype.setVisible = function (v) {
                    this.visible = v;
                };
                Scene.prototype.render = function (state) {
                    if (!this.visible)
                        return;
                    var gl = state.gl;
                    state.setClipPlanes(10, 500000);
                    state.useProgram(this.program);
                    state.bindModelView();
                    state.useFlags(this.renderFlags);
                    gl.uniform3fv(this.program.u_Color, this.iv.color);
                    this.chunks.forEach(function (chunk) {
                        chunk.render(state);
                    });
                };
                Scene.prototype.destroy = function (gl) {
                    this.chunks.forEach(function (chunk) {
                        chunk.destroy(gl);
                    });
                    this.program.destroy(gl);
                };
                return Scene;
            }());
            exports_64("Scene", Scene);
        }
    };
});
System.register("dksiv/scenes", ["dksiv/iv", "dksiv/render", "ui", "Progressable", "util"], function (exports_65, context_65) {
    "use strict";
    var __moduleName = context_65 && context_65.id;
    var iv_1, render_26, UI, Progressable_7, util_37, dks1Paths, dks2Paths, MultiScene, SceneDesc, sceneDescs, name, id, sceneGroup;
    return {
        setters: [
            function (iv_1_1) {
                iv_1 = iv_1_1;
            },
            function (render_26_1) {
                render_26 = render_26_1;
            },
            function (UI_4) {
                UI = UI_4;
            },
            function (Progressable_7_1) {
                Progressable_7 = Progressable_7_1;
            },
            function (util_37_1) {
                util_37 = util_37_1;
            }
        ],
        execute: function () {
            dks1Paths = [
                "data/dksiv/dks1/15-0 Sens Fortress.iv",
                "data/dksiv/dks1/15-1 Anor Londo.iv",
                "data/dksiv/dks1/16-0 New Londo Ruins+Valley of Drakes.iv",
                "data/dksiv/dks1/17-0 Duke's Archive+Crystal Caves.iv",
                "data/dksiv/dks1/18-0 Kiln of the first Flame.iv",
                "data/dksiv/dks1/18-1 Undead Asylum.iv",
                "data/dksiv/dks1/10-0 Depths.iv",
                "data/dksiv/dks1/10-1 Undead Burg.iv",
                "data/dksiv/dks1/10-2 Firelink Shrine.iv",
                "data/dksiv/dks1/11-0 Painted World of Ariamis.iv",
                "data/dksiv/dks1/12-0 Darkroot Garden+Basin.iv",
                "data/dksiv/dks1/12-1 Oolacile.iv",
                "data/dksiv/dks1/13-0 Catacombs.iv",
                "data/dksiv/dks1/13-1 Tomb of the Giants.iv",
                "data/dksiv/dks1/13-2 Ash Lake.iv",
                "data/dksiv/dks1/14-0 Blighttown+Quelaags Domain.iv",
                "data/dksiv/dks1/14-1 Demon Ruins+Lost Izalith.iv",
            ];
            dks2Paths = [
                "data/dksiv/dks2/10_25_The Gutter & Black Gulch.iv",
                "data/dksiv/dks2/10_27_Dragon Aerie & Dragon Shrine.iv",
                "data/dksiv/dks2/10_29_Majula.iv",
                "data/dksiv/dks2/10_30_Heide's Tower of Flame.iv",
                "data/dksiv/dks2/10_31_Heide's Tower of Flame & Cathedral of Blue.iv",
                "data/dksiv/dks2/10_32_Shaded Woods & Shrine of Winter.iv",
                "data/dksiv/dks2/10_33_Doors of Pharros.iv",
                "data/dksiv/dks2/10_34_Grave of Saints.iv",
                "data/dksiv/dks2/20_10_Memory of Vammar, Orro, Jeigh.iv",
                "data/dksiv/dks2/20_11_Shrine of Amana.iv",
                "data/dksiv/dks2/20_21_Drangleic Castle & King's Passage & Throne of Want.iv",
                "data/dksiv/dks2/20_24_Undead Crypt.iv",
                "data/dksiv/dks2/20_26_Dragon Memories.iv",
                "data/dksiv/dks2/40_03_Dark Chasm of Old.iv",
                "data/dksiv/dks2/10_02_Things Betwixt.iv",
                "data/dksiv/dks2/10_04_Majula.iv",
                "data/dksiv/dks2/10_10_Forest of Fallen Giants.iv",
                "data/dksiv/dks2/10_14_Brightstone Cove Tseldora & Lord's Private Chamber.iv",
                "data/dksiv/dks2/10_15_Aldia's Keep.iv",
                "data/dksiv/dks2/10_16_The Lost Bastille & Sinners' Rise & Belfry Luna.iv",
                "data/dksiv/dks2/10_17_Harvest Valley & Earthen Peak.iv",
                "data/dksiv/dks2/10_18_No-man's Wharf.iv",
                "data/dksiv/dks2/10_19_Iron Keep & Belfry Sol.iv",
                "data/dksiv/dks2/10_23_Huntsman's Copse & Undead Purgatory.iv",
            ];
            MultiScene = /** @class */ (function () {
                function MultiScene(scenes) {
                    this.scenes = scenes;
                    this.textures = [];
                    try {
                        for (var _a = __values(this.scenes), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var scene = _b.value;
                            this.textures = this.textures.concat(scene.textures);
                        }
                    }
                    catch (e_54_1) { e_54 = { error: e_54_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_54) throw e_54.error; }
                    }
                    var e_54, _c;
                }
                MultiScene.prototype.createPanels = function () {
                    var layers = new UI.LayerPanel();
                    layers.setLayers(this.scenes);
                    return [layers];
                };
                MultiScene.prototype.render = function (renderState) {
                    this.scenes.forEach(function (scene) {
                        scene.render(renderState);
                    });
                };
                MultiScene.prototype.destroy = function (gl) {
                    this.scenes.forEach(function (scene) { return scene.destroy(gl); });
                };
                return MultiScene;
            }());
            SceneDesc = /** @class */ (function () {
                function SceneDesc(id, name, paths) {
                    this.id = id;
                    this.name = name;
                    this.paths = paths;
                }
                SceneDesc.prototype.createScene = function (gl) {
                    var _this = this;
                    return Progressable_7.default.all(this.paths.map(function (path) {
                        return _this.createSceneForPath(gl, path);
                    })).then(function (scenes) {
                        return new MultiScene(scenes);
                    });
                };
                SceneDesc.prototype.createSceneForPath = function (gl, path) {
                    return util_37.fetch(path).then(function (result) {
                        var iv = iv_1.parseIV(result);
                        var basename = path.split('/').pop();
                        return new render_26.Scene(gl, basename, iv);
                    });
                };
                return SceneDesc;
            }());
            sceneDescs = [
                new SceneDesc('dks1', 'Dark Souls 1', dks1Paths),
                new SceneDesc('dks2', 'Dark Souls 2', dks2Paths),
            ];
            name = "Dark Souls Collision Data";
            id = "dksiv";
            exports_65("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
// Implements Retro's PAK format as seen in Metroid Prime 1.
System.register("metroid_prime/pak", ["util"], function (exports_66, context_66) {
    "use strict";
    var __moduleName = context_66 && context_66.id;
    function parse(buffer) {
        var view = buffer.createDataView();
        util_38.assert(view.getUint32(0x00) === 0x00030005);
        // Named resource table.
        var offs = 0x08;
        var namedResourceTableEntries = [];
        var namedResourceTableCount = view.getUint32(offs);
        offs += 0x04;
        for (var i = 0; i < namedResourceTableCount; i++) {
            var fourCC = util_38.readString(buffer, offs + 0x00, 4, false);
            var fileID = util_38.readString(buffer, offs + 0x04, 4, false);
            var fileNameLength = view.getUint32(offs + 0x08);
            var fileName = util_38.readString(buffer, offs + 0x0C, fileNameLength, false);
            namedResourceTableEntries.push({ fourCC: fourCC, fileID: fileID, fileName: fileName });
            offs += 0x0C + fileNameLength;
        }
        var namedResourceTable = new Map();
        var resourceTable = new Map();
        // Regular resource table.
        var resourceTableCount = view.getUint32(offs + 0x00);
        offs += 0x04;
        var _loop_12 = function (i) {
            var isCompressed = !!view.getUint32(offs + 0x00);
            var fourCC = util_38.readString(buffer, offs + 0x04, 4, false);
            var fileID = util_38.readString(buffer, offs + 0x08, 4, false);
            var fileSize = view.getUint32(offs + 0x0C);
            var fileOffset = view.getUint32(offs + 0x10);
            offs += 0x14;
            var decompressedSize = fileSize;
            if (isCompressed) {
                decompressedSize = view.getUint32(fileOffset);
                fileOffset += 0x04;
                fileSize -= 0x04;
            }
            if (resourceTable.has(fileID)) {
                var existingResource = resourceTable.get(fileID);
                // Skip files that are apparently the same.
                util_38.assert(fourCC === existingResource.fourCC);
                util_38.assert(fileSize === existingResource.fileSize);
                return "continue";
            }
            // Check for a named resource.
            var name_13 = null;
            var namedResourceTableEntry = namedResourceTableEntries.find(function (nr) { return nr.fileID === fileID; });
            if (namedResourceTableEntry) {
                name_13 = namedResourceTableEntry.fileName;
                util_38.assert(namedResourceTableEntry.fourCC === fourCC);
            }
            var fileBuffer = buffer.slice(fileOffset, fileOffset + fileSize);
            var fileResource = { name: name_13, fourCC: fourCC, fileID: fileID, fileSize: fileSize, fileOffset: fileOffset, isCompressed: isCompressed, decompressedSize: decompressedSize, buffer: fileBuffer };
            resourceTable.set(fileResource.fileID, fileResource);
            if (name_13 !== null)
                namedResourceTable.set(fileResource.name, fileResource);
        };
        for (var i = 0; i < resourceTableCount; i++) {
            _loop_12(i);
        }
        return { namedResourceTable: namedResourceTable, resourceTable: resourceTable };
    }
    exports_66("parse", parse);
    var util_38;
    return {
        setters: [
            function (util_38_1) {
                util_38 = util_38_1;
            }
        ],
        execute: function () {
        }
    };
});
// Implements Retro's TXTR (texture) format as seen in Metroid Prime 1.
System.register("metroid_prime/txtr", ["gx/gx_texture"], function (exports_67, context_67) {
    "use strict";
    var __moduleName = context_67 && context_67.id;
    function parse(resourceSystem, assetID, buffer) {
        var view = buffer.createDataView();
        var txtrFormat = view.getUint32(0x00);
        var name = resourceSystem.findResourceNameByID(assetID);
        var format = txtrFormatRemap[txtrFormat];
        var width = view.getUint16(0x04);
        var height = view.getUint16(0x06);
        var mipCount = view.getUint32(0x08);
        var offs = 0x0C;
        var paletteFormat = 0;
        var paletteData = null;
        switch (format) {
            case 8 /* C4 */:
            case 9 /* C8 */:
                paletteFormat = view.getUint32(offs + 0x00);
                var palWidth = view.getUint32(offs + 0x04);
                var palHeight = view.getUint32(offs + 0x06);
                offs += 0x08;
                var palSize = GX_Texture.calcPaletteSize(format, paletteFormat);
                paletteData = buffer.slice(offs, offs + palSize);
                offs += palSize;
            case 10 /* C14X2 */:
                throw "whoops";
        }
        var data = buffer.slice(offs);
        return { name: name, format: format, width: width, height: height, mipCount: mipCount, data: data, paletteFormat: paletteFormat, paletteData: paletteData };
    }
    exports_67("parse", parse);
    var GX_Texture, txtrFormatRemap;
    return {
        setters: [
            function (GX_Texture_2) {
                GX_Texture = GX_Texture_2;
            }
        ],
        execute: function () {
            txtrFormatRemap = [
                0 /* I4 */,
                1 /* I8 */,
                2 /* IA4 */,
                3 /* IA8 */,
                8 /* C4 */,
                9 /* C8 */,
                10 /* C14X2 */,
                4 /* RGB565 */,
                5 /* RGB5A3 */,
                6 /* RGBA8 */,
                14 /* CMPR */,
            ];
        }
    };
});
// Implements Retro's MREA format as seen in Metroid Prime 1.
System.register("metroid_prime/mrea", ["gx/gx_material", "util", "gx/gx_displaylist", "Camera", "gl-matrix"], function (exports_68, context_68) {
    "use strict";
    var __moduleName = context_68 && context_68.id;
    function parseMaterialSet(resourceSystem, buffer, offs) {
        var view = buffer.createDataView();
        var textureCount = view.getUint32(offs + 0x00);
        offs += 0x04;
        var textures = [];
        var textureRemapTable = [];
        for (var i = 0; i < textureCount; i++) {
            var materialTXTRID = util_39.readString(buffer, offs, 0x04, false);
            var txtr = resourceSystem.loadAssetByID(materialTXTRID, 'TXTR');
            var txtrIndex = textures.indexOf(txtr);
            if (txtrIndex >= 0) {
                textureRemapTable.push(txtrIndex);
            }
            else {
                var newIndex = textures.push(txtr) - 1;
                textureRemapTable.push(newIndex);
            }
            offs += 0x04;
        }
        var materialCount = view.getUint32(offs + 0x00);
        offs += 0x04;
        var materialEndTable = [];
        for (var i = 0; i < materialCount; i++) {
            var materialEndOffs = view.getUint32(offs);
            materialEndTable.push(materialEndOffs);
            offs += 0x04;
        }
        var materialsStart = offs;
        var materials = [];
        for (var i = 0; i < materialCount; i++) {
            var flags = view.getUint32(offs + 0x00);
            var textureIndexCount = view.getUint32(offs + 0x04);
            offs += 0x08;
            var textureIndexes = [];
            util_39.assert(textureIndexCount < 8);
            for (var j = 0; j < textureIndexCount; j++) {
                var textureIndex = view.getUint32(offs);
                textureIndexes.push(textureIndex);
                offs += 0x04;
            }
            var vtxAttrFormat = view.getUint32(offs + 0x00);
            var groupIndex = view.getUint32(offs + 0x04);
            offs += 0x08;
            var colorConstants = [];
            if (flags & 8 /* HAS_KONST */) {
                var konstCount = view.getUint32(offs);
                offs += 0x04;
                for (var j = 0; j < konstCount; j++) {
                    var r = view.getUint8(offs + 0x00);
                    var g = view.getUint8(offs + 0x01);
                    var b = view.getUint8(offs + 0x02);
                    var a = view.getUint8(offs + 0x03);
                    colorConstants.push(new GX_Material.Color(r, g, b, a));
                    offs += 0x04;
                }
            }
            for (var j = colorConstants.length; j < 4; j++) {
                // Push default colors.
                // XXX(jstpierre): Should this stuff be moved outside GXMaterial?
                colorConstants.push(new GX_Material.Color(0, 0, 0, 0));
            }
            var blendDstFactor = view.getUint16(offs + 0x00);
            var blendSrcFactor = view.getUint16(offs + 0x02);
            offs += 0x04;
            if (flags & 1024 /* HAS_INDTX_REFL */) {
                var reflectionIndtexSlot = view.getUint32(offs);
                offs += 0x04;
            }
            var colorChannelFlagsTableCount = view.getUint32(offs);
            util_39.assert(colorChannelFlagsTableCount <= 4);
            offs += 0x04;
            var lightChannels = [];
            // Only color channel 1 is stored in the format.
            for (var j = 0; j < 1; j++) {
                var colorChannelFlags = view.getUint32(offs);
                var lightingEnabled = !!(colorChannelFlags & 0x01);
                var ambColorSource = (colorChannelFlags >>> 1) & 0x01;
                var matColorSource = (colorChannelFlags >>> 2) & 0x01;
                var colorChannel = { lightingEnabled: lightingEnabled, ambColorSource: ambColorSource, matColorSource: matColorSource };
                // XXX(jstpierre): What's with COLOR0A0?
                var alphaChannel = { lightingEnabled: false, ambColorSource: 0 /* REG */, matColorSource: 0 /* REG */ };
                lightChannels.push({ colorChannel: colorChannel, alphaChannel: alphaChannel });
            }
            offs += 0x04 * colorChannelFlagsTableCount;
            // Fake other channel.
            lightChannels.push({
                colorChannel: { lightingEnabled: false, ambColorSource: 0 /* REG */, matColorSource: 0 /* REG */ },
                alphaChannel: { lightingEnabled: false, ambColorSource: 0 /* REG */, matColorSource: 0 /* REG */ },
            });
            var tevStageCount = view.getUint32(offs);
            util_39.assert(tevStageCount <= 8);
            offs += 0x04;
            var tevOrderTableOffs = offs + tevStageCount * 0x14;
            var tevStages = [];
            for (var j = 0; j < tevStageCount; j++) {
                var colorInputSel = view.getUint32(offs + 0x00);
                var alphaInputSel = view.getUint32(offs + 0x04);
                var colorCombineFlags = view.getUint32(offs + 0x08);
                var alphaCombineFlags = view.getUint32(offs + 0x0C);
                var konstAlphaSel = view.getUint8(offs + 0x11);
                var konstColorSel = view.getUint8(offs + 0x12);
                var channelId = GX_Material.getRasColorChannelID(view.getUint8(offs + 0x13));
                var colorInA = (colorInputSel >>> 0) & 0x1F;
                var colorInB = (colorInputSel >>> 5) & 0x1F;
                var colorInC = (colorInputSel >>> 10) & 0x1F;
                var colorInD = (colorInputSel >>> 15) & 0x1F;
                var alphaInA = (alphaInputSel >>> 0) & 0x1F;
                var alphaInB = (alphaInputSel >>> 5) & 0x1F;
                var alphaInC = (alphaInputSel >>> 10) & 0x1F;
                var alphaInD = (alphaInputSel >>> 15) & 0x1F;
                var colorOp = (colorCombineFlags >>> 0) & 0x0F;
                var colorBias = (colorCombineFlags >>> 4) & 0x03;
                var colorScale = (colorCombineFlags >>> 6) & 0x03;
                var colorClamp = !!(colorCombineFlags >>> 8);
                var colorRegId = (colorCombineFlags >>> 9) & 0x03;
                var alphaOp = (alphaCombineFlags >>> 0) & 0x0F;
                var alphaBias = (alphaCombineFlags >>> 4) & 0x03;
                var alphaScale = (alphaCombineFlags >>> 6) & 0x03;
                var alphaClamp = !!(alphaCombineFlags >>> 8);
                var alphaRegId = (alphaCombineFlags >>> 9) & 0x03;
                var texCoordId = view.getUint8(tevOrderTableOffs + 0x03);
                var texMap = view.getUint8(tevOrderTableOffs + 0x02);
                var index_4 = j;
                var tevStage = {
                    index: index_4,
                    colorInA: colorInA, colorInB: colorInB, colorInC: colorInC, colorInD: colorInD, colorOp: colorOp, colorBias: colorBias, colorScale: colorScale, colorClamp: colorClamp, colorRegId: colorRegId,
                    alphaInA: alphaInA, alphaInB: alphaInB, alphaInC: alphaInC, alphaInD: alphaInD, alphaOp: alphaOp, alphaBias: alphaBias, alphaScale: alphaScale, alphaClamp: alphaClamp, alphaRegId: alphaRegId,
                    texCoordId: texCoordId, texMap: texMap, channelId: channelId,
                    konstColorSel: konstColorSel, konstAlphaSel: konstAlphaSel,
                    // We don't use indtex.
                    indTexStage: 0 /* STAGE0 */,
                    indTexMatrix: 0 /* OFF */,
                    indTexFormat: 0 /* _8 */,
                    indTexBiasSel: 0 /* NONE */,
                    indTexWrapS: 0 /* OFF */,
                    indTexWrapT: 0 /* OFF */,
                    indTexAddPrev: false,
                    indTexUseOrigLOD: false,
                };
                tevStages.push(tevStage);
                offs += 0x14;
                tevOrderTableOffs += 0x04;
            }
            // Skip past TEV order table.
            offs = tevOrderTableOffs;
            var texGenCount = view.getUint32(offs);
            util_39.assert(texGenCount <= 8);
            offs += 0x04;
            var texGens = [];
            for (var j = 0; j < texGenCount; j++) {
                var index_5 = j;
                var flags_1 = view.getUint32(offs);
                var type = (flags_1 >>> 0) & 0x0F;
                var source = (flags_1 >>> 4) & 0x0F;
                var matrix = ((flags_1 >>> 9) & 0x1F) + 30;
                var normalize = !!(flags_1 & 14);
                var postMatrix = ((flags_1 >>> 15) & 0x3F) + 64;
                texGens.push({ index: index_5, type: type, source: source, matrix: matrix, normalize: normalize, postMatrix: postMatrix });
                offs += 0x04;
            }
            var uvAnimations = [];
            var uvAnimationsSize = view.getUint32(offs + 0x00);
            var uvAnimationsCount = view.getUint32(offs + 0x04);
            offs += 0x08;
            for (var j = 0; j < uvAnimationsCount; j++) {
                var type = view.getUint32(offs + 0x00);
                offs += 0x04;
                switch (type) {
                    case 0 /* INV_MAT_SKY */:
                    case 1 /* INV_MAT */:
                    case 6 /* MODEL_MAT */:
                        uvAnimations.push({ type: type });
                        // These guys have no parameters.
                        break;
                    case 2 /* UV_SCROLL */: {
                        var offsetS = view.getFloat32(offs + 0x00);
                        var offsetT = view.getFloat32(offs + 0x04);
                        var scaleS = view.getFloat32(offs + 0x08);
                        var scaleT = view.getFloat32(offs + 0x0C);
                        uvAnimations.push({ type: type, offsetS: offsetS, offsetT: offsetT, scaleS: scaleS, scaleT: scaleT });
                        offs += 0x10;
                        break;
                    }
                    case 3 /* ROTATION */: {
                        var offset = view.getFloat32(offs + 0x00);
                        var scale = view.getFloat32(offs + 0x04);
                        uvAnimations.push({ type: type, offset: offset, scale: scale });
                        offs += 0x08;
                        break;
                    }
                    case 4 /* FLIPBOOK_U */:
                    case 5 /* FLIPBOOK_V */: {
                        var scale = view.getFloat32(offs + 0x00);
                        var numFrames = view.getFloat32(offs + 0x04);
                        var step = view.getFloat32(offs + 0x08);
                        var offset = view.getFloat32(offs + 0x0C);
                        uvAnimations.push({ type: type, scale: scale, numFrames: numFrames, step: step, offset: offset });
                        offs += 0x10;
                        break;
                    }
                    case 7 /* CYLINDER */: {
                        var theta = view.getFloat32(offs + 0x00);
                        var phi = view.getFloat32(offs + 0x04);
                        uvAnimations.push({ type: type, theta: theta, phi: phi });
                        offs += 0x08;
                        break;
                    }
                }
            }
            var index = i;
            var translucent = flags & 16 /* IS_TRANSPARENT */;
            var name_14 = "PrimeGen_" + i;
            var cullMode = 1 /* FRONT */;
            var colorRegisters = [];
            colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
            colorRegisters.push(new GX_Material.Color(1, 1, 1, 0));
            colorRegisters.push(new GX_Material.Color(1, 1, 1, 0));
            colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
            var alphaTest = {
                op: 1 /* OR */,
                compareA: 4 /* GREATER */,
                referenceA: 0.25,
                compareB: 0 /* NEVER */,
                referenceB: 0,
            };
            var blendMode = {
                type: translucent ? 1 /* BLEND */ : 0 /* NONE */,
                srcFactor: blendSrcFactor,
                dstFactor: blendDstFactor,
                logicOp: 0 /* CLEAR */,
            };
            var ropInfo = {
                blendMode: blendMode,
                depthTest: true,
                depthFunc: 1 /* LESS */,
                depthWrite: (!!(flags & 128 /* DEPTH_WRITE */)) && !translucent,
            };
            var gxMaterial = {
                index: index, name: name_14,
                cullMode: cullMode,
                colorRegisters: colorRegisters,
                colorConstants: colorConstants,
                lightChannels: lightChannels,
                texGens: texGens,
                tevStages: tevStages,
                alphaTest: alphaTest,
                ropInfo: ropInfo,
                indTexStages: [],
            };
            materials.push({ flags: flags, groupIndex: groupIndex, textureIndexes: textureIndexes, vtxAttrFormat: vtxAttrFormat, gxMaterial: gxMaterial, uvAnimations: uvAnimations });
            util_39.assert((offs - materialsStart) === materialEndTable[i]);
        }
        return { textures: textures, textureRemapTable: textureRemapTable, materials: materials };
    }
    exports_68("parseMaterialSet", parseMaterialSet);
    function parseGeometry(buffer, materialSet, sectionOffsTable, hasUVShort, sectionIndex) {
        var view = buffer.createDataView();
        var posSectionOffs = sectionOffsTable[sectionIndex++];
        var nrmSectionOffs = sectionOffsTable[sectionIndex++];
        var clrSectionOffs = sectionOffsTable[sectionIndex++];
        var uvfSectionOffs = sectionOffsTable[sectionIndex++];
        var uvsSectionOffs = hasUVShort ? sectionOffsTable[sectionIndex++] : null;
        var surfaceTableOffs = sectionOffsTable[sectionIndex++];
        var firstSurfaceOffs = sectionOffsTable[sectionIndex];
        var surfaceCount = view.getUint32(surfaceTableOffs + 0x00);
        var surfaces = [];
        function fillVatFormat(nrmType, tex0Type, compShift) {
            var vatFormat = [];
            vatFormat[9 /* POS */] = { compCnt: 1 /* POS_XYZ */, compType: 4 /* F32 */, compShift: compShift };
            vatFormat[10 /* NRM */] = { compCnt: 0 /* NRM_XYZ */, compType: nrmType, compShift: compShift };
            vatFormat[11 /* CLR0 */] = { compCnt: 1 /* CLR_RGBA */, compType: 5 /* RGBA8 */, compShift: compShift };
            vatFormat[12 /* CLR1 */] = { compCnt: 1 /* CLR_RGBA */, compType: 5 /* RGBA8 */, compShift: compShift };
            vatFormat[13 /* TEX0 */] = { compCnt: 1 /* TEX_ST */, compType: tex0Type, compShift: compShift };
            vatFormat[14 /* TEX1 */] = { compCnt: 1 /* TEX_ST */, compType: 4 /* F32 */, compShift: compShift };
            vatFormat[15 /* TEX2 */] = { compCnt: 1 /* TEX_ST */, compType: 4 /* F32 */, compShift: compShift };
            vatFormat[16 /* TEX3 */] = { compCnt: 1 /* TEX_ST */, compType: 4 /* F32 */, compShift: compShift };
            vatFormat[17 /* TEX4 */] = { compCnt: 1 /* TEX_ST */, compType: 4 /* F32 */, compShift: compShift };
            vatFormat[18 /* TEX5 */] = { compCnt: 1 /* TEX_ST */, compType: 4 /* F32 */, compShift: compShift };
            vatFormat[19 /* TEX6 */] = { compCnt: 1 /* TEX_ST */, compType: 4 /* F32 */, compShift: compShift };
            vatFormat[20 /* TEX7 */] = { compCnt: 1 /* TEX_ST */, compType: 4 /* F32 */, compShift: compShift };
            return vatFormat;
        }
        for (var i = 0; i < surfaceCount; i++) {
            var surfaceOffs = sectionOffsTable[sectionIndex];
            var surfaceEnd = firstSurfaceOffs + view.getUint32(surfaceTableOffs + 0x04 + i * 0x04);
            var centerX = view.getFloat32(surfaceOffs + 0x00);
            var centerY = view.getFloat32(surfaceOffs + 0x04);
            var centerZ = view.getFloat32(surfaceOffs + 0x08);
            var materialIndex = view.getUint32(surfaceOffs + 0x0C);
            var mantissa = view.getUint16(surfaceOffs + 0x10);
            var displayListSizeExceptNotReally = view.getUint16(surfaceOffs + 0x12);
            var extraDataSize = view.getUint32(surfaceOffs + 0x1C);
            var normalX = view.getFloat32(surfaceOffs + 0x20);
            var normalY = view.getFloat32(surfaceOffs + 0x24);
            var normalZ = view.getFloat32(surfaceOffs + 0x28);
            // XXX(jstpierre): 0x30 or 0x2C?
            var surfaceHeaderEnd = surfaceOffs + 0x2C + extraDataSize;
            var primitiveDataOffs = util_39.align(surfaceHeaderEnd, 32);
            // Build our vertex format.
            var material = materialSet.materials[materialIndex];
            var vtxAttrFormat = material.vtxAttrFormat;
            var vat = [];
            var useUvsArray = (material.flags & 8192 /* UV_SHORT */);
            var vtxArrays = [];
            vtxArrays[9 /* POS */] = { buffer: buffer, offs: posSectionOffs };
            vtxArrays[10 /* NRM */] = { buffer: buffer, offs: nrmSectionOffs };
            vtxArrays[11 /* CLR0 */] = { buffer: buffer, offs: clrSectionOffs };
            vtxArrays[12 /* CLR1 */] = { buffer: buffer, offs: clrSectionOffs };
            vtxArrays[13 /* TEX0 */] = { buffer: buffer, offs: useUvsArray ? uvsSectionOffs : uvfSectionOffs };
            vtxArrays[14 /* TEX1 */] = { buffer: buffer, offs: uvfSectionOffs };
            vtxArrays[15 /* TEX2 */] = { buffer: buffer, offs: uvfSectionOffs };
            vtxArrays[16 /* TEX3 */] = { buffer: buffer, offs: uvfSectionOffs };
            vtxArrays[17 /* TEX4 */] = { buffer: buffer, offs: uvfSectionOffs };
            vtxArrays[18 /* TEX5 */] = { buffer: buffer, offs: uvfSectionOffs };
            vtxArrays[19 /* TEX6 */] = { buffer: buffer, offs: uvfSectionOffs };
            vtxArrays[20 /* TEX7 */] = { buffer: buffer, offs: uvfSectionOffs };
            var vcd = [];
            try {
                for (var vtxAttrFormats_1 = __values(vtxAttrFormats), vtxAttrFormats_1_1 = vtxAttrFormats_1.next(); !vtxAttrFormats_1_1.done; vtxAttrFormats_1_1 = vtxAttrFormats_1.next()) {
                    var format = vtxAttrFormats_1_1.value;
                    if (!(vtxAttrFormat & format.mask))
                        continue;
                    vcd[format.vtxAttrib] = { type: 3 /* INDEX16 */ };
                }
            }
            catch (e_55_1) { e_55 = { error: e_55_1 }; }
            finally {
                try {
                    if (vtxAttrFormats_1_1 && !vtxAttrFormats_1_1.done && (_a = vtxAttrFormats_1.return)) _a.call(vtxAttrFormats_1);
                }
                finally { if (e_55) throw e_55.error; }
            }
            // GX_VTXFMT0 | GX_VA_NRM = GX_F32
            // GX_VTXFMT1 | GX_VA_NRM = GX_S16
            // GX_VTXFMT2 | GX_VA_NRM = GX_S16
            // GX_VTXFMT0 | GX_VA_TEX0 = GX_F32
            // GX_VTXFMT1 | GX_VA_TEX0 = GX_F32
            // GX_VTXFMT2 | GX_VA_TEX0 = GX_S16
            var compShift = Math.log2(mantissa);
            vat[0 /* VTXFMT0 */] = fillVatFormat(4 /* F32 */, 4 /* F32 */, compShift);
            vat[1 /* VTXFMT1 */] = fillVatFormat(3 /* S16 */, 4 /* F32 */, compShift);
            vat[2 /* VTXFMT2 */] = fillVatFormat(3 /* S16 */, 3 /* S16 */, compShift);
            var vtxLoader = gx_displaylist_2.compileVtxLoaderMultiVat(vat, vcd);
            var dlData = buffer.slice(primitiveDataOffs, surfaceEnd);
            var loadedVertexLayout = vtxLoader.loadedVertexLayout;
            var loadedVertexData = vtxLoader.runVertices(vtxArrays, dlData);
            var surface = {
                materialIndex: materialIndex,
                loadedVertexData: loadedVertexData,
                loadedVertexLayout: loadedVertexLayout,
            };
            surfaces.push(surface);
            sectionIndex++;
        }
        var geometry = { surfaces: surfaces };
        return [geometry, sectionIndex];
        var e_55, _a;
    }
    exports_68("parseGeometry", parseGeometry);
    function parse(resourceSystem, assetID, buffer) {
        var view = buffer.createDataView();
        util_39.assert(view.getUint32(0x00) === 0xDEADBEEF);
        var version = view.getUint32(0x04);
        util_39.assert(version === 0x0F);
        // 0x10 - 0x34: Transform matrix
        var worldModelCount = view.getUint32(0x38);
        var dataSectionCount = view.getUint32(0x3C);
        var worldGeometrySectionIndex = view.getUint32(0x40);
        var dataSectionSizeTable = [];
        var dataSectionSizeTableIdx = 0x60;
        for (var i = 0; i < dataSectionCount; i++) {
            var size = view.getUint32(dataSectionSizeTableIdx + 0x00);
            dataSectionSizeTable.push(size);
            dataSectionSizeTableIdx += 0x04;
        }
        var firstDataSectionOffs = util_39.align(dataSectionSizeTableIdx, 32);
        var dataSectionOffsTable = [firstDataSectionOffs];
        for (var i = 1; i < dataSectionCount; i++) {
            var prevOffs = dataSectionOffsTable[i - 1];
            var prevSize = dataSectionSizeTable[i - 1];
            dataSectionOffsTable.push(util_39.align(prevOffs + prevSize, 32));
        }
        // In practice.
        util_39.assert(worldGeometrySectionIndex === 0);
        // The materials section is always the first index in the world geometry section indexes...
        var materialSectionOffs = dataSectionOffsTable[worldGeometrySectionIndex + 0];
        // Parse out materials.
        var materialSet = parseMaterialSet(resourceSystem, buffer, materialSectionOffs);
        var geometrySectionIndex = worldGeometrySectionIndex + 1;
        var worldModels = [];
        for (var i = 0; i < worldModelCount; i++) {
            // World model header.
            var worldModelHeaderOffs = dataSectionOffsTable[geometrySectionIndex];
            var visorFlags = view.getUint32(worldModelHeaderOffs + 0x00);
            var m00 = view.getFloat32(worldModelHeaderOffs + 0x04);
            var m01 = view.getFloat32(worldModelHeaderOffs + 0x08);
            var m02 = view.getFloat32(worldModelHeaderOffs + 0x0C);
            var m03 = view.getFloat32(worldModelHeaderOffs + 0x10);
            var m10 = view.getFloat32(worldModelHeaderOffs + 0x14);
            var m11 = view.getFloat32(worldModelHeaderOffs + 0x18);
            var m12 = view.getFloat32(worldModelHeaderOffs + 0x1C);
            var m13 = view.getFloat32(worldModelHeaderOffs + 0x20);
            var m20 = view.getFloat32(worldModelHeaderOffs + 0x24);
            var m21 = view.getFloat32(worldModelHeaderOffs + 0x28);
            var m22 = view.getFloat32(worldModelHeaderOffs + 0x2C);
            var m23 = view.getFloat32(worldModelHeaderOffs + 0x30);
            var modelMatrix = gl_matrix_15.mat4.fromValues(m00, m10, m20, 0.0, m01, m11, m21, 0.0, m02, m12, m22, 0.0, m03, m13, m23, 1.0);
            var bboxMinX = view.getFloat32(worldModelHeaderOffs + 0x34);
            var bboxMinY = view.getFloat32(worldModelHeaderOffs + 0x38);
            var bboxMinZ = view.getFloat32(worldModelHeaderOffs + 0x3C);
            var bboxMaxX = view.getFloat32(worldModelHeaderOffs + 0x40);
            var bboxMaxY = view.getFloat32(worldModelHeaderOffs + 0x44);
            var bboxMaxZ = view.getFloat32(worldModelHeaderOffs + 0x48);
            var bbox = new Camera_7.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
            worldModelHeaderOffs += 0x4C;
            geometrySectionIndex += 1;
            var geometry = void 0;
            _a = __read(parseGeometry(buffer, materialSet, dataSectionOffsTable, true, geometrySectionIndex), 2), geometry = _a[0], geometrySectionIndex = _a[1];
            worldModels.push({ geometry: geometry, modelMatrix: modelMatrix, bbox: bbox });
        }
        return { materialSet: materialSet, worldModels: worldModels };
        var _a;
    }
    exports_68("parse", parse);
    var GX_Material, util_39, gx_displaylist_2, Camera_7, gl_matrix_15, vtxAttrFormats;
    return {
        setters: [
            function (GX_Material_5) {
                GX_Material = GX_Material_5;
            },
            function (util_39_1) {
                util_39 = util_39_1;
            },
            function (gx_displaylist_2_1) {
                gx_displaylist_2 = gx_displaylist_2_1;
            },
            function (Camera_7_1) {
                Camera_7 = Camera_7_1;
            },
            function (gl_matrix_15_1) {
                gl_matrix_15 = gl_matrix_15_1;
            }
        ],
        execute: function () {
            exports_68("vtxAttrFormats", vtxAttrFormats = [
                { vtxAttrib: 9 /* POS */, mask: 0x00000003, compCount: 3 },
                { vtxAttrib: 10 /* NRM */, mask: 0x0000000C, compCount: 3 },
                { vtxAttrib: 11 /* CLR0 */, mask: 0x00000030, compCount: 4 },
                { vtxAttrib: 12 /* CLR1 */, mask: 0x000000C0, compCount: 4 },
                { vtxAttrib: 13 /* TEX0 */, mask: 0x00000300, compCount: 2 },
                { vtxAttrib: 14 /* TEX1 */, mask: 0x00000C00, compCount: 2 },
                { vtxAttrib: 15 /* TEX2 */, mask: 0x00003000, compCount: 2 },
                { vtxAttrib: 16 /* TEX3 */, mask: 0x0000C000, compCount: 2 },
                { vtxAttrib: 17 /* TEX4 */, mask: 0x00030000, compCount: 2 },
                { vtxAttrib: 18 /* TEX5 */, mask: 0x000C0000, compCount: 2 },
                { vtxAttrib: 19 /* TEX6 */, mask: 0x00300000, compCount: 2 },
            ]);
        }
    };
});
// Implements Retro's STRG (string table resource group) format as seen in Metroid Prime 1.
System.register("metroid_prime/strg", ["util"], function (exports_69, context_69) {
    "use strict";
    var __moduleName = context_69 && context_69.id;
    function readUTF16String(buffer, offs) {
        var arr = buffer.createTypedArray(Uint8Array, offs, 0xFF);
        var raw = utf16Decoder.decode(arr);
        var nul = raw.indexOf('\u0000');
        var str;
        if (nul >= 0)
            str = raw.slice(0, nul);
        else
            str = raw;
        return str;
    }
    function parse(resourceSystem, assetID, buffer) {
        var view = buffer.createDataView();
        util_40.assert(view.getUint32(0x00) === 0x87654321);
        var version = view.getUint32(0x04);
        util_40.assert(version === 0x00); // Metroid Prime 1
        var languageCount = view.getUint32(0x08);
        var stringCount = view.getUint32(0x0C);
        var languageTableOffs = 0x10;
        var stringsTableOffs = languageTableOffs + languageCount * 0x08;
        var languageTableIdx = languageTableOffs;
        var strings = [];
        for (var i = 0; i < languageCount; i++) {
            var languageID = util_40.readString(buffer, languageTableIdx + 0x00, 4, false);
            var languageStringsOffs = view.getUint32(languageTableIdx + 0x04);
            languageTableIdx += 0x08;
            // Load English for now because I am a dirty American.
            if (languageID === 'ENGL') {
                var stringTableIdx = stringsTableOffs + languageStringsOffs;
                var stringTableSize = view.getUint32(stringTableIdx + 0x00);
                stringTableIdx += 0x04;
                var stringTableDataOffs = stringTableIdx;
                for (var j = 0; j < stringCount; j++) {
                    var stringOffs = view.getUint32(stringTableIdx);
                    var string = readUTF16String(buffer, stringTableDataOffs + stringOffs);
                    strings.push(string);
                    stringTableIdx += 0x04;
                }
            }
        }
        return { strings: strings };
    }
    exports_69("parse", parse);
    var util_40, utf16Decoder;
    return {
        setters: [
            function (util_40_1) {
                util_40 = util_40_1;
            }
        ],
        execute: function () {
            utf16Decoder = new TextDecoder('utf-16be');
        }
    };
});
// Implements Retro's CMDL format as seen in Metroid Prime 1.
System.register("metroid_prime/cmdl", ["metroid_prime/mrea", "Camera", "util"], function (exports_70, context_70) {
    "use strict";
    var __moduleName = context_70 && context_70.id;
    function parse(resourceSystem, assetID, buffer) {
        var view = buffer.createDataView();
        util_41.assert(view.getUint32(0x00) === 0xDEADBABE);
        var version = view.getUint32(0x04);
        util_41.assert(version === 0x02);
        var flags = view.getUint32(0x08);
        var minX = view.getFloat32(0x0C);
        var minY = view.getFloat32(0x10);
        var minZ = view.getFloat32(0x14);
        var maxX = view.getFloat32(0x18);
        var maxY = view.getFloat32(0x1C);
        var maxZ = view.getFloat32(0x20);
        var bbox = new Camera_8.AABB(minX, minY, minZ, maxX, maxY, maxZ);
        var dataSectionCount = view.getUint32(0x24);
        var materialSetCount = view.getUint32(0x28);
        var dataSectionSizeTable = [];
        var dataSectionSizeTableIdx = 0x2C;
        for (var i = 0; i < dataSectionCount; i++) {
            var size = view.getUint32(dataSectionSizeTableIdx + 0x00);
            dataSectionSizeTable.push(size);
            dataSectionSizeTableIdx += 0x04;
        }
        var firstDataSectionOffs = util_41.align(dataSectionSizeTableIdx, 32);
        var dataSectionOffsTable = [firstDataSectionOffs];
        for (var i = 1; i < dataSectionCount; i++) {
            var prevOffs = dataSectionOffsTable[i - 1];
            var prevSize = dataSectionSizeTable[i - 1];
            dataSectionOffsTable.push(util_41.align(prevOffs + prevSize, 32));
        }
        var dataSectionIndex = 0;
        var materialSets = [];
        for (var i = 0; i < materialSetCount; i++) {
            var materialSet = mrea_1.parseMaterialSet(resourceSystem, buffer, dataSectionOffsTable[dataSectionIndex++]);
            materialSets.push(materialSet);
        }
        var hasUVShort = !!(flags & Flags.UV_SHORT);
        var geometry;
        _a = __read(mrea_1.parseGeometry(buffer, materialSets[0], dataSectionOffsTable, hasUVShort, dataSectionIndex++), 2), geometry = _a[0], dataSectionIndex = _a[1];
        return { bbox: bbox, materialSets: materialSets, geometry: geometry };
        var _a;
    }
    exports_70("parse", parse);
    var mrea_1, Camera_8, util_41, Flags;
    return {
        setters: [
            function (mrea_1_1) {
                mrea_1 = mrea_1_1;
            },
            function (Camera_8_1) {
                Camera_8 = Camera_8_1;
            },
            function (util_41_1) {
                util_41 = util_41_1;
            }
        ],
        execute: function () {
            (function (Flags) {
                Flags[Flags["SKINNED"] = 1] = "SKINNED";
                Flags[Flags["NRM_SHORT"] = 2] = "NRM_SHORT";
                Flags[Flags["UV_SHORT"] = 4] = "UV_SHORT";
            })(Flags || (Flags = {}));
        }
    };
});
// Resource System
System.register("metroid_prime/resource", ["pako", "metroid_prime/mlvl", "metroid_prime/mrea", "metroid_prime/strg", "metroid_prime/txtr", "metroid_prime/cmdl", "util", "ArrayBufferSlice"], function (exports_71, context_71) {
    "use strict";
    var __moduleName = context_71 && context_71.id;
    function hexName(id) {
        var S = '';
        for (var i = 0; i < id.length; i++)
            S += util_42.hexzero(id.charCodeAt(i), 2).toUpperCase();
        return S;
    }
    var pako_1, MLVL, MREA, STRG, TXTR, CMDL, util_42, ArrayBufferSlice_7, FourCCLoaders, ResourceSystem;
    return {
        setters: [
            function (pako_1_1) {
                pako_1 = pako_1_1;
            },
            function (MLVL_1) {
                MLVL = MLVL_1;
            },
            function (MREA_1) {
                MREA = MREA_1;
            },
            function (STRG_1) {
                STRG = STRG_1;
            },
            function (TXTR_1) {
                TXTR = TXTR_1;
            },
            function (CMDL_1) {
                CMDL = CMDL_1;
            },
            function (util_42_1) {
                util_42 = util_42_1;
            },
            function (ArrayBufferSlice_7_1) {
                ArrayBufferSlice_7 = ArrayBufferSlice_7_1;
            }
        ],
        execute: function () {
            FourCCLoaders = {
                'MLVL': MLVL.parse,
                'MREA': MREA.parse,
                'STRG': STRG.parse,
                'TXTR': TXTR.parse,
                'CMDL': CMDL.parse,
            };
            ResourceSystem = /** @class */ (function () {
                function ResourceSystem(paks, nameData) {
                    this.paks = paks;
                    this.nameData = nameData;
                    this._cache = new Map();
                }
                ResourceSystem.prototype.loadResourceBuffer = function (resource) {
                    if (resource.isCompressed) {
                        var deflated = resource.buffer.createTypedArray(Uint8Array);
                        var inflated = pako_1.default.inflate(deflated);
                        return new ArrayBufferSlice_7.default(inflated.buffer);
                    }
                    else {
                        return resource.buffer;
                    }
                };
                ResourceSystem.prototype.findResourceNameByID = function (assetID) {
                    var assetIDHex = hexName(assetID);
                    util_42.assert(assetIDHex.length === 8);
                    var nameDataAsset = this.nameData.Assets[assetIDHex];
                    if (nameDataAsset)
                        return nameDataAsset.Filename;
                    else
                        return assetIDHex;
                };
                ResourceSystem.prototype.findResourceByID = function (assetID) {
                    util_42.assert(assetID.length === 4);
                    try {
                        for (var _a = __values(this.paks), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var pak = _b.value;
                            var resource = pak.resourceTable.get(assetID);
                            if (resource)
                                return resource;
                        }
                    }
                    catch (e_56_1) { e_56 = { error: e_56_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_56) throw e_56.error; }
                    }
                    return null;
                    var e_56, _c;
                };
                ResourceSystem.prototype.loadAssetByID = function (assetID, fourCC) {
                    if (assetID === '\xFF\xFF\xFF\xFF')
                        return null;
                    var cached = this._cache.get(assetID);
                    if (cached !== undefined)
                        return cached;
                    var loaderFunc = FourCCLoaders[fourCC];
                    if (!loaderFunc)
                        return null;
                    var resource = this.findResourceByID(assetID);
                    util_42.assert(resource.fourCC === fourCC);
                    var buffer = this.loadResourceBuffer(resource);
                    var inst = loaderFunc(this, assetID, buffer);
                    this._cache.set(assetID, inst);
                    return inst;
                };
                return ResourceSystem;
            }());
            exports_71("ResourceSystem", ResourceSystem);
        }
    };
});
// Implements Retro's MLVL format as seen in Metroid Prime 1.
System.register("metroid_prime/mlvl", ["util"], function (exports_72, context_72) {
    "use strict";
    var __moduleName = context_72 && context_72.id;
    function parse(resourceSystem, assetID, buffer) {
        var view = buffer.createDataView();
        util_43.assert(view.getUint32(0x00) == 0xDEAFBABE);
        var version = view.getUint32(0x04);
        // Version that appears in Metroid Prime 1.
        util_43.assert(version === 0x11);
        // STRG file ID?
        var worldNameSTRGID = util_43.readString(buffer, 0x08, 4, false);
        var worldName = resourceSystem.loadAssetByID(worldNameSTRGID, 'STRG');
        var worldSaveID = view.getUint32(0x0C);
        var defaultSkyboxID = util_43.readString(buffer, 0x10, 4, false);
        // Memory Relay junk.
        var memoryRelayTableIdx = 0x14;
        var memoryRelayTableCount = view.getUint32(memoryRelayTableIdx + 0x00);
        memoryRelayTableIdx += 0x04;
        for (var i = 0; i < memoryRelayTableCount; i++) {
            var memoryRelayInstanceID = view.getUint32(memoryRelayTableIdx + 0x00);
            var targetInstanceID = view.getUint32(memoryRelayTableIdx + 0x04);
            var messageType = view.getUint16(memoryRelayTableIdx + 0x08);
            var active = !!view.getUint8(memoryRelayTableIdx + 0x0A);
            memoryRelayTableIdx += 0x0B;
        }
        var areaTableOffs = memoryRelayTableIdx;
        var areaTableCount = view.getUint32(areaTableOffs + 0x00);
        util_43.assert(view.getUint32(areaTableOffs + 0x04) === 0x01);
        var areaTableIdx = areaTableOffs + 0x08;
        var areaTable = [];
        for (var i = 0; i < areaTableCount; i++) {
            var areaSTRGID = util_43.readString(buffer, areaTableIdx, 4, false);
            var areaSTRG = resourceSystem.loadAssetByID(areaSTRGID, 'STRG');
            var areaName = areaSTRG.strings[0];
            areaTableIdx += 0x04;
            areaTableIdx += 0x04 * 12; // Transform matrix
            areaTableIdx += 0x04 * 6; // AABB
            var areaMREAID = util_43.readString(buffer, areaTableIdx + 0x00, 4, false);
            var areaMREA = resourceSystem.findResourceByID(areaMREAID);
            util_43.assert(areaMREA !== null);
            var areaInternalID = view.getUint32(areaTableIdx + 0x04);
            areaTableIdx += 0x08;
            var attachedAreaCount = view.getUint32(areaTableIdx + 0x00);
            areaTableIdx += 0x04;
            for (var j = 0; j < attachedAreaCount; j++) {
                areaTableIdx += 0x02; // Attached Area Index Array
            }
            // TODO(jstpierre): Verify with Aruki. Seems to be undocumented?
            areaTableIdx += 0x04;
            var dependencyTableCount = view.getUint32(areaTableIdx);
            areaTableIdx += 0x04;
            for (var j = 0; j < dependencyTableCount; j++) {
                var dependencyID = view.getUint32(areaTableIdx + 0x00);
                var dependencyFOURCC = view.getUint32(areaTableIdx + 0x04);
                areaTableIdx += 0x08;
            }
            var dependencyOffsetTableCount = view.getUint32(areaTableIdx);
            areaTableIdx += 0x04;
            for (var j = 0; j < dependencyOffsetTableCount; j++) {
                var dependencyOffset = view.getUint32(areaTableIdx + 0x00);
                areaTableIdx += 0x04;
            }
            var dockCount = view.getUint32(areaTableIdx);
            areaTableIdx += 0x04;
            for (var j = 0; j < dockCount; j++) {
                var connectingDockCount = view.getUint32(areaTableIdx);
                areaTableIdx += 0x04;
                for (var k = 0; k < connectingDockCount; k++) {
                    var connectingDockAreaIndex = view.getUint32(areaTableIdx + 0x00);
                    var connectingDockDockIndex = view.getUint32(areaTableIdx + 0x04);
                    areaTableIdx += 0x08;
                }
                var dockCoordinateCount = view.getUint32(areaTableIdx);
                areaTableIdx += 0x04;
                for (var k = 0; k < dockCoordinateCount; k++) {
                    areaTableIdx += 0x0C; // xyz floats
                }
            }
            areaTable.push({ areaName: areaName, areaMREAID: areaMREAID });
        }
        return { areaTable: areaTable, defaultSkyboxID: defaultSkyboxID };
    }
    exports_72("parse", parse);
    var util_43;
    return {
        setters: [
            function (util_43_1) {
                util_43 = util_43_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("metroid_prime/render", ["gl-matrix", "gx/gx_material", "gx/gx_render", "util", "ArrayBufferSlice", "BufferCoalescer", "Camera"], function (exports_73, context_73) {
    "use strict";
    var __moduleName = context_73 && context_73.id;
    var gl_matrix_16, GX_Material, gx_render_2, util_44, ArrayBufferSlice_8, BufferCoalescer_3, Camera_9, fixPrimeUsingTheWrongConventionYesIKnowItsFromMayaButMayaIsStillWrong, posScale, posMtx, RetroTextureHolder, textureMappingScratch, MREARenderer, CMDLRenderer, Command_Surface, Command_Material;
    return {
        setters: [
            function (gl_matrix_16_1) {
                gl_matrix_16 = gl_matrix_16_1;
            },
            function (GX_Material_6) {
                GX_Material = GX_Material_6;
            },
            function (gx_render_2_1) {
                gx_render_2 = gx_render_2_1;
            },
            function (util_44_1) {
                util_44 = util_44_1;
            },
            function (ArrayBufferSlice_8_1) {
                ArrayBufferSlice_8 = ArrayBufferSlice_8_1;
            },
            function (BufferCoalescer_3_1) {
                BufferCoalescer_3 = BufferCoalescer_3_1;
            },
            function (Camera_9_1) {
                Camera_9 = Camera_9_1;
            }
        ],
        execute: function () {
            fixPrimeUsingTheWrongConventionYesIKnowItsFromMayaButMayaIsStillWrong = gl_matrix_16.mat4.fromValues(1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1);
            // Cheap way to scale up.
            posScale = 10;
            posMtx = gl_matrix_16.mat4.create();
            gl_matrix_16.mat4.multiplyScalar(posMtx, fixPrimeUsingTheWrongConventionYesIKnowItsFromMayaButMayaIsStillWrong, posScale);
            posMtx[15] = 1;
            RetroTextureHolder = /** @class */ (function (_super) {
                __extends(RetroTextureHolder, _super);
                function RetroTextureHolder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                RetroTextureHolder.prototype.addMaterialSetTextures = function (gl, materialSet) {
                    this.addTextures(gl, materialSet.textures);
                };
                return RetroTextureHolder;
            }(gx_render_2.TextureHolder));
            exports_73("RetroTextureHolder", RetroTextureHolder);
            textureMappingScratch = util_44.nArray(8, function () { return new gx_render_2.TextureMapping(); });
            MREARenderer = /** @class */ (function () {
                function MREARenderer(gl, textureHolder, name, mrea) {
                    this.textureHolder = textureHolder;
                    this.name = name;
                    this.mrea = mrea;
                    this.textures = [];
                    this.materialCommands = [];
                    this.opaqueCommands = [];
                    this.transparentCommands = [];
                    this.sceneParams = new gx_render_2.SceneParams();
                    this.packetParams = new gx_render_2.PacketParams();
                    this.bboxScratch = new Camera_9.AABB();
                    this.visible = true;
                    this.renderHelper = new gx_render_2.GXRenderHelper(gl);
                    this.translateModel(gl);
                }
                MREARenderer.prototype.translateModel = function (gl) {
                    var _this = this;
                    var materialSet = this.mrea.materialSet;
                    this.textureHolder.addMaterialSetTextures(gl, materialSet);
                    // Pull out the first material of each group, which should be identical except for textures.
                    var groupMaterials = [];
                    for (var i = 0; i < materialSet.materials.length; i++) {
                        var material = materialSet.materials[i];
                        if (!groupMaterials[material.groupIndex])
                            groupMaterials[material.groupIndex] = material;
                    }
                    this.materialCommands = groupMaterials.map(function (material) {
                        return new Command_Material(material);
                    });
                    var vertexDatas = [];
                    var indexDatas = [];
                    // Coalesce surface data.
                    this.mrea.worldModels.forEach(function (worldModel) {
                        worldModel.geometry.surfaces.forEach(function (surface) {
                            vertexDatas.push(new ArrayBufferSlice_8.default(surface.loadedVertexData.packedVertexData));
                            indexDatas.push(new ArrayBufferSlice_8.default(surface.loadedVertexData.indexData));
                        });
                    });
                    this.bufferCoalescer = new BufferCoalescer_3.default(gl, vertexDatas, indexDatas);
                    var bufferIndex = 0;
                    this.mrea.worldModels.forEach(function (worldModel, modelIndex) {
                        worldModel.geometry.surfaces.forEach(function (surface) {
                            var material = materialSet.materials[surface.materialIndex];
                            var coalescedBuffers = _this.bufferCoalescer.coalescedBuffers[bufferIndex++];
                            if (material.flags & 512 /* OCCLUDER */)
                                return;
                            var surfaceCommand = new Command_Surface(gl, surface, coalescedBuffers, modelIndex);
                            if (material.flags & 16 /* IS_TRANSPARENT */)
                                _this.transparentCommands.push(surfaceCommand);
                            else
                                _this.opaqueCommands.push(surfaceCommand);
                        });
                    });
                };
                MREARenderer.prototype.setVisible = function (visible) {
                    this.visible = visible;
                };
                MREARenderer.prototype.render = function (state) {
                    if (!this.visible)
                        return;
                    state.setClipPlanes(2, 7500);
                    this.renderHelper.bindUniformBuffers(state);
                    gx_render_2.fillSceneParamsFromRenderState(this.sceneParams, state);
                    this.renderHelper.bindSceneParams(state, this.sceneParams);
                    this.computeModelView(this.packetParams.u_PosMtx[0], state);
                    this.renderHelper.bindPacketParams(state, this.packetParams);
                    // Frustum cull.
                    var bbox = this.bboxScratch;
                    var modelVisibility = [];
                    this.mrea.worldModels.forEach(function (worldModel, i) {
                        bbox.transform(worldModel.bbox, posMtx);
                        modelVisibility[i] = state.camera.frustum.intersect(bbox) !== Camera_9.IntersectionState.FULLY_OUTSIDE;
                    });
                    this.execSurfaceCommandList(state, this.opaqueCommands, modelVisibility);
                    this.execSurfaceCommandList(state, this.transparentCommands, modelVisibility);
                };
                MREARenderer.prototype.destroy = function (gl) {
                    this.materialCommands.forEach(function (cmd) { return cmd.destroy(gl); });
                    this.opaqueCommands.forEach(function (cmd) { return cmd.destroy(gl); });
                    this.transparentCommands.forEach(function (cmd) { return cmd.destroy(gl); });
                    this.bufferCoalescer.destroy(gl);
                };
                MREARenderer.prototype.execSurfaceCommandList = function (state, cmdList, modelVisibility) {
                    var currentMaterialIndex = -1;
                    var currentGroupIndex = -1;
                    for (var i = 0; i < cmdList.length; i++) {
                        var surfaceCmd = cmdList[i];
                        if (!modelVisibility[surfaceCmd.modelIndex])
                            continue;
                        var materialIndex = surfaceCmd.surface.materialIndex;
                        var material = this.mrea.materialSet.materials[materialIndex];
                        if (currentMaterialIndex !== materialIndex) {
                            var groupIndex = material.groupIndex;
                            var materialCommand = this.materialCommands[groupIndex];
                            if (groupIndex !== currentGroupIndex) {
                                materialCommand.exec(state, null, false, this.renderHelper);
                                currentGroupIndex = groupIndex;
                            }
                            this.bindTextures(state, material, materialCommand.program);
                            currentMaterialIndex = materialIndex;
                        }
                        surfaceCmd.exec(state);
                    }
                };
                MREARenderer.prototype.fillTextureMapping = function (textureMapping, material) {
                    for (var i = 0; i < material.textureIndexes.length; i++) {
                        var textureIndex = material.textureIndexes[i];
                        if (textureIndex === -1)
                            continue;
                        var materialSet = this.mrea.materialSet;
                        var txtr = materialSet.textures[materialSet.textureRemapTable[textureIndex]];
                        this.textureHolder.fillTextureMapping(textureMapping[i], txtr.name);
                    }
                };
                MREARenderer.prototype.bindTextures = function (state, material, program) {
                    this.fillTextureMapping(textureMappingScratch, material);
                    this.renderHelper.bindMaterialTextureMapping(state, textureMappingScratch, program);
                };
                MREARenderer.prototype.computeModelView = function (dst, state) {
                    gl_matrix_16.mat4.copy(dst, state.updateModelView(false, posMtx));
                };
                return MREARenderer;
            }());
            exports_73("MREARenderer", MREARenderer);
            // TODO(jstpierre): Dedupe.
            CMDLRenderer = /** @class */ (function () {
                function CMDLRenderer(gl, textureHolder, name, cmdl) {
                    this.textureHolder = textureHolder;
                    this.name = name;
                    this.cmdl = cmdl;
                    this.textures = [];
                    this.materialCommands = [];
                    this.surfaceCommands = [];
                    this.sceneParams = new gx_render_2.SceneParams();
                    this.packetParams = new gx_render_2.PacketParams();
                    this.bboxScratch = new Camera_9.AABB();
                    this.modelMatrix = gl_matrix_16.mat4.create();
                    this.visible = true;
                    this.isSkybox = false;
                    this.renderHelper = new gx_render_2.GXRenderHelper(gl);
                    this.translateModel(gl);
                }
                CMDLRenderer.prototype.translateModel = function (gl) {
                    var _this = this;
                    var materialSet = this.cmdl.materialSets[0];
                    this.textureHolder.addMaterialSetTextures(gl, materialSet);
                    // Pull out the first material of each group, which should be identical except for textures.
                    var groupMaterials = [];
                    for (var i_4 = 0; i_4 < materialSet.materials.length; i_4++) {
                        var material = materialSet.materials[i_4];
                        if (!groupMaterials[material.groupIndex])
                            groupMaterials[material.groupIndex] = material;
                    }
                    this.materialCommands = groupMaterials.map(function (material) {
                        return new Command_Material(material);
                    });
                    var vertexDatas = [];
                    var indexDatas = [];
                    // Coalesce surface data.
                    this.cmdl.geometry.surfaces.forEach(function (surface) {
                        vertexDatas.push(new ArrayBufferSlice_8.default(surface.loadedVertexData.packedVertexData));
                        indexDatas.push(new ArrayBufferSlice_8.default(surface.loadedVertexData.indexData));
                    });
                    this.bufferCoalescer = new BufferCoalescer_3.default(gl, vertexDatas, indexDatas);
                    var i = 0;
                    this.cmdl.geometry.surfaces.forEach(function (surface) {
                        _this.surfaceCommands.push(new Command_Surface(gl, surface, _this.bufferCoalescer.coalescedBuffers[i]));
                        ++i;
                    });
                };
                CMDLRenderer.prototype.setVisible = function (visible) {
                    this.visible = visible;
                };
                CMDLRenderer.prototype.render = function (state) {
                    if (!this.visible)
                        return;
                    this.renderHelper.bindUniformBuffers(state);
                    gx_render_2.fillSceneParamsFromRenderState(this.sceneParams, state);
                    this.renderHelper.bindSceneParams(state, this.sceneParams);
                    this.computeModelView(this.packetParams.u_PosMtx[0], state);
                    this.renderHelper.bindPacketParams(state, this.packetParams);
                    var currentMaterialIndex = -1;
                    var currentGroupIndex = -1;
                    var surfaceCmdIndex = 0;
                    var bbox = this.bboxScratch;
                    var numSurfaces = this.cmdl.geometry.surfaces.length;
                    var materialSet = this.cmdl.materialSets[0];
                    // Frustum cull.
                    if (!this.isSkybox) {
                        bbox.transform(this.cmdl.bbox, posMtx);
                        if (state.camera.frustum.intersect(bbox) === Camera_9.IntersectionState.FULLY_OUTSIDE)
                            return;
                    }
                    for (var i = 0; i < numSurfaces; i++) {
                        var surfaceCmd = this.surfaceCommands[surfaceCmdIndex++];
                        var materialIndex = surfaceCmd.surface.materialIndex;
                        var material = materialSet.materials[materialIndex];
                        // Don't render occluder meshes.
                        if (material.flags & 512 /* OCCLUDER */)
                            continue;
                        if (currentMaterialIndex !== materialIndex) {
                            var groupIndex = materialSet.materials[materialIndex].groupIndex;
                            var materialCommand = this.materialCommands[groupIndex];
                            if (groupIndex !== currentGroupIndex) {
                                materialCommand.exec(state, this.modelMatrix, this.isSkybox, this.renderHelper);
                                currentGroupIndex = groupIndex;
                            }
                            this.bindTextures(state, material, materialCommand.program);
                            currentMaterialIndex = materialIndex;
                        }
                        surfaceCmd.exec(state);
                    }
                };
                CMDLRenderer.prototype.destroy = function (gl) {
                    this.materialCommands.forEach(function (cmd) { return cmd.destroy(gl); });
                    this.surfaceCommands.forEach(function (cmd) { return cmd.destroy(gl); });
                    this.bufferCoalescer.destroy(gl);
                };
                CMDLRenderer.prototype.fillTextureMapping = function (textureMapping, material) {
                    for (var i = 0; i < material.textureIndexes.length; i++) {
                        var textureIndex = material.textureIndexes[i];
                        if (textureIndex === -1)
                            continue;
                        var materialSet = this.cmdl.materialSets[0];
                        var txtr = materialSet.textures[materialSet.textureRemapTable[textureIndex]];
                        this.textureHolder.fillTextureMapping(textureMapping[i], txtr.name);
                    }
                };
                CMDLRenderer.prototype.bindTextures = function (state, material, program) {
                    this.fillTextureMapping(textureMappingScratch, material);
                    this.renderHelper.bindMaterialTextureMapping(state, textureMappingScratch, program);
                };
                CMDLRenderer.prototype.computeModelView = function (dst, state) {
                    gl_matrix_16.mat4.copy(dst, state.updateModelView(this.isSkybox, posMtx));
                };
                return CMDLRenderer;
            }());
            exports_73("CMDLRenderer", CMDLRenderer);
            Command_Surface = /** @class */ (function () {
                function Command_Surface(gl, surface, coalescedBuffers, modelIndex) {
                    if (modelIndex === void 0) { modelIndex = 0; }
                    this.surface = surface;
                    this.modelIndex = modelIndex;
                    this.shapeHelper = new gx_render_2.GXShapeHelper(gl, coalescedBuffers, surface.loadedVertexLayout, surface.loadedVertexData);
                }
                Command_Surface.prototype.exec = function (state) {
                    var gl = state.gl;
                    this.shapeHelper.drawSimple(gl);
                    state.drawCallCount++;
                };
                Command_Surface.prototype.destroy = function (gl) {
                    this.shapeHelper.destroy(gl);
                };
                return Command_Surface;
            }());
            Command_Material = /** @class */ (function () {
                function Command_Material(material) {
                    this.material = material;
                    this.materialParams = new gx_render_2.MaterialParams();
                    this.program = new GX_Material.GX_Program(this.material.gxMaterial);
                    this.renderFlags = GX_Material.translateRenderFlags(this.material.gxMaterial);
                }
                Command_Material.prototype.exec = function (state, modelMatrix, isSkybox, renderHelper) {
                    state.useProgram(this.program);
                    state.useFlags(this.renderFlags);
                    this.fillMaterialParamsData(state, modelMatrix, isSkybox, this.materialParams);
                    renderHelper.bindMaterialParams(state, this.materialParams);
                };
                Command_Material.prototype.destroy = function (gl) {
                    this.program.destroy(gl);
                };
                Command_Material.prototype.fillMaterialParamsData = function (state, modelMatrix, isSkybox, materialParams) {
                    materialParams.u_ColorMatReg[0].set(1, 1, 1, 1);
                    if (isSkybox)
                        materialParams.u_ColorAmbReg[0].set(1, 1, 1, 1);
                    else
                        materialParams.u_ColorMatReg[0].set(0, 0, 0, 1);
                    for (var i = 0; i < 4; i++)
                        materialParams.u_Color[i].copy(this.material.gxMaterial.colorRegisters[i]);
                    for (var i = 0; i < 4; i++)
                        materialParams.u_KonstColor[i].copy(this.material.gxMaterial.colorConstants[i]);
                    var animTime = ((state.time / 1000) % 900);
                    for (var i = 0; i < this.material.uvAnimations.length; i++) {
                        var uvAnimation = this.material.uvAnimations[i];
                        var texMtx = materialParams.u_TexMtx[i];
                        var postMtx = materialParams.u_PostTexMtx[i];
                        switch (uvAnimation.type) {
                            case 2 /* UV_SCROLL */: {
                                var transS = animTime * uvAnimation.scaleS + uvAnimation.offsetS;
                                var transT = animTime * uvAnimation.scaleT + uvAnimation.offsetT;
                                texMtx[12] = transS;
                                texMtx[13] = transT;
                                break;
                            }
                            case 3 /* ROTATION */: {
                                var theta = animTime * uvAnimation.scale + uvAnimation.offset;
                                var cosR = Math.cos(theta);
                                var sinR = Math.sin(theta);
                                texMtx[0] = cosR;
                                texMtx[4] = sinR;
                                texMtx[12] = (1.0 - (cosR - sinR)) * 0.5;
                                texMtx[1] = -sinR;
                                texMtx[5] = cosR;
                                texMtx[13] = (1.0 - (sinR + cosR)) * 0.5;
                                break;
                            }
                            case 4 /* FLIPBOOK_U */: {
                                var n = uvAnimation.step * uvAnimation.scale * (uvAnimation.offset + animTime);
                                var trans = Math.floor(uvAnimation.numFrames * (n % 1.0)) * uvAnimation.step;
                                texMtx[12] = trans;
                                break;
                            }
                            case 5 /* FLIPBOOK_V */: {
                                var n = uvAnimation.step * uvAnimation.scale * (uvAnimation.offset + animTime);
                                var trans = Math.floor(uvAnimation.numFrames * (n % 1.0)) * uvAnimation.step;
                                texMtx[13] = trans;
                                break;
                            }
                            case 0 /* INV_MAT_SKY */:
                                gl_matrix_16.mat4.invert(texMtx, state.view);
                                if (modelMatrix !== null)
                                    gl_matrix_16.mat4.mul(texMtx, texMtx, modelMatrix);
                                texMtx[12] = 0;
                                texMtx[13] = 0;
                                texMtx[14] = 0;
                                Camera_9.texEnvMtx(postMtx, 0.5, -0.5, 0.5, 0.5);
                                break;
                            case 1 /* INV_MAT */:
                                gl_matrix_16.mat4.invert(texMtx, state.view);
                                if (modelMatrix !== null)
                                    gl_matrix_16.mat4.mul(texMtx, texMtx, modelMatrix);
                                Camera_9.texEnvMtx(postMtx, 0.5, -0.5, 0.5, 0.5);
                                break;
                            case 6 /* MODEL_MAT */:
                                if (modelMatrix !== null)
                                    gl_matrix_16.mat4.copy(texMtx, modelMatrix);
                                else
                                    gl_matrix_16.mat4.identity(texMtx);
                                texMtx[12] = 0;
                                texMtx[13] = 0;
                                texMtx[14] = 0;
                                Camera_9.texEnvMtx(postMtx, 0.5, -0.5, modelMatrix[12] * 0.5, modelMatrix[13] * 0.5);
                                break;
                            case 7 /* CYLINDER */: {
                                gl_matrix_16.mat4.copy(texMtx, state.view);
                                if (modelMatrix !== null)
                                    gl_matrix_16.mat4.mul(texMtx, texMtx, modelMatrix);
                                texMtx[12] = 0;
                                texMtx[13] = 0;
                                texMtx[14] = 0;
                                var xy = ((state.view[12] + state.view[13]) * 0.025 * uvAnimation.phi) % 1.0;
                                var z = (state.view[14] * 0.05 * uvAnimation.phi) % 1.0;
                                var a = uvAnimation.theta * 0.5;
                                Camera_9.texEnvMtx(postMtx, a, -a, xy, z);
                                break;
                            }
                        }
                    }
                };
                return Command_Material;
            }());
        }
    };
});
System.register("metroid_prime/scenes", ["metroid_prime/pak", "metroid_prime/resource", "metroid_prime/render", "ui", "util", "Progressable", "render", "byml"], function (exports_74, context_74) {
    "use strict";
    var __moduleName = context_74 && context_74.id;
    // PAK Files are too big for GitHub.
    function findPakBase() {
        if (document.location.protocol === 'file:') {
            return "data/metroid_prime/mp1/";
        }
        else {
            return "https://funny.computer/cloud/MetroidPrime1/";
        }
    }
    var PAK, resource_1, render_27, UI, util_45, Progressable_8, render_28, BYML, pakBase, MetroidPrimeWorldScene, MP1SceneDesc, id, name, sceneDescs, sceneGroup;
    return {
        setters: [
            function (PAK_1) {
                PAK = PAK_1;
            },
            function (resource_1_1) {
                resource_1 = resource_1_1;
            },
            function (render_27_1) {
                render_27 = render_27_1;
            },
            function (UI_5) {
                UI = UI_5;
            },
            function (util_45_1) {
                util_45 = util_45_1;
            },
            function (Progressable_8_1) {
                Progressable_8 = Progressable_8_1;
            },
            function (render_28_1) {
                render_28 = render_28_1;
            },
            function (BYML_2) {
                BYML = BYML_2;
            }
        ],
        execute: function () {
            pakBase = findPakBase();
            MetroidPrimeWorldScene = /** @class */ (function () {
                function MetroidPrimeWorldScene(mlvl, textureHolder, skyboxRenderer, areaRenderers) {
                    this.mlvl = mlvl;
                    this.textureHolder = textureHolder;
                    this.skyboxRenderer = skyboxRenderer;
                    this.areaRenderers = areaRenderers;
                    this.textures = textureHolder.viewerTextures;
                }
                MetroidPrimeWorldScene.prototype.createPanels = function () {
                    var layersPanel = new UI.LayerPanel();
                    layersPanel.setLayers(this.areaRenderers);
                    return [layersPanel];
                };
                MetroidPrimeWorldScene.prototype.render = function (state) {
                    var gl = state.gl;
                    if (this.skyboxRenderer)
                        this.skyboxRenderer.render(state);
                    state.useFlags(render_28.depthClearFlags);
                    gl.clear(gl.DEPTH_BUFFER_BIT);
                    this.areaRenderers.forEach(function (areaRenderer) {
                        areaRenderer.render(state);
                    });
                };
                MetroidPrimeWorldScene.prototype.destroy = function (gl) {
                    this.textureHolder.destroy(gl);
                    if (this.skyboxRenderer)
                        this.skyboxRenderer.destroy(gl);
                    this.areaRenderers.forEach(function (areaRenderer) { return areaRenderer.destroy(gl); });
                };
                return MetroidPrimeWorldScene;
            }());
            exports_74("MetroidPrimeWorldScene", MetroidPrimeWorldScene);
            MP1SceneDesc = /** @class */ (function () {
                function MP1SceneDesc(filename, name) {
                    this.filename = filename;
                    this.name = name;
                    this.id = filename;
                }
                MP1SceneDesc.prototype.createScene = function (gl) {
                    var stringsPakP = util_45.fetch(pakBase + "/Strings.pak");
                    var levelPakP = util_45.fetch(pakBase + "/" + this.filename);
                    var nameDataP = util_45.fetch("data/metroid_prime/mp1/MP1_NameData.crg1");
                    return Progressable_8.default.all([levelPakP, stringsPakP, nameDataP]).then(function (datas) {
                        var levelPak = PAK.parse(datas[0]);
                        var stringsPak = PAK.parse(datas[1]);
                        var nameData = BYML.parse(datas[2], 1 /* CRG1 */);
                        var resourceSystem = new resource_1.ResourceSystem([levelPak, stringsPak], nameData);
                        var _loop_13 = function (mlvlEntry) {
                            util_45.assert(mlvlEntry.fourCC === 'MLVL');
                            var mlvl = resourceSystem.loadAssetByID(mlvlEntry.fileID, mlvlEntry.fourCC);
                            var areas = mlvl.areaTable;
                            var textureHolder = new render_27.RetroTextureHolder();
                            var skyboxRenderer = null;
                            var skyboxCMDL = resourceSystem.loadAssetByID(mlvl.defaultSkyboxID, 'CMDL');
                            if (skyboxCMDL) {
                                var skyboxName = resourceSystem.findResourceNameByID(mlvl.defaultSkyboxID);
                                skyboxRenderer = new render_27.CMDLRenderer(gl, textureHolder, skyboxName, skyboxCMDL);
                                skyboxRenderer.isSkybox = true;
                            }
                            var areaRenderers = areas.map(function (mreaEntry) {
                                var mrea = resourceSystem.loadAssetByID(mreaEntry.areaMREAID, 'MREA');
                                return new render_27.MREARenderer(gl, textureHolder, mreaEntry.areaName, mrea);
                            });
                            // By default, set only the first 10 area renderers to visible, so as to not "crash my browser please".
                            areaRenderers.slice(10).forEach(function (areaRenderer) {
                                areaRenderer.visible = false;
                            });
                            return { value: new MetroidPrimeWorldScene(mlvl, textureHolder, skyboxRenderer, areaRenderers) };
                        };
                        try {
                            for (var _a = __values(levelPak.namedResourceTable.values()), _b = _a.next(); !_b.done; _b = _a.next()) {
                                var mlvlEntry = _b.value;
                                var state_2 = _loop_13(mlvlEntry);
                                if (typeof state_2 === "object")
                                    return state_2.value;
                            }
                        }
                        catch (e_57_1) { e_57 = { error: e_57_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                            }
                            finally { if (e_57) throw e_57.error; }
                        }
                        return null;
                        var e_57, _c;
                    });
                };
                return MP1SceneDesc;
            }());
            id = "mp1";
            name = "Metroid Prime 1";
            sceneDescs = [
                new MP1SceneDesc("Metroid1.pak", "Space Pirate Frigate"),
                new MP1SceneDesc("Metroid2.pak", "Chozo Ruins"),
                new MP1SceneDesc("Metroid3.pak", "Phendrana Drifts"),
                new MP1SceneDesc("Metroid4.pak", "Tallon Overworld"),
                new MP1SceneDesc("Metroid5.pak", "Phazon Mines"),
                new MP1SceneDesc("Metroid6.pak", "Magmoor Caverns"),
                new MP1SceneDesc("Metroid7.pak", "Impact Crater"),
            ];
            exports_74("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
// Nintendo Yay0 format.
//
// Similar to Yaz0 (an earlier version, likely), except it packs compressed data
// into three separate substreams.
//
// Header (16 bytes):
//   Magic: "Yay0" (4 bytes)
//   Uncompressed size (4 bytes, big endian)
//   Offset to Lengths substream (4 bytes, big endian)
//   Offset to Data substream (4 bytes, big endian)
//
// Flags substream starts at 0x10 (directly after Header)
//
// Data:
//   Read Flags from Flags substream (1 byte)
//   For each bit in the Flags byte, from MSB to LSB:
//     If flag is 1:
//       Literal: copy one byte from Data substream to dest.
//     If flag is 0:
//       Read LZ77 from Lengths substream (2 bytes, big endian):
//         Length: bits 0-4
//           If Length = 0, then read additional byte from Data (not Lengths!) substream, add 16, and add it to Length.
//         Offset: bits 5-15
//         Copy Length+2 bytes from Offset back in the output buffer.
System.register("compression/Yay0", ["util", "ArrayBufferSlice"], function (exports_75, context_75) {
    "use strict";
    var __moduleName = context_75 && context_75.id;
    function decompress(srcBuffer) {
        var srcView = srcBuffer.createDataView();
        util_46.assert(util_46.readString(srcBuffer, 0x00, 0x04) === 'Yay0');
        var uncompressedSize = srcView.getUint32(0x04, false);
        var lengthsOffs = srcView.getUint32(0x08, false);
        var dataOffs = srcView.getUint32(0x0C, false);
        var flagsOffs = 0x10;
        var dstBuffer = new Uint8Array(uncompressedSize);
        var dstOffs = 0x00;
        while (true) {
            var commandByte = srcView.getUint8(flagsOffs++);
            var i = 8;
            while (i--) {
                if (commandByte & (1 << i)) {
                    // Literal.
                    uncompressedSize--;
                    dstBuffer[dstOffs++] = srcView.getUint8(dataOffs++);
                }
                else {
                    var tmp = srcView.getUint16(lengthsOffs, false);
                    lengthsOffs += 2;
                    var windowOffset = (tmp & 0x0FFF) + 1;
                    var windowLength = (tmp >> 12) + 2;
                    if (windowLength === 2) {
                        windowLength += srcView.getUint8(dataOffs++) + 0x10;
                    }
                    util_46.assert(windowLength >= 3 && windowLength <= 0x111);
                    var copyOffs = dstOffs - windowOffset;
                    uncompressedSize -= windowLength;
                    while (windowLength--)
                        dstBuffer[dstOffs++] = dstBuffer[copyOffs++];
                }
                if (uncompressedSize <= 0)
                    return new ArrayBufferSlice_9.default(dstBuffer.buffer);
            }
        }
    }
    exports_75("decompress", decompress);
    var util_46, ArrayBufferSlice_9;
    return {
        setters: [
            function (util_46_1) {
                util_46 = util_46_1;
            },
            function (ArrayBufferSlice_9_1) {
                ArrayBufferSlice_9 = ArrayBufferSlice_9_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("luigis_mansion/bin", ["util", "gl-matrix", "gx/gx_displaylist", "gx/gx_material", "Camera"], function (exports_76, context_76) {
    "use strict";
    var __moduleName = context_76 && context_76.id;
    function parse(buffer) {
        var view = buffer.createDataView();
        var version = view.getUint8(0x00);
        util_47.assert(version === 0x01 || version === 0x02);
        var name = util_47.readString(buffer, 0x01, 0x0B);
        var textureChunkOffs = view.getUint32(0x0C, false);
        var samplerChunkOffs = view.getUint32(0x10, false);
        var materialChunkOffs = view.getUint32(0x34, false);
        var batchChunkOffs = view.getUint32(0x38, false);
        var sceneGraphChunkOffs = view.getUint32(0x3C, false);
        var positionBufferOffs = view.getUint32(0x14, false);
        var tex0BufferOffs = view.getUint32(0x24, false);
        function parseTexture(index) {
            var offs = textureChunkOffs + (0x0C * index);
            var width = view.getUint16(offs + 0x00, false);
            var height = view.getUint16(offs + 0x02, false);
            var format = view.getUint8(offs + 0x04);
            var textureDataOffs = view.getUint32(offs + 0x08, false);
            var data = buffer.slice(textureChunkOffs + textureDataOffs);
            return { width: width, height: height, format: format, data: data };
        }
        function parseSampler(index) {
            var offs = samplerChunkOffs + (0x14 * index);
            var textureIndex = view.getUint16(offs + 0x00);
            var texture = parseTexture(textureIndex);
            var wrapS = view.getUint8(offs + 0x04);
            var wrapT = view.getUint8(offs + 0x04);
            return { texture: texture, wrapS: wrapS, wrapT: wrapT };
        }
        var samplers = [];
        function ensureSampler(index) {
            if (!samplers[index])
                samplers[index] = parseSampler(index);
        }
        function parseBatch(index) {
            var offs = batchChunkOffs + (0x18 * index);
            // Not used in-game.
            var triangleCount = view.getUint16(offs + 0x00, false);
            var displayListSize = view.getUint16(offs + 0x02, false) * 0x20;
            var attributes = view.getUint32(offs + 0x04, false);
            // WTF. Shouldn't this be in the material?
            var bumpMap = view.getUint8(offs + 0x08);
            var cullMode = view.getUint8(offs + 0x09);
            var texGenCount = view.getUint8(offs + 0x0A);
            var nbt3 = view.getUint8(offs + 0x0B);
            var displayListOffset = batchChunkOffs + view.getUint32(offs + 0x0C, false);
            var vat = [];
            // Should always have position.
            util_47.assert((attributes & (1 << 9 /* POS */)) !== 0);
            vat[9 /* POS */] = { compCnt: 1 /* POS_XYZ */, compType: 3 /* S16 */, compShift: 0 };
            // Should always have tex0.
            if (!(attributes & (1 << 13 /* TEX0 */))) {
                // If we don't have TEX0, then skip this batch...
                console.warn("Batch " + index + " does not have TEX0. WTF? / Attributes: " + attributes.toString(16));
                return null;
            }
            vat[13 /* TEX0 */] = { compCnt: 1 /* TEX_ST */, compType: 4 /* F32 */, compShift: 0 };
            vat[10 /* NRM */] = { compCnt: nbt3 ? 2 /* NRM_NBT3 */ : 1 /* NRM_NBT */, compType: 4 /* F32 */, compShift: 0 };
            // Set up our input vertex description.
            var vcd = [];
            for (var i = 0; i < 20 /* MAX */; i++) {
                if ((attributes & (1 << i)) !== 0) {
                    // Only care about TEX0 and POS for now...
                    var enableOutput = (i === 9 /* POS */ || i === 13 /* TEX0 */);
                    vcd[i] = { type: 3 /* INDEX16 */, enableOutput: enableOutput };
                }
            }
            var vtxLoader = gx_displaylist_3.compileVtxLoader(vat, vcd);
            var loadedVertexLayout = vtxLoader.loadedVertexLayout;
            var displayListBuffer = buffer.subarray(displayListOffset, displayListSize);
            var vtxArrays = [];
            vtxArrays[9 /* POS */] = { buffer: buffer, offs: positionBufferOffs };
            vtxArrays[13 /* TEX0 */] = { buffer: buffer, offs: tex0BufferOffs };
            var loadedVertexData;
            try {
                loadedVertexData = vtxLoader.runVertices(vtxArrays, displayListBuffer);
            }
            catch (e) {
                // Could not parse batch.
                console.warn("Batch " + index + " had parse error: " + e + " / Attributes: " + attributes.toString(16));
                return null;
            }
            return { vat: vat, loadedVertexLayout: loadedVertexLayout, loadedVertexData: loadedVertexData };
        }
        function parseMaterial(index) {
            var offs = materialChunkOffs + (0x28 * index);
            // TODO(jstpierre): diffuse color
            var samplerIndexes = [];
            for (var i = 0; i < 8; i++) {
                var samplerIndex = view.getInt16(offs + 0x08 + (i * 0x02), false);
                samplerIndexes.push(samplerIndex);
                if (samplerIndex >= 0)
                    ensureSampler(samplerIndex);
            }
            // Fake a GX material.
            var texGen0 = {
                index: 0,
                type: 1 /* MTX2x4 */,
                source: 4 /* TEX0 */,
                matrix: 60 /* IDENTITY */,
                normalize: false,
                postMatrix: 125 /* PTIDENTITY */
            };
            var texGens = [texGen0];
            var colorRegisters = [];
            colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
            colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
            colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
            colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
            var lightChannel0 = {
                alphaChannel: { lightingEnabled: false, ambColorSource: 1 /* VTX */, matColorSource: 1 /* VTX */ },
                colorChannel: { lightingEnabled: false, ambColorSource: 1 /* VTX */, matColorSource: 1 /* VTX */ },
            };
            var lightChannels = [lightChannel0, lightChannel0];
            var tevStage0 = {
                index: 0,
                channelId: 0 /* COLOR0A0 */,
                alphaInA: 7 /* ZERO */,
                alphaInB: 7 /* ZERO */,
                alphaInC: 7 /* ZERO */,
                alphaInD: 4 /* TEXA */,
                alphaOp: 0 /* ADD */,
                alphaBias: 0 /* ZERO */,
                alphaClamp: false,
                alphaScale: 0 /* SCALE_1 */,
                alphaRegId: 0 /* PREV */,
                konstAlphaSel: 0 /* KASEL_1 */,
                colorInA: 15 /* ZERO */,
                colorInB: 15 /* ZERO */,
                colorInC: 15 /* ZERO */,
                colorInD: 8 /* TEXC */,
                colorOp: 0 /* ADD */,
                colorBias: 0 /* ZERO */,
                colorClamp: false,
                colorScale: 0 /* SCALE_1 */,
                colorRegId: 0 /* PREV */,
                konstColorSel: 0 /* KCSEL_1 */,
                texCoordId: 0 /* TEXCOORD0 */,
                texMap: 0 /* TEXMAP0 */,
                // We don't use indtex.
                indTexStage: 0 /* STAGE0 */,
                indTexMatrix: 0 /* OFF */,
                indTexFormat: 0 /* _8 */,
                indTexBiasSel: 0 /* NONE */,
                indTexWrapS: 0 /* OFF */,
                indTexWrapT: 0 /* OFF */,
                indTexAddPrev: false,
                indTexUseOrigLOD: false,
            };
            var tevStages = [tevStage0];
            // Filter any pixels less than 0.1.
            var alphaTest = {
                op: 0 /* AND */,
                compareA: 6 /* GEQUAL */,
                compareB: 7 /* ALWAYS */,
                referenceA: 0.1,
                referenceB: 0.0,
            };
            var blendMode = {
                type: 0 /* NONE */,
                srcFactor: 1 /* ONE */,
                dstFactor: 1 /* ONE */,
                logicOp: 0 /* CLEAR */,
            };
            var ropInfo = {
                blendMode: blendMode,
                depthFunc: 1 /* LESS */,
                depthTest: true,
                depthWrite: true,
            };
            var gxMaterial = {
                index: index, name: '',
                cullMode: 2 /* BACK */,
                lightChannels: lightChannels,
                texGens: texGens,
                colorRegisters: colorRegisters,
                colorConstants: colorRegisters,
                tevStages: tevStages,
                alphaTest: alphaTest,
                ropInfo: ropInfo,
                indTexStages: [],
            };
            return { gxMaterial: gxMaterial, samplerIndexes: samplerIndexes };
        }
        function traverseSceneGraph(parentNode, nodeIndex) {
            var nodeOffs = sceneGraphChunkOffs + (0x8C * nodeIndex);
            var parentIndex = view.getInt16(nodeOffs + 0x00, false);
            var firstChildIndex = view.getInt16(nodeOffs + 0x02, false);
            var nextSiblingIndex = view.getInt16(nodeOffs + 0x04, false);
            var prevSiblingIndex = view.getInt16(nodeOffs + 0x06, false);
            // view.getUint8(nodeOffs + 0x08);
            var flags = view.getUint8(nodeOffs + 0x09);
            // view.getUint16(node.offs + 0x0A);
            var modelMatrix = gl_matrix_17.mat4.create();
            var scaleX = view.getFloat32(nodeOffs + 0x0C, false);
            var scaleY = view.getFloat32(nodeOffs + 0x10, false);
            var scaleZ = view.getFloat32(nodeOffs + 0x14, false);
            var rotationX = view.getFloat32(nodeOffs + 0x18, false);
            var rotationY = view.getFloat32(nodeOffs + 0x1C, false);
            var rotationZ = view.getFloat32(nodeOffs + 0x20, false);
            var translationX = view.getFloat32(nodeOffs + 0x24, false);
            var translationY = view.getFloat32(nodeOffs + 0x28, false);
            var translationZ = view.getFloat32(nodeOffs + 0x2C, false);
            var bboxMinX = view.getFloat32(nodeOffs + 0x30, false);
            var bboxMinY = view.getFloat32(nodeOffs + 0x34, false);
            var bboxMinZ = view.getFloat32(nodeOffs + 0x38, false);
            var bboxMaxX = view.getFloat32(nodeOffs + 0x3C, false);
            var bboxMaxY = view.getFloat32(nodeOffs + 0x40, false);
            var bboxMaxZ = view.getFloat32(nodeOffs + 0x44, false);
            // const unk = view.getFloat32(nodeOffs + 0x48, false);
            var bbox = null;
            if (bboxMinX !== 0 || bboxMinY !== 0 || bboxMinZ !== 0 || bboxMaxX !== 0 || bboxMaxY !== 0 || bboxMaxZ !== 0) {
                bbox = new Camera_10.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
            }
            var scale = gl_matrix_17.vec3.fromValues(scaleX, scaleY, scaleZ);
            var rotation = gl_matrix_17.quat.create();
            gl_matrix_17.quat.fromEuler(rotation, rotationX, rotationY, rotationZ);
            var translation = gl_matrix_17.vec3.fromValues(translationX, translationY, translationZ);
            gl_matrix_17.mat4.fromRotationTranslationScale(modelMatrix, rotation, translation, scale);
            // Flatten matrix hierarchy.
            gl_matrix_17.mat4.mul(modelMatrix, parentNode.modelMatrix, modelMatrix);
            var parts = [];
            var partCount = view.getUint16(nodeOffs + 0x4C, false);
            var partTableIdx = sceneGraphChunkOffs + view.getUint32(nodeOffs + 0x50, false);
            for (var i = 0; i < partCount; i++) {
                var materialIndex = view.getUint16(partTableIdx + 0x00, false);
                var batchIndex = view.getUint16(partTableIdx + 0x02, false);
                partTableIdx += 0x04;
                var material = parseMaterial(materialIndex);
                var batch = parseBatch(batchIndex);
                if (batch === null)
                    continue;
                parts.push({ material: material, batch: batch });
            }
            var children = [];
            var node = { children: children, modelMatrix: modelMatrix, bbox: bbox, parts: parts };
            // Add ourselves to parent.
            parentNode.children.push(node);
            // Parse children
            if (firstChildIndex >= 0)
                traverseSceneGraph(node, firstChildIndex);
            // Advance to next sibling.
            if (nextSiblingIndex >= 0)
                traverseSceneGraph(parentNode, nextSiblingIndex);
        }
        // Create a fake root node to be parent to the root nodes.
        var rootNode = { children: [], modelMatrix: gl_matrix_17.mat4.create(), bbox: null, parts: [] };
        traverseSceneGraph(rootNode, 0);
        var bin = { rootNode: rootNode, samplers: samplers };
        return bin;
    }
    exports_76("parse", parse);
    var util_47, gl_matrix_17, gx_displaylist_3, GX_Material, Camera_10;
    return {
        setters: [
            function (util_47_1) {
                util_47 = util_47_1;
            },
            function (gl_matrix_17_1) {
                gl_matrix_17 = gl_matrix_17_1;
            },
            function (gx_displaylist_3_1) {
                gx_displaylist_3 = gx_displaylist_3_1;
            },
            function (GX_Material_7) {
                GX_Material = GX_Material_7;
            },
            function (Camera_10_1) {
                Camera_10 = Camera_10_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("luigis_mansion/render", ["gx/gx_texture", "gx/gx_material", "gx/gx_render", "util", "gl-matrix", "Camera"], function (exports_77, context_77) {
    "use strict";
    var __moduleName = context_77 && context_77.id;
    var GX_Texture, GX_Material, gx_render_3, util_48, gl_matrix_18, Camera_11, Command_Material, bboxScratch, Command_Batch, BinScene;
    return {
        setters: [
            function (GX_Texture_3) {
                GX_Texture = GX_Texture_3;
            },
            function (GX_Material_8) {
                GX_Material = GX_Material_8;
            },
            function (gx_render_3_1) {
                gx_render_3 = gx_render_3_1;
            },
            function (util_48_1) {
                util_48 = util_48_1;
            },
            function (gl_matrix_18_1) {
                gl_matrix_18 = gl_matrix_18_1;
            },
            function (Camera_11_1) {
                Camera_11 = Camera_11_1;
            }
        ],
        execute: function () {
            Command_Material = /** @class */ (function () {
                function Command_Material(gl, scene, material) {
                    this.scene = scene;
                    this.material = material;
                    this.materialParams = new gx_render_3.MaterialParams();
                    this.program = new GX_Material.GX_Program(this.material.gxMaterial);
                    this.renderFlags = GX_Material.translateRenderFlags(this.material.gxMaterial);
                    // We don't animate, so we only need to compute this once.
                    this.fillMaterialParams(this.materialParams);
                }
                Command_Material.prototype.fillMaterialParams = function (materialParams) {
                    // All we care about is textures...
                    for (var i = 0; i < this.material.samplerIndexes.length; i++) {
                        var samplerIndex = this.material.samplerIndexes[i];
                        if (samplerIndex >= 0) {
                            var m = this.materialParams.m_TextureMapping[i];
                            m.glTexture = this.scene.glTextures[samplerIndex];
                        }
                    }
                };
                Command_Material.prototype.exec = function (state) {
                    var gl = state.gl;
                    state.useProgram(this.program);
                    state.useFlags(this.renderFlags);
                    this.scene.renderHelper.bindMaterialParams(state, this.materialParams);
                    this.scene.renderHelper.bindMaterialTextures(state, this.materialParams, this.program);
                };
                Command_Material.prototype.destroy = function (gl) {
                    this.program.destroy(gl);
                };
                return Command_Material;
            }());
            bboxScratch = new Camera_11.AABB();
            Command_Batch = /** @class */ (function () {
                function Command_Batch(gl, scene, sceneGraphNode, batch, coalescedBuffers) {
                    this.scene = scene;
                    this.sceneGraphNode = sceneGraphNode;
                    this.batch = batch;
                    this.coalescedBuffers = coalescedBuffers;
                    this.packetParams = new gx_render_3.PacketParams();
                    this.shapeHelper = new gx_render_3.GXShapeHelper(gl, coalescedBuffers, batch.loadedVertexLayout, batch.loadedVertexData);
                }
                Command_Batch.prototype.computeModelView = function (dst, state) {
                    gl_matrix_18.mat4.copy(dst, state.updateModelView(false, this.sceneGraphNode.modelMatrix));
                };
                Command_Batch.prototype.exec = function (state) {
                    var gl = state.gl;
                    if (this.sceneGraphNode.bbox) {
                        bboxScratch.transform(this.sceneGraphNode.bbox, this.sceneGraphNode.modelMatrix);
                        if (state.camera.frustum.intersect(bboxScratch) === Camera_11.IntersectionState.FULLY_OUTSIDE) {
                            return;
                        }
                    }
                    this.computeModelView(this.packetParams.u_PosMtx[0], state);
                    this.scene.renderHelper.bindPacketParams(state, this.packetParams);
                    this.shapeHelper.drawSimple(gl);
                    state.drawCallCount++;
                };
                Command_Batch.prototype.destroy = function (gl) {
                    this.shapeHelper.destroy(gl);
                };
                return Command_Batch;
            }());
            BinScene = /** @class */ (function () {
                function BinScene(gl, bin) {
                    this.bin = bin;
                    this.textures = [];
                    this.glTextures = [];
                    this.visible = true;
                    this.sceneParams = new gx_render_3.SceneParams();
                    this.translateModel(gl, bin);
                    this.renderHelper = new gx_render_3.GXRenderHelper(gl);
                }
                BinScene.prototype.setVisible = function (visible) {
                    this.visible = visible;
                };
                BinScene.prototype.render = function (state) {
                    if (!this.visible)
                        return;
                    state.setClipPlanes(10, 500000);
                    this.renderHelper.bindUniformBuffers(state);
                    gx_render_3.fillSceneParamsFromRenderState(this.sceneParams, state);
                    this.renderHelper.bindSceneParams(state, this.sceneParams);
                    this.commands.forEach(function (command) {
                        command.exec(state);
                    });
                };
                BinScene.prototype.destroy = function (gl) {
                    this.glTextures.forEach(function (textureId) { return gl.deleteTexture(textureId); });
                    this.renderHelper.destroy(gl);
                    this.bufferCoalescer.destroy(gl);
                };
                BinScene.prototype.translatePart = function (gl, node, part) {
                    var materialCommand = new Command_Material(gl, this, part.material);
                    this.commands.push(materialCommand);
                    var batch = part.batch;
                    var batchIndex = this.batches.indexOf(batch);
                    util_48.assert(batchIndex >= 0);
                    var batchCommand = new Command_Batch(gl, this, node, batch, this.bufferCoalescer.coalescedBuffers[batchIndex]);
                    this.commands.push(batchCommand);
                };
                BinScene.prototype.translateSceneGraph = function (gl, node) {
                    try {
                        for (var _a = __values(node.parts), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var part = _b.value;
                            this.translatePart(gl, node, part);
                        }
                    }
                    catch (e_58_1) { e_58 = { error: e_58_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_58) throw e_58.error; }
                    }
                    try {
                        for (var _d = __values(node.children), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var child = _e.value;
                            this.translateSceneGraph(gl, child);
                        }
                    }
                    catch (e_59_1) { e_59 = { error: e_59_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                        }
                        finally { if (e_59) throw e_59.error; }
                    }
                    var e_58, _c, e_59, _f;
                };
                BinScene.prototype.collectBatches = function (batches, node) {
                    try {
                        for (var _a = __values(node.parts), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var part = _b.value;
                            batches.push(part.batch);
                        }
                    }
                    catch (e_60_1) { e_60 = { error: e_60_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_60) throw e_60.error; }
                    }
                    try {
                        for (var _d = __values(node.children), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var child = _e.value;
                            this.collectBatches(batches, child);
                        }
                    }
                    catch (e_61_1) { e_61 = { error: e_61_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                        }
                        finally { if (e_61) throw e_61.error; }
                    }
                    var e_60, _c, e_61, _f;
                };
                BinScene.prototype.translateModel = function (gl, bin) {
                    for (var i = 0; i < bin.samplers.length; i++) {
                        var sampler = bin.samplers[i];
                        var texture = __assign({}, sampler.texture, { name: "unknown " + i });
                        var mipChain = GX_Texture.calcMipChain(texture, 1);
                        var _a = gx_render_3.loadTextureFromMipChain(gl, mipChain), glTexture = _a.glTexture, viewerTexture = _a.viewerTexture;
                        // GL texture is bound by loadTextureFromMipChain.
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gx_render_3.translateWrapMode(gl, sampler.wrapS));
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gx_render_3.translateWrapMode(gl, sampler.wrapT));
                        this.glTextures.push(glTexture);
                        this.textures.push(viewerTexture);
                    }
                    // First, collect all the batches we're rendering.
                    this.batches = [];
                    this.collectBatches(this.batches, bin.rootNode);
                    // Coalesce buffers.
                    this.bufferCoalescer = gx_render_3.loadedDataCoalescer(gl, this.batches.map(function (batch) { return batch.loadedVertexData; }));
                    this.commands = [];
                    this.translateSceneGraph(gl, bin.rootNode);
                };
                return BinScene;
            }());
            exports_77("BinScene", BinScene);
        }
    };
});
System.register("luigis_mansion/scenes", ["Progressable", "compression/Yay0", "util", "j3d/rarc", "luigis_mansion/bin", "luigis_mansion/render", "ui", "j3d/scenes", "j3d/render"], function (exports_78, context_78) {
    "use strict";
    var __moduleName = context_78 && context_78.id;
    function collectTextures(scenes) {
        var textures = [];
        try {
            for (var scenes_8 = __values(scenes), scenes_8_1 = scenes_8.next(); !scenes_8_1.done; scenes_8_1 = scenes_8.next()) {
                var scene = scenes_8_1.value;
                if (scene)
                    textures.push.apply(textures, scene.textures);
            }
        }
        catch (e_62_1) { e_62 = { error: e_62_1 }; }
        finally {
            try {
                if (scenes_8_1 && !scenes_8_1.done && (_a = scenes_8.return)) _a.call(scenes_8);
            }
            finally { if (e_62) throw e_62.error; }
        }
        return textures;
        var e_62, _a;
    }
    function fetchVRBScene(gl, path) {
        return util_49.fetch("data/luigis_mansion/" + path).then(function (buffer) {
            var decompressed = Yay0.decompress(buffer);
            var textureHolder = new render_29.J3DTextureHolder();
            return scenes_9.createScenesFromBuffer(gl, textureHolder, decompressed).then(function (scenes) {
                util_49.assert(scenes.length === 1);
                return scenes[0];
            });
        });
    }
    function fetchBinScene(gl, path) {
        return util_49.fetch("data/luigis_mansion/" + path).then(function (buffer) {
            var binBuffer;
            if (path.endsWith('.bin')) {
                binBuffer = buffer;
            }
            else if (path.endsWith('.arc')) {
                var rarc = RARC.parse(buffer);
                var roomBinFile = rarc.findFile('room.bin');
                binBuffer = roomBinFile.buffer;
            }
            var bin = BIN.parse(binBuffer);
            var binScene = new render_30.BinScene(gl, bin);
            binScene.name = path.split('/').pop();
            return binScene;
        });
    }
    function zeroPad(i) {
        var s = '' + i;
        if (s.length === 1)
            return '0' + s;
        else
            return s;
    }
    var Progressable_9, Yay0, util_49, RARC, BIN, render_30, UI, scenes_9, render_29, LuigisMansionScene, LuigisMansionBinSceneDesc, map2RoomsPaths, id, name, sceneDescs, sceneGroup;
    return {
        setters: [
            function (Progressable_9_1) {
                Progressable_9 = Progressable_9_1;
            },
            function (Yay0_1) {
                Yay0 = Yay0_1;
            },
            function (util_49_1) {
                util_49 = util_49_1;
            },
            function (RARC_6) {
                RARC = RARC_6;
            },
            function (BIN_1) {
                BIN = BIN_1;
            },
            function (render_30_1) {
                render_30 = render_30_1;
            },
            function (UI_6) {
                UI = UI_6;
            },
            function (scenes_9_1) {
                scenes_9 = scenes_9_1;
            },
            function (render_29_1) {
                render_29 = render_29_1;
            }
        ],
        execute: function () {
            LuigisMansionScene = /** @class */ (function () {
                function LuigisMansionScene(roomScenes) {
                    this.roomScenes = roomScenes;
                    this.textures = collectTextures(roomScenes);
                }
                LuigisMansionScene.prototype.createPanels = function () {
                    var layers = new UI.LayerPanel();
                    layers.setLayers(this.roomScenes);
                    return [layers];
                };
                LuigisMansionScene.prototype.render = function (state) {
                    this.roomScenes.forEach(function (scene) {
                        scene.render(state);
                    });
                };
                LuigisMansionScene.prototype.destroy = function (gl) {
                    this.roomScenes.forEach(function (scene) { return scene.destroy(gl); });
                };
                return LuigisMansionScene;
            }());
            LuigisMansionBinSceneDesc = /** @class */ (function () {
                function LuigisMansionBinSceneDesc(id, name, paths) {
                    this.id = id;
                    this.name = name;
                    this.paths = paths;
                }
                LuigisMansionBinSceneDesc.prototype.createScene = function (gl) {
                    var promises = this.paths.map(function (path) { return fetchBinScene(gl, path); });
                    // TODO(jstpierre): J3D format in VRB has a different version with a different MAT3 chunk.
                    // promises.unshift(fetchVRBScene(gl, `vrball_B.szp`));
                    return Progressable_9.default.all(promises).then(function (roomScenes) {
                        roomScenes = roomScenes.filter(function (s) { return !!s; });
                        return new LuigisMansionScene(roomScenes);
                    });
                };
                return LuigisMansionBinSceneDesc;
            }());
            // Main mansion
            map2RoomsPaths = [
                "map2/room_00.arc",
                "map2/room_01.arc",
                "map2/room_02.arc",
                "map2/room_03.arc",
                "map2/room_04.arc",
                "map2/room_05.arc",
                "map2/room_06.arc",
                "map2/room_07.arc",
                "map2/room_08.arc",
                "map2/room_09.arc",
                "map2/room_10.arc",
                "map2/room_11.arc",
                "map2/room_12.arc",
                "map2/room_13.arc",
                "map2/room_14.arc",
                "map2/room_15.arc",
                "map2/room_16.arc",
                "map2/room_17.arc",
                "map2/room_18.arc",
                "map2/room_19.arc",
                "map2/room_20.arc",
                "map2/room_21.arc",
                "map2/room_22.arc",
                "map2/room_23.arc",
                "map2/room_24.arc",
                "map2/room_25.arc",
                "map2/room_26.arc",
                "map2/room_27.arc",
                "map2/room_28.arc",
                "map2/room_28A.arc",
                "map2/room_29.arc",
                "map2/room_30.arc",
                "map2/room_31.arc",
                "map2/room_32.arc",
                "map2/room_33.arc",
                "map2/room_34.arc",
                "map2/room_35.arc",
                "map2/room_36.arc",
                "map2/room_37.arc",
                "map2/room_38.arc",
                "map2/room_39.arc",
                "map2/room_40.arc",
                "map2/room_41.arc",
                "map2/room_42.arc",
                "map2/room_43.arc",
                "map2/room_44.arc",
                "map2/room_45.arc",
                "map2/room_46.arc",
                "map2/room_47.arc",
                "map2/room_48.arc",
                "map2/room_49.arc",
                "map2/room_50.arc",
                "map2/room_51.arc",
                "map2/room_52.arc",
                "map2/room_53.arc",
                "map2/room_54.arc",
                "map2/room_55.arc",
                "map2/room_56.arc",
                "map2/room_57.arc",
                "map2/room_58.arc",
                "map2/room_59.arc",
                "map2/room_60.arc",
                "map2/room_61.arc",
                "map2/room_62.arc",
                "map2/room_63.arc",
                "map2/room_64.arc",
                "map2/room_65.arc",
                "map2/room_66.arc",
                "map2/room_67.arc",
                "map2/room_68.arc",
                "map2/room_69.arc",
                "map2/room_70.arc",
                "map2/room_71.arc",
                "map2/room_72.arc",
                "map2/room_73.arc",
            ];
            id = "luigis_mansion";
            name = "Luigi's Mansion";
            sceneDescs = [
                new LuigisMansionBinSceneDesc('map2', "Main Mansion", map2RoomsPaths),
                // h_01.bin is a duplicate of the room.bin found in hakase.arc
                new LuigisMansionBinSceneDesc('map1', "E Gadd's Garage", ['map1/h_02.bin', 'map1/hakase.arc']),
                new LuigisMansionBinSceneDesc('map3', "Training Room", ['map3/h_07_00.arc']),
                new LuigisMansionBinSceneDesc('map4', "Ghost Portrificationizer", ['map4/h_02.bin']),
                new LuigisMansionBinSceneDesc('map6', "Gallery", ['map6/gyara_00.arc', 'map6/gyara_01.arc', 'map6/gyara_02.arc', 'map6/gyara_03.arc']),
                new LuigisMansionBinSceneDesc('map5', "Gallery (Unused)", ['map5/h_03_00.bin', 'map5/h_03_01.bin', 'map5/h_03_02.bin', 'map5/h_03_03.bin']),
                new LuigisMansionBinSceneDesc('map7', "Gallery (Unused 2)", ['map7/h_05_00.bin', 'map7/h_05_01.bin', 'map7/h_05_02.bin', 'map7/h_05_03.bin']),
                new LuigisMansionBinSceneDesc('map8', "Gallery (Unused 3)", ['map8/h_06_00.bin', 'map8/h_06_01.bin', 'map8/h_06_02.bin', 'map8/h_06_03.bin']),
                new LuigisMansionBinSceneDesc('map9', "King Boo Boss Arena", ['map9/lastroof.arc']),
                new LuigisMansionBinSceneDesc('map10', "Chauncey Boss Arena", ['map10/roombed.arc']),
                new LuigisMansionBinSceneDesc('map11', "Boolossus Boss Arena", ['map11/beranda.arc']),
                new LuigisMansionBinSceneDesc('map13', "Bogmire Boss Arena", ['map13/tombboss.arc']),
                new LuigisMansionBinSceneDesc('map12', "Ghost Portrificationizer (End Credits)", ['map12/h_02.bin']),
            ];
            exports_78("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
System.register("rres/render", ["rres/brres", "gx/gx_material", "gl-matrix", "gx/gx_render", "Camera", "j3d/render"], function (exports_79, context_79) {
    "use strict";
    var __moduleName = context_79 && context_79.id;
    var BRRES, GX_Material, gl_matrix_19, gx_render_4, Camera_12, render_31, RRESTextureHolder, ModelRenderer, Command_Shape, matrixScratch, Command_Material;
    return {
        setters: [
            function (BRRES_1) {
                BRRES = BRRES_1;
            },
            function (GX_Material_9) {
                GX_Material = GX_Material_9;
            },
            function (gl_matrix_19_1) {
                gl_matrix_19 = gl_matrix_19_1;
            },
            function (gx_render_4_1) {
                gx_render_4 = gx_render_4_1;
            },
            function (Camera_12_1) {
                Camera_12 = Camera_12_1;
            },
            function (render_31_1) {
                render_31 = render_31_1;
            }
        ],
        execute: function () {
            RRESTextureHolder = /** @class */ (function (_super) {
                __extends(RRESTextureHolder, _super);
                function RRESTextureHolder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                RRESTextureHolder.prototype.addRRESTextures = function (gl, rres) {
                    this.addTextures(gl, rres.tex0);
                };
                return RRESTextureHolder;
            }(gx_render_4.TextureHolder));
            exports_79("RRESTextureHolder", RRESTextureHolder);
            ModelRenderer = /** @class */ (function () {
                function ModelRenderer(gl, textureHolder, mdl0, namePrefix, materialHacks) {
                    if (namePrefix === void 0) { namePrefix = ''; }
                    if (materialHacks === void 0) { materialHacks = null; }
                    this.textureHolder = textureHolder;
                    this.mdl0 = mdl0;
                    this.namePrefix = namePrefix;
                    this.materialHacks = materialHacks;
                    this.materialCommands = [];
                    this.shapeCommands = [];
                    this.sceneParams = new gx_render_4.SceneParams();
                    this.packetParams = new gx_render_4.PacketParams();
                    this.matrixVisibility = [];
                    this.matrixArray = [];
                    this.matrixScratch = gl_matrix_19.mat4.create();
                    this.bboxScratch = new Camera_12.AABB();
                    this.colorOverrides = [];
                    this.modelMatrix = gl_matrix_19.mat4.create();
                    this.visible = true;
                    this.isSkybox = false;
                    this.renderHelper = new gx_render_4.GXRenderHelper(gl);
                    this.translateModel(gl);
                    this.name = namePrefix + "/" + mdl0.name;
                }
                ModelRenderer.prototype.bindCHR0 = function (animationController, chr0) {
                    this.chr0NodeAnimator = BRRES.bindCHR0Animator(animationController, chr0, this.mdl0.nodes);
                };
                ModelRenderer.prototype.bindSRT0 = function (animationController, srt0) {
                    for (var i = 0; i < this.materialCommands.length; i++) {
                        var cmd = this.materialCommands[i];
                        cmd.bindSRT0(animationController, srt0);
                    }
                };
                ModelRenderer.prototype.bindPAT0 = function (animationController, pat0) {
                    for (var i = 0; i < this.materialCommands.length; i++) {
                        var cmd = this.materialCommands[i];
                        cmd.bindPAT0(animationController, pat0);
                    }
                };
                ModelRenderer.prototype.bindCLR0 = function (animationController, clr0) {
                    for (var i = 0; i < this.materialCommands.length; i++) {
                        var cmd = this.materialCommands[i];
                        cmd.bindCLR0(animationController, clr0);
                    }
                };
                ModelRenderer.prototype.bindRRESAnimations = function (animationController, rres) {
                    for (var i = 0; i < rres.chr0.length; i++)
                        this.bindCHR0(animationController, rres.chr0[i]);
                    for (var i = 0; i < rres.srt0.length; i++)
                        this.bindSRT0(animationController, rres.srt0[i]);
                    for (var i = 0; i < rres.pat0.length; i++)
                        this.bindPAT0(animationController, rres.pat0[i]);
                    for (var i = 0; i < rres.clr0.length; i++)
                        this.bindCLR0(animationController, rres.clr0[i]);
                };
                ModelRenderer.prototype.setColorOverride = function (i, color) {
                    this.colorOverrides[i] = color;
                };
                ModelRenderer.prototype.setVisible = function (visible) {
                    this.visible = visible;
                };
                ModelRenderer.prototype.render = function (state) {
                    if (!this.visible)
                        return;
                    // Frustum cull.
                    if (this.mdl0.bbox !== null) {
                        var bbox = this.bboxScratch;
                        bbox.transform(this.mdl0.bbox, this.modelMatrix);
                        if (state.camera.frustum.intersect(bbox) === Camera_12.IntersectionState.FULLY_OUTSIDE)
                            return;
                    }
                    // First, update our matrix state.
                    this.execNodeTreeOpList(state, this.mdl0.sceneGraph.nodeTreeOps);
                    this.renderHelper.bindUniformBuffers(state);
                    gx_render_4.fillSceneParamsFromRenderState(this.sceneParams, state);
                    this.renderHelper.bindSceneParams(state, this.sceneParams);
                    // TODO(jstpierre): Split into two draws.
                    this.execDrawOpList(state, this.mdl0.sceneGraph.drawOpaOps);
                    this.execDrawOpList(state, this.mdl0.sceneGraph.drawXluOps);
                };
                ModelRenderer.prototype.destroy = function (gl) {
                    this.renderHelper.destroy(gl);
                    this.materialCommands.forEach(function (cmd) { return cmd.destroy(gl); });
                    this.shapeCommands.forEach(function (cmd) { return cmd.destroy(gl); });
                };
                ModelRenderer.prototype.execDrawOpList = function (state, opList) {
                    var lastMatId = -1;
                    for (var i = 0; i < opList.length; i++) {
                        var op = opList[i];
                        var node = this.mdl0.nodes[op.nodeId];
                        if (this.matrixVisibility[node.mtxId] === Camera_12.IntersectionState.FULLY_OUTSIDE)
                            continue;
                        var matCommand = this.materialCommands[op.matId];
                        if (!matCommand.visible)
                            continue;
                        var usesEnvelope = (node.mtxId < 0);
                        if (usesEnvelope)
                            throw "whoops";
                        var shpCommand = this.shapeCommands[op.shpId];
                        var nodeModelMtx = this.matrixArray[node.mtxId];
                        var modelView = state.updateModelView(this.isSkybox, nodeModelMtx);
                        if (op.matId != lastMatId) {
                            matCommand.exec(state, this.renderHelper);
                            lastMatId = op.matId;
                        }
                        gl_matrix_19.mat4.copy(this.packetParams.u_PosMtx[0], modelView);
                        this.renderHelper.bindPacketParams(state, this.packetParams);
                        shpCommand.exec(state);
                    }
                };
                ModelRenderer.prototype.growMatrixArray = function (opList) {
                    for (var i = 0; i < opList.length; i++) {
                        var op = opList[i];
                        var dstMtxId = void 0;
                        if (op.op === 2 /* NODEDESC */) {
                            var node = this.mdl0.nodes[op.nodeId];
                            dstMtxId = node.mtxId;
                        }
                        else if (op.op === 6 /* MTXDUP */) {
                            dstMtxId = op.toMtxId;
                        }
                        else {
                            throw "whoops";
                        }
                        var newSize = dstMtxId + 1;
                        while (this.matrixArray.length < newSize)
                            this.matrixArray.push(gl_matrix_19.mat4.create());
                    }
                };
                ModelRenderer.prototype.execNodeTreeOpList = function (state, opList) {
                    gl_matrix_19.mat4.copy(this.matrixArray[0], this.modelMatrix);
                    this.matrixVisibility[0] = Camera_12.IntersectionState.PARTIAL_INTERSECT;
                    for (var i = 0; i < opList.length; i++) {
                        var op = opList[i];
                        if (op.op === 2 /* NODEDESC */) {
                            var node = this.mdl0.nodes[op.nodeId];
                            var parentMtxId = op.parentMtxId;
                            var dstMtxId = node.mtxId;
                            var modelMatrix = void 0;
                            if (this.chr0NodeAnimator && this.chr0NodeAnimator.calcModelMtx(this.matrixScratch, op.nodeId)) {
                                modelMatrix = this.matrixScratch;
                            }
                            else {
                                modelMatrix = node.modelMatrix;
                            }
                            gl_matrix_19.mat4.mul(this.matrixArray[dstMtxId], this.matrixArray[parentMtxId], modelMatrix);
                            var bboxScratch = this.bboxScratch;
                            bboxScratch.transform(node.bbox, this.matrixArray[dstMtxId]);
                            this.matrixVisibility[dstMtxId] = state.camera.frustum.intersect(bboxScratch);
                        }
                        else if (op.op === 6 /* MTXDUP */) {
                            var srcMtxId = op.fromMtxId;
                            var dstMtxId = op.toMtxId;
                            gl_matrix_19.mat4.copy(this.matrixArray[dstMtxId], this.matrixArray[srcMtxId]);
                            this.matrixVisibility[dstMtxId] = this.matrixVisibility[srcMtxId];
                        }
                    }
                };
                ModelRenderer.prototype.translateModel = function (gl) {
                    this.growMatrixArray(this.mdl0.sceneGraph.nodeTreeOps);
                    try {
                        for (var _a = __values(this.mdl0.materials), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var material = _b.value;
                            this.materialCommands.push(new Command_Material(gl, this, this.textureHolder, material, this.materialHacks));
                        }
                    }
                    catch (e_63_1) { e_63 = { error: e_63_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_63) throw e_63.error; }
                    }
                    this.bufferCoalescer = gx_render_4.loadedDataCoalescer(gl, this.mdl0.shapes.map(function (shape) { return shape.loadedVertexData; }));
                    for (var i = 0; i < this.mdl0.shapes.length; i++) {
                        var shape = this.mdl0.shapes[i];
                        this.shapeCommands.push(new Command_Shape(gl, this.bufferCoalescer.coalescedBuffers[i], shape));
                    }
                    var e_63, _c;
                };
                return ModelRenderer;
            }());
            exports_79("ModelRenderer", ModelRenderer);
            Command_Shape = /** @class */ (function () {
                function Command_Shape(gl, coalescedBuffers, shape) {
                    this.shape = shape;
                    this.shapeHelper = new gx_render_4.GXShapeHelper(gl, coalescedBuffers, shape.loadedVertexLayout, shape.loadedVertexData);
                }
                Command_Shape.prototype.exec = function (state) {
                    var gl = state.gl;
                    this.shapeHelper.drawSimple(gl);
                };
                Command_Shape.prototype.destroy = function (gl) {
                    this.shapeHelper.destroy(gl);
                };
                return Command_Shape;
            }());
            matrixScratch = gl_matrix_19.mat4.create();
            Command_Material = /** @class */ (function () {
                function Command_Material(gl, model, textureHolder, material, materialHacks) {
                    this.model = model;
                    this.textureHolder = textureHolder;
                    this.material = material;
                    this.materialHacks = materialHacks;
                    this.materialParams = new gx_render_4.MaterialParams();
                    this.glSamplers = [];
                    this.srt0Animators = [];
                    this.pat0Animators = [];
                    this.clr0Animators = [];
                    this.visible = true;
                    this.program = new GX_Material.GX_Program(this.material.gxMaterial, this.materialHacks);
                    this.program.name = this.material.name;
                    this.renderFlags = GX_Material.translateRenderFlags(this.material.gxMaterial);
                    this.translateSamplers(gl);
                }
                Command_Material.prototype.bindSRT0 = function (animationController, srt0) {
                    for (var i = 0; i < BRRES.TexMtxIndex.COUNT; i++) {
                        var srtAnimator = BRRES.bindSRT0Animator(animationController, srt0, this.material.name, i);
                        if (srtAnimator)
                            this.srt0Animators[i] = srtAnimator;
                    }
                };
                Command_Material.prototype.bindPAT0 = function (animationController, pat0) {
                    for (var i = 0; i < 8; i++) {
                        var patAnimator = BRRES.bindPAT0Animator(animationController, pat0, this.material.name, i);
                        if (patAnimator)
                            this.pat0Animators[i] = patAnimator;
                    }
                };
                Command_Material.prototype.bindCLR0 = function (animationController, clr0) {
                    for (var i = 0; i < BRRES.AnimatableColor.COUNT; i++) {
                        var clrAnimator = BRRES.bindCLR0Animator(animationController, clr0, this.material.name, i);
                        if (clrAnimator)
                            this.clr0Animators[i] = clrAnimator;
                    }
                };
                Command_Material.prototype.translateSamplers = function (gl) {
                    for (var i = 0; i < 8; i++) {
                        var sampler = this.material.samplers[i];
                        if (!sampler)
                            continue;
                        // Check sampler validity.
                        if (!this.textureHolder.hasTexture(sampler.name))
                            console.warn("Missing texture:", sampler.name);
                        var glSampler = gl.createSampler();
                        gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, gx_render_4.translateTexFilter(gl, sampler.minFilter));
                        gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, gx_render_4.translateTexFilter(gl, sampler.magFilter));
                        gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, gx_render_4.translateWrapMode(gl, sampler.wrapS));
                        gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, gx_render_4.translateWrapMode(gl, sampler.wrapT));
                        this.glSamplers[i] = glSampler;
                    }
                };
                Command_Material.prototype.calcPostTexMtx = function (dst, texIdx, state, flipY) {
                    var texMtxIdx = BRRES.TexMtxIndex.TEX0 + texIdx;
                    var texSrt = this.material.texSrts[texIdx];
                    var flipYScale = flipY ? -1.0 : 1.0;
                    if (texSrt.mapMode === 2 /* PROJECTION */) {
                        Camera_12.texProjPerspMtx(dst, state.fov, state.getAspect(), 0.5, -0.5 * flipYScale, 0.5, 0.5);
                        // XXX(jstpierre): ZSS hack. Reference camera 31 is set up by the game to be an overhead
                        // camera for clouds. Kill it until we can emulate the camera system in this game...
                        if (texSrt.refCamera === 31) {
                            dst[0] = 0;
                            dst[5] = 0;
                        }
                    }
                    else if (texSrt.mapMode === 1 /* ENV_CAMERA */) {
                        Camera_12.texEnvMtx(dst, 0.5, -0.5 * flipYScale, 0.5, 0.5);
                    }
                    else {
                        gl_matrix_19.mat4.identity(dst);
                    }
                    // Apply effect matrix.
                    gl_matrix_19.mat4.mul(dst, texSrt.effectMtx, dst);
                    // Calculate SRT.
                    if (this.srt0Animators[texMtxIdx]) {
                        this.srt0Animators[texMtxIdx].calcTexMtx(matrixScratch);
                    }
                    else {
                        gl_matrix_19.mat4.copy(matrixScratch, texSrt.srtMtx);
                    }
                    // SRT matrices have translation in fourth component, but we want our matrix to have translation
                    // in third component. Swap.
                    var tx = matrixScratch[12];
                    matrixScratch[12] = matrixScratch[8];
                    matrixScratch[8] = tx;
                    var ty = matrixScratch[13];
                    matrixScratch[13] = matrixScratch[9];
                    matrixScratch[9] = ty;
                    gl_matrix_19.mat4.mul(dst, matrixScratch, dst);
                };
                Command_Material.prototype.calcIndMtx = function (dst, indIdx) {
                    var texMtxIdx = BRRES.TexMtxIndex.IND0 + indIdx;
                    if (this.srt0Animators[texMtxIdx]) {
                        this.srt0Animators[texMtxIdx].calcIndTexMtx(dst);
                    }
                    else {
                        gl_matrix_19.mat2d.copy(dst, this.material.indTexMatrices[indIdx]);
                    }
                };
                Command_Material.prototype.fillMaterialParams = function (materialParams, state) {
                    var _this = this;
                    for (var i = 0; i < 8; i++) {
                        var sampler = this.material.samplers[i];
                        if (!sampler)
                            continue;
                        var m = materialParams.m_TextureMapping[i];
                        if (this.pat0Animators[i]) {
                            this.pat0Animators[i].calcTextureMapping(m, this.textureHolder);
                        }
                        else {
                            this.textureHolder.fillTextureMapping(m, sampler.name);
                        }
                        // Fill in sampler state.
                        m.glSampler = this.glSamplers[i];
                        m.lodBias = sampler.lodBias;
                    }
                    var calcColor = function (dst, fallbackColor, i, a) {
                        var color;
                        if (_this.model.colorOverrides[i]) {
                            color = _this.model.colorOverrides[i];
                        }
                        else {
                            color = fallbackColor;
                        }
                        if (_this.clr0Animators[a]) {
                            _this.clr0Animators[a].calcColor(dst, color);
                        }
                        else {
                            dst.copy(color);
                        }
                    };
                    calcColor(materialParams.u_ColorMatReg[0], this.material.colorMatRegs[0], render_31.ColorOverride.MAT0, BRRES.AnimatableColor.MAT0);
                    calcColor(materialParams.u_ColorMatReg[1], this.material.colorMatRegs[1], render_31.ColorOverride.MAT1, BRRES.AnimatableColor.MAT1);
                    calcColor(materialParams.u_ColorAmbReg[0], this.material.colorAmbRegs[0], render_31.ColorOverride.AMB0, BRRES.AnimatableColor.AMB0);
                    calcColor(materialParams.u_ColorAmbReg[1], this.material.colorAmbRegs[1], render_31.ColorOverride.AMB1, BRRES.AnimatableColor.AMB1);
                    calcColor(materialParams.u_KonstColor[0], this.material.gxMaterial.colorConstants[0], render_31.ColorOverride.K0, BRRES.AnimatableColor.K0);
                    calcColor(materialParams.u_KonstColor[1], this.material.gxMaterial.colorConstants[1], render_31.ColorOverride.K1, BRRES.AnimatableColor.K1);
                    calcColor(materialParams.u_KonstColor[2], this.material.gxMaterial.colorConstants[2], render_31.ColorOverride.K2, BRRES.AnimatableColor.K2);
                    calcColor(materialParams.u_KonstColor[3], this.material.gxMaterial.colorConstants[3], render_31.ColorOverride.K3, BRRES.AnimatableColor.K3);
                    calcColor(materialParams.u_Color[0], this.material.gxMaterial.colorRegisters[0], render_31.ColorOverride.CPREV, -1);
                    calcColor(materialParams.u_Color[1], this.material.gxMaterial.colorRegisters[1], render_31.ColorOverride.C0, BRRES.AnimatableColor.C0);
                    calcColor(materialParams.u_Color[2], this.material.gxMaterial.colorRegisters[2], render_31.ColorOverride.C1, BRRES.AnimatableColor.C1);
                    calcColor(materialParams.u_Color[3], this.material.gxMaterial.colorRegisters[3], render_31.ColorOverride.C2, BRRES.AnimatableColor.C2);
                    for (var i = 0; i < 8; i++)
                        this.calcPostTexMtx(materialParams.u_PostTexMtx[i], i, state, materialParams.m_TextureMapping[i].flipY);
                    for (var i = 0; i < 3; i++)
                        this.calcIndMtx(materialParams.u_IndTexMtx[i], i);
                };
                Command_Material.prototype.exec = function (state, renderHelper) {
                    var gl = state.gl;
                    state.useProgram(this.program);
                    state.useFlags(this.renderFlags);
                    this.fillMaterialParams(this.materialParams, state);
                    renderHelper.bindMaterialParams(state, this.materialParams);
                    renderHelper.bindMaterialTextures(state, this.materialParams, this.program);
                };
                Command_Material.prototype.destroy = function (gl) {
                    this.program.destroy(gl);
                    this.glSamplers.forEach(function (sampler) { return gl.deleteSampler(sampler); });
                };
                return Command_Material;
            }());
        }
    };
});
// Parses NintendoWare BRRES (Binary Revolution RESource) files.
// http://wiki.tockdom.com/wiki/BRRES
System.register("rres/brres", ["util", "gx/gx_material", "gx/gx_displaylist", "gl-matrix", "Camera"], function (exports_80, context_80) {
    "use strict";
    var __moduleName = context_80 && context_80.id;
    //#region Utility
    function calc2dMtx(dst, src) {
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[4];
        dst[3] = src[5];
        dst[4] = src[12];
        dst[5] = src[13];
    }
    function calcTexMtx_Basic(dst, scaleS, scaleT, rotation, translationS, translationT) {
        var theta = Math.PI / 180 * rotation;
        var sinR = Math.sin(theta);
        var cosR = Math.cos(theta);
        gl_matrix_20.mat4.identity(dst);
        dst[0] = scaleS * cosR;
        dst[4] = scaleT * -sinR;
        dst[12] = translationS;
        dst[1] = scaleS * sinR;
        dst[5] = scaleT * cosR;
        dst[13] = translationT;
    }
    function calcTexMtx_Maya(dst, scaleS, scaleT, rotation, translationS, translationT) {
        var theta = Math.PI / 180 * rotation;
        var sinR = Math.sin(theta);
        var cosR = Math.cos(theta);
        gl_matrix_20.mat4.identity(dst);
        dst[0] = scaleS * cosR;
        dst[4] = scaleS * sinR;
        dst[12] = scaleS * ((-0.5 * cosR) - (0.5 * sinR - 0.5) - translationS);
        dst[1] = scaleT * -sinR;
        dst[5] = scaleT * cosR;
        dst[13] = scaleT * ((-0.5 * cosR) + (0.5 * sinR - 0.5) + translationT) + 1;
    }
    function calcTexMtx_Max(dst, scaleS, scaleT, rotation, translationS, translationT) {
        var theta = Math.PI / 180 * rotation;
        var sinR = Math.sin(theta);
        var cosR = Math.cos(theta);
        gl_matrix_20.mat4.identity(dst);
        dst[0] = scaleS * cosR;
        dst[4] = scaleS * sinR;
        dst[12] = (scaleS * -cosR * (translationS + 0.5)) + (scaleS * sinR * (translationT - 0.5)) + 0.5;
        dst[1] = scaleT * -sinR;
        dst[5] = scaleT * cosR;
        dst[13] = (scaleT * sinR * (translationS + 0.5)) + (scaleT * cosR * (translationT - 0.5)) + 0.5;
    }
    function calcTexMtx(dst, texMtxMode, scaleS, scaleT, rotation, translationS, translationT) {
        switch (texMtxMode) {
            case -1 /* BASIC */:
                return calcTexMtx_Basic(dst, scaleS, scaleT, rotation, translationS, translationT);
            case 0 /* MAYA */:
                return calcTexMtx_Maya(dst, scaleS, scaleT, rotation, translationS, translationT);
            case 2 /* MAX */:
                return calcTexMtx_Max(dst, scaleS, scaleT, rotation, translationS, translationT);
            default:
                throw "whoops";
        }
    }
    function calcModelMtx(dst, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ, translationX, translationY, translationZ) {
        var rX = Math.PI / 180 * rotationX;
        var rY = Math.PI / 180 * rotationY;
        var rZ = Math.PI / 180 * rotationZ;
        var sinX = Math.sin(rX), cosX = Math.cos(rX);
        var sinY = Math.sin(rY), cosY = Math.cos(rY);
        var sinZ = Math.sin(rZ), cosZ = Math.cos(rZ);
        dst[0] = scaleX * (cosY * cosZ);
        dst[1] = scaleX * (sinZ * cosY);
        dst[2] = scaleX * (-sinY);
        dst[3] = 0.0;
        dst[4] = scaleY * (sinX * cosZ * sinY - cosX * sinZ);
        dst[5] = scaleY * (sinX * sinZ * sinY + cosX * cosZ);
        dst[6] = scaleY * (sinX * cosY);
        dst[7] = 0.0;
        dst[8] = scaleZ * (cosX * cosZ * sinY + sinX * sinZ);
        dst[9] = scaleZ * (cosX * sinZ * sinY - sinX * cosZ);
        dst[10] = scaleZ * (cosY * cosX);
        dst[11] = 0.0;
        dst[12] = translationX;
        dst[13] = translationY;
        dst[14] = translationZ;
        dst[15] = 1.0;
    }
    function parseResDic(buffer, tableOffs) {
        if (tableOffs === 0)
            return [];
        var view = buffer.createDataView();
        var tableSize = view.getUint32(tableOffs + 0x00);
        var tableCount = view.getUint32(tableOffs + 0x04);
        var entries = [];
        var tableIdx = tableOffs + 0x08;
        // Skip root entry.
        tableIdx += 0x10;
        for (var i = 0; i < tableCount; i++) {
            // There's a fancy search tree in here which I don't care about at all...
            var name_15 = util_50.readString(buffer, tableOffs + view.getUint32(tableIdx + 0x08));
            var offs = tableOffs + view.getUint32(tableIdx + 0x0C);
            entries.push({ name: name_15, offs: offs });
            tableIdx += 0x10;
        }
        return entries;
    }
    function parseTEX0(buffer) {
        var view = buffer.createDataView();
        util_50.assert(util_50.readString(buffer, 0x00, 0x04) === 'TEX0');
        var version = view.getUint32(0x08);
        var supportedVersions = [0x01, 0x03];
        util_50.assert(supportedVersions.includes(version));
        var dataOffs = view.getUint32(0x10);
        var nameOffs = view.getUint32(0x14);
        var name = util_50.readString(buffer, nameOffs);
        var flags = view.getUint32(0x18);
        var width = view.getUint16(0x1C);
        var height = view.getUint16(0x1E);
        var format = view.getUint32(0x20);
        var mipCount = view.getUint32(0x24);
        var minLOD = view.getFloat32(0x28) * 1 / 8;
        var maxLOD = view.getFloat32(0x2C) * 1 / 8;
        var data = buffer.subarray(dataOffs);
        return { name: name, width: width, height: height, format: format, mipCount: mipCount, minLOD: minLOD, maxLOD: maxLOD, data: data };
    }
    // TODO(jstpierre): Move this to gx_displaylist.ts
    function runDisplayListRegisters(r, buffer) {
        var view = buffer.createDataView();
        for (var i = 0; i < buffer.byteLength;) {
            var cmd = view.getUint8(i++);
            switch (cmd) {
                case 0 /* NOOP */:
                    continue;
                case 97 /* LOAD_BP_REG */: {
                    var regBag = view.getUint32(i);
                    i += 4;
                    r.bps(regBag);
                    break;
                }
                case 8 /* LOAD_CP_REG */: {
                    var regAddr = view.getUint8(i);
                    i++;
                    var regValue = view.getUint32(i);
                    i += 4;
                    r.cp[regAddr] = regValue;
                    break;
                }
                case 16 /* LOAD_XF_REG */: {
                    var len = view.getUint16(i) + 1;
                    i += 2;
                    util_50.assert(len <= 0x10);
                    var regAddr = view.getUint16(i);
                    i += 2;
                    for (var j = 0; j < len; j++) {
                        r.xfs(regAddr, j, view.getUint32(i));
                        i += 4;
                    }
                    // Clear out the other values.
                    for (var j = len; j < 16; j++) {
                        r.xfs(regAddr, j, 0);
                    }
                    break;
                }
                default:
                    console.error("Unknown command " + cmd + " at " + i + " (buffer: 0x" + buffer.byteOffset.toString(16) + ")");
                    throw "whoops 1";
            }
        }
    }
    function findTevOp(bias, scale, sub) {
        if (bias === 3 /* $HWB_COMPARE */) {
            switch (scale) {
                case 0 /* $HWB_R8 */: return sub ? 9 /* COMP_R8_EQ */ : 8 /* COMP_R8_GT */;
                case 1 /* $HWB_GR16 */: return sub ? 11 /* COMP_GR16_EQ */ : 10 /* COMP_GR16_GT */;
                case 2 /* $HWB_BGR24 */: return sub ? 13 /* COMP_BGR24_EQ */ : 12 /* COMP_BGR24_GT */;
                case 3 /* $HWB_RGB8 */: return sub ? 15 /* COMP_RGB8_EQ */ : 14 /* COMP_RGB8_GT */;
                default:
                    throw "whoops 2";
            }
        }
        else {
            return sub ? 1 /* SUB */ : 0 /* ADD */;
        }
    }
    function parseMDL0_TevEntry(buffer, r, numStagesCheck) {
        var view = buffer.createDataView();
        var size = view.getUint32(0x00);
        util_50.assert(size === 480 + 32);
        var index = view.getUint32(0x08);
        var numStages = view.getUint8(0x0C);
        util_50.assert(numStages === numStagesCheck);
        var dlOffs = 0x20;
        runDisplayListRegisters(r, buffer.subarray(dlOffs, 480));
    }
    function parseMDL0_MaterialEntry(buffer, version) {
        var view = buffer.createDataView();
        var size = view.getUint32(0x00);
        var nameOffs = view.getUint32(0x08);
        var name = util_50.readString(buffer, nameOffs);
        var index = view.getUint32(0x0C);
        var flags = view.getUint32(0x10);
        var translucent = !!(flags & 0x80000000);
        // genMode
        var numTexGens = view.getUint8(0x14);
        var numChans = view.getUint8(0x15);
        var numTevs = view.getUint8(0x16);
        var numInds = view.getUint8(0x17);
        var cullMode = view.getUint32(0x18);
        // matMisc
        var zCompLoc = !!view.getUint8(0x1C);
        var lightset = view.getInt8(0x1D);
        var fogset = view.getInt8(0x1E);
        // pad
        var indMethod0 = view.getUint8(0x20);
        var indMethod1 = view.getUint8(0x21);
        var indMethod2 = view.getUint8(0x22);
        var indMethod3 = view.getUint8(0x23);
        var nrmRefLight0 = view.getUint8(0x24);
        var nrmRefLight1 = view.getUint8(0x25);
        var nrmRefLight2 = view.getUint8(0x26);
        var nrmRefLight3 = view.getUint8(0x27);
        var tevOffs = view.getUint32(0x28);
        util_50.assert(numTevs <= 16);
        var numTexPltt = view.getUint32(0x2C);
        var texPlttOffs = view.getUint32(0x30);
        var endOfHeaderOffs = 0x34;
        if (version >= 0x0A) {
            endOfHeaderOffs += 0x04; // Fur
        }
        endOfHeaderOffs += 0x04; // user data
        // Run the mat DLs.
        var r = new DisplayListRegisters();
        var matDLOffs = view.getUint32(endOfHeaderOffs);
        var matDLSize = 32 + 128 + 64 + 160;
        runDisplayListRegisters(r, buffer.subarray(matDLOffs, matDLSize));
        // Run the TEV registers as well.
        parseMDL0_TevEntry(buffer.subarray(tevOffs), r, numTevs);
        // Now combine the whole thing.
        // TexGens.
        var texGens = [];
        for (var i = 0; i < numTexGens; i++) {
            var v = r.xfg(4160 /* XF_TEX0_ID */ + i);
            var proj = (v >>> 1) & 0x01;
            var form = (v >>> 2) & 0x01;
            var tgType = (v >>> 4) & 0x02;
            var src = (v >>> 7) & 0x0F;
            var embossSrc = (v >>> 12) & 0x07;
            var embossLgt = (v >>> 15) & 0x07;
            var texGenType = void 0;
            var texGenSrc = void 0;
            if (tgType === 0 /* REGULAR */) {
                var srcLookup = [
                    0 /* POS */,
                    1 /* NRM */,
                    19 /* COLOR0 */,
                    2 /* BINRM */,
                    3 /* TANGENT */,
                    4 /* TEX0 */,
                    5 /* TEX1 */,
                    6 /* TEX2 */,
                    7 /* TEX3 */,
                    8 /* TEX4 */,
                    9 /* TEX5 */,
                    10 /* TEX6 */,
                    11 /* TEX7 */,
                ];
                texGenType = proj === 0 /* ST */ ? 1 /* MTX2x4 */ : 0 /* MTX3x4 */;
                texGenSrc = srcLookup[src];
            }
            else if (tgType === 1 /* EMBOSS_MAP */) {
                texGenType = 2 /* BUMP0 */ + embossLgt;
                texGenSrc = 12 /* TEXCOORD0 */ + embossSrc;
            }
            else if (tgType === 2 /* COLOR_STRGBC0 */) {
                texGenType = 10 /* SRTG */;
                texGenSrc = 19 /* COLOR0 */;
            }
            else if (tgType === 2 /* COLOR_STRGBC1 */) {
                texGenType = 10 /* SRTG */;
                texGenSrc = 20 /* COLOR1 */;
            }
            // TODO(jstpierre): Figure out texgen matrices. Seems like in most cases BRRES
            // only supports postmtx.
            var matrix = 60 /* IDENTITY */;
            var dv = r.xfg(4176 /* XF_DUALTEX0_ID */ + i);
            var postMatrix = ((dv >>> 0) & 0xFF) + 64 /* PTTEXMTX0 */;
            var normalize = !!((dv >>> 8) & 0x01);
            texGens.push({ index: i, type: texGenType, source: texGenSrc, matrix: matrix, normalize: normalize, postMatrix: postMatrix });
        }
        // TEV stages.
        var tevStages = [];
        var tevOrders = [];
        // First up, parse RAS1_TREF into tev orders.
        for (var i = 0; i < 8; i++) {
            var v = r.bp[40 /* RAS1_TREF_0_ID */ + i];
            var ti0 = (v >>> 0) & 0x07;
            var tc0 = (v >>> 3) & 0x07;
            var te0 = !!((v >>> 6) & 0x01);
            var cc0 = (v >>> 7) & 0x07;
            // 7-10 = pad
            var ti1 = (v >>> 12) & 0x07;
            var tc1 = (v >>> 15) & 0x07;
            var te1 = !!((v >>> 18) & 0x01);
            var cc1 = (v >>> 19) & 0x07;
            if (i * 2 + 0 >= numTevs)
                break;
            var order0 = {
                texMapId: te0 ? ti0 : 255 /* TEXMAP_NULL */,
                texCoordId: tc0,
                channelId: cc0,
            };
            tevOrders.push(order0);
            if (i * 2 + 1 >= numTevs)
                break;
            var order1 = {
                texMapId: te1 ? ti1 : 255 /* TEXMAP_NULL */,
                texCoordId: tc1,
                channelId: cc1,
            };
            tevOrders.push(order1);
        }
        util_50.assert(tevOrders.length === numTevs);
        // Now parse out individual stages.
        for (var i = 0; i < tevOrders.length; i++) {
            var color = r.bp[192 /* TEV_COLOR_ENV_0_ID */ + (i * 2)];
            var colorInD = (color >>> 0) & 0x0F;
            var colorInC = (color >>> 4) & 0x0F;
            var colorInB = (color >>> 8) & 0x0F;
            var colorInA = (color >>> 12) & 0x0F;
            var colorBias = (color >>> 16) & 0x03;
            var colorSub = !!((color >>> 18) & 0x01);
            var colorClamp = !!((color >>> 19) & 0x01);
            var colorScale = (color >>> 20) & 0x03;
            var colorRegId = (color >>> 22) & 0x03;
            var colorOp = findTevOp(colorBias, colorScale, colorSub);
            // Find the op.
            var alpha = r.bp[193 /* TEV_ALPHA_ENV_0_ID */ + (i * 2)];
            // TODO(jstpierre): swap table
            var alphaInD = (alpha >>> 4) & 0x07;
            var alphaInC = (alpha >>> 7) & 0x07;
            var alphaInB = (alpha >>> 10) & 0x07;
            var alphaInA = (alpha >>> 13) & 0x07;
            var alphaBias = (alpha >>> 16) & 0x03;
            var alphaSub = !!((alpha >>> 18) & 0x01);
            var alphaClamp = !!((alpha >>> 19) & 0x01);
            var alphaScale = (alpha >>> 20) & 0x03;
            var alphaRegId = (alpha >>> 22) & 0x03;
            var alphaOp = findTevOp(alphaBias, alphaScale, alphaSub);
            var ksel = r.bp[246 /* TEV_KSEL_0_ID */ + (i >>> 1)];
            var konstColorSel = ((i & 1) ? (ksel >>> 14) : (ksel >>> 4)) & 0x1F;
            var konstAlphaSel = ((i & 1) ? (ksel >>> 19) : (ksel >>> 9)) & 0x1F;
            var indCmd = r.bp[16 /* IND_CMD0_ID */ + i];
            var indTexStage = (indCmd >>> 0) & 0x03;
            var indTexFormat = (indCmd >>> 2) & 0x03;
            var indTexBiasSel = (indCmd >>> 4) & 0x03;
            // alpha sel
            var indTexMatrix = (indCmd >>> 9) & 0x0F;
            var indTexWrapS = (indCmd >>> 13) & 0x07;
            var indTexWrapT = (indCmd >>> 16) & 0x07;
            var indTexUseOrigLOD = !!((indCmd >>> 19) & 0x01);
            var indTexAddPrev = !!((indCmd >>> 20) & 0x01);
            var tevStage = {
                index: i,
                colorInA: colorInA, colorInB: colorInB, colorInC: colorInC, colorInD: colorInD, colorOp: colorOp, colorBias: colorBias, colorClamp: colorClamp, colorScale: colorScale, colorRegId: colorRegId,
                alphaInA: alphaInA, alphaInB: alphaInB, alphaInC: alphaInC, alphaInD: alphaInD, alphaOp: alphaOp, alphaBias: alphaBias, alphaClamp: alphaClamp, alphaScale: alphaScale, alphaRegId: alphaRegId,
                texCoordId: tevOrders[i].texCoordId,
                texMap: tevOrders[i].texMapId,
                channelId: tevOrders[i].channelId,
                konstColorSel: konstColorSel, konstAlphaSel: konstAlphaSel,
                indTexStage: indTexStage, indTexFormat: indTexFormat, indTexBiasSel: indTexBiasSel, indTexMatrix: indTexMatrix, indTexWrapS: indTexWrapS, indTexWrapT: indTexWrapT, indTexAddPrev: indTexAddPrev, indTexUseOrigLOD: indTexUseOrigLOD,
            };
            tevStages.push(tevStage);
        }
        // Colors.
        var colorRegisters = [];
        var colorConstants = [];
        for (var i = 0; i < 8; i++) {
            var vl = r.kc[i * 2 + 0];
            var vh = r.kc[i * 2 + 1];
            var cr = ((vl >>> 0) & 0x7FF) / 0xFF;
            var ca = ((vl >>> 12) & 0x7FF) / 0xFF;
            var cb = ((vh >>> 0) & 0x7FF) / 0xFF;
            var cg = ((vh >>> 12) & 0x7FF) / 0xFF;
            var c = new GX_Material.Color(cr, cg, cb, ca);
            if (i < 4)
                colorRegisters[i] = c;
            else
                colorConstants[i - 4] = c;
        }
        // Alpha test.
        var ap = r.bp[243 /* TEV_ALPHAFUNC_ID */];
        var alphaTest = {
            referenceA: ((ap >>> 0) & 0xFF) / 0xFF,
            referenceB: ((ap >>> 8) & 0xFF) / 0xFF,
            compareA: (ap >>> 16) & 0x07,
            compareB: (ap >>> 19) & 0x07,
            op: (ap >>> 22) & 0x07,
        };
        var cm0 = r.bp[65 /* PE_CMODE0_ID */];
        var bmboe = (cm0 >>> 0) & 0x01;
        var bmloe = (cm0 >>> 1) & 0x01;
        var bmbop = (cm0 >>> 11) & 0x01;
        var blendType = bmboe ? (bmbop ? 3 /* SUBTRACT */ : 1 /* BLEND */) :
            bmloe ? 2 /* LOGIC */ : 0 /* NONE */;
        ;
        var dstFactor = (cm0 >>> 5) & 0x07;
        var srcFactor = (cm0 >>> 8) & 0x07;
        var logicOp = (cm0 >>> 12) & 0x0F;
        var blendMode = {
            type: blendType,
            dstFactor: dstFactor, srcFactor: srcFactor, logicOp: logicOp,
        };
        var zm = r.bp[64 /* PE_ZMODE_ID */];
        var depthTest = !!((zm >>> 0) & 0x01);
        var depthFunc = (zm >>> 1) & 0x07;
        var depthWrite = !!((zm >>> 4) & 0x01);
        var ropInfo = {
            blendMode: blendMode, depthFunc: depthFunc, depthTest: depthTest, depthWrite: depthWrite,
        };
        var indTexStages = [];
        var iref = r.bp[39 /* RAS1_IREF_ID */];
        for (var i = 0; i < numInds; i++) {
            var index_6 = i;
            var ss = r.bp[37 /* RAS1_SS0_ID */ + (index_6 >>> 2)];
            var scaleS = (ss >>> ((0x08 * (i & 1)) + 0x00) & 0x0F);
            var scaleT = (ss >>> ((0x08 * (i & 1)) + 0x04) & 0x0F);
            var texture = (iref >>> (0x06 * i)) & 0x07;
            var texCoordId = (iref >>> (0x06 * i)) & 0x07;
            indTexStages.push({ index: index_6, scaleS: scaleS, scaleT: scaleT, texCoordId: texCoordId, texture: texture });
        }
        var indTexMatrices = [];
        for (var i = 0; i < 3; i++) {
            var indTexScaleBase = 10;
            var indTexScaleBias = 0x11;
            var indOffs = i * 3;
            var mtxA = r.bp[6 /* IND_MTXA0_ID */ + indOffs];
            var mtxB = r.bp[7 /* IND_MTXB0_ID */ + indOffs];
            var mtxC = r.bp[8 /* IND_MTXC0_ID */ + indOffs];
            var scaleBitsA = (mtxA >>> 22) & 0x03;
            var scaleBitsB = (mtxB >>> 22) & 0x03;
            var scaleBitsC = (mtxC >>> 22) & 0x03;
            var scaleExp = (scaleBitsC << 4) | (scaleBitsB << 2) | scaleBitsA;
            var scale = Math.pow(2, scaleExp - indTexScaleBias - indTexScaleBase);
            var ma = ((((mtxA >>> 0) & 0x07FF) << 21) >> 21) * scale;
            var mc = ((((mtxA >>> 11) & 0x07FF) << 21) >> 21) * scale;
            var mx = ((((mtxB >>> 0) & 0x07FF) << 21) >> 21) * scale;
            var mb = ((((mtxB >>> 11) & 0x07FF) << 21) >> 21) * scale;
            var md = ((((mtxC >>> 0) & 0x07FF) << 21) >> 21) * scale;
            var my = ((((mtxC >>> 11) & 0x07FF) << 21) >> 21) * scale;
            var mat = gl_matrix_20.mat2d.fromValues(ma, mb, mc, md, mx, my);
            indTexMatrices.push(mat);
        }
        // Samplers
        var samplers = [];
        for (var i = 0; i < numTexPltt; i++) {
            var texPlttInfoOffs = texPlttOffs + i * 0x34;
            var nameTexOffs = view.getUint32(texPlttInfoOffs + 0x00);
            var namePltOffs = view.getUint32(texPlttInfoOffs + 0x04);
            // unk
            // unk
            var texMapId = view.getUint32(texPlttInfoOffs + 0x10);
            var tlutId = view.getUint32(texPlttInfoOffs + 0x14);
            var wrapS = view.getUint32(texPlttInfoOffs + 0x18);
            var wrapT = view.getUint32(texPlttInfoOffs + 0x1C);
            var minFilter = view.getUint32(texPlttInfoOffs + 0x20);
            var magFilter = view.getUint32(texPlttInfoOffs + 0x24);
            var lodBias = view.getFloat32(texPlttInfoOffs + 0x28) * 1 / 8;
            var maxAniso = view.getUint32(texPlttInfoOffs + 0x2C);
            var biasClamp = view.getUint8(texPlttInfoOffs + 0x30);
            var edgeLod = view.getUint8(texPlttInfoOffs + 0x31);
            var name_16 = util_50.readString(buffer, texPlttInfoOffs + nameTexOffs);
            var namePalette = (namePltOffs !== 0) ? util_50.readString(buffer, texPlttInfoOffs + namePltOffs) : null;
            samplers[texMapId] = { name: name_16, namePalette: namePalette, lodBias: lodBias, wrapS: wrapS, wrapT: wrapT, minFilter: minFilter, magFilter: magFilter };
        }
        var srtFlags = view.getUint32(endOfHeaderOffs + 0x16C);
        var texMtxMode = view.getUint32(endOfHeaderOffs + 0x170);
        var texSrtTableIdx = endOfHeaderOffs + 0x174;
        var texMtxTableIdx = endOfHeaderOffs + 0x214;
        var texSrts = [];
        for (var i = 0; i < 8; i++) {
            // SRT
            var scaleS = view.getFloat32(texSrtTableIdx + 0x00);
            var scaleT = view.getFloat32(texSrtTableIdx + 0x04);
            var rotation = view.getFloat32(texSrtTableIdx + 0x08);
            var translationS = view.getFloat32(texSrtTableIdx + 0x0C);
            var translationT = view.getFloat32(texSrtTableIdx + 0x10);
            var refCamera = view.getInt8(texMtxTableIdx + 0x00);
            var refLight = view.getInt8(texMtxTableIdx + 0x01);
            var mapMode = view.getInt8(texMtxTableIdx + 0x02);
            var miscFlags = view.getInt8(texMtxTableIdx + 0x03);
            var m00 = view.getFloat32(texMtxTableIdx + 0x04);
            var m01 = view.getFloat32(texMtxTableIdx + 0x08);
            var m02 = view.getFloat32(texMtxTableIdx + 0x0C);
            var m03 = view.getFloat32(texMtxTableIdx + 0x10);
            var m10 = view.getFloat32(texMtxTableIdx + 0x14);
            var m11 = view.getFloat32(texMtxTableIdx + 0x18);
            var m12 = view.getFloat32(texMtxTableIdx + 0x1C);
            var m13 = view.getFloat32(texMtxTableIdx + 0x20);
            var m20 = view.getFloat32(texMtxTableIdx + 0x24);
            var m21 = view.getFloat32(texMtxTableIdx + 0x28);
            var m22 = view.getFloat32(texMtxTableIdx + 0x2C);
            var m23 = view.getFloat32(texMtxTableIdx + 0x30);
            var effectMtx = gl_matrix_20.mat4.fromValues(m00, m10, m20, 0, m01, m11, m21, 0, m02, m12, m22, 0, m03, m13, m23, 1);
            switch (mapMode) {
                case 0 /* TEXCOORD */:
                    // No matrix needed.
                    break;
                case 2 /* PROJECTION */:
                case 1 /* ENV_CAMERA */:
                case 3 /* ENV_LIGHT */:
                    // Use the PNMTX0 matrix for projection and environment.
                    // TODO(jstpierre): normal matrix for env camera / light.
                    texGens[i].matrix = 0 /* PNMTX0 */;
                    break;
            }
            var srtMtx = gl_matrix_20.mat4.create();
            calcTexMtx(srtMtx, texMtxMode, scaleS, scaleT, rotation, translationS, translationT);
            var texSrt = { refCamera: refCamera, refLight: refLight, mapMode: mapMode, srtMtx: srtMtx, effectMtx: effectMtx };
            texSrts.push(texSrt);
            texSrtTableIdx += 0x14;
            texMtxTableIdx += 0x34;
        }
        var lightChannels = [];
        var colorMatRegs = [];
        var colorAmbRegs = [];
        var lightChannelTableIdx = endOfHeaderOffs + 0x3B4;
        for (var i = 0; i < 2; i++) {
            var flags_2 = view.getUint32(lightChannelTableIdx + 0x00);
            var matColorR = view.getUint8(lightChannelTableIdx + 0x04) / 0xFF;
            var matColorG = view.getUint8(lightChannelTableIdx + 0x05) / 0xFF;
            var matColorB = view.getUint8(lightChannelTableIdx + 0x06) / 0xFF;
            var matColorA = view.getUint8(lightChannelTableIdx + 0x07) / 0xFF;
            var ambColorR = view.getUint8(lightChannelTableIdx + 0x08) / 0xFF;
            var ambColorG = view.getUint8(lightChannelTableIdx + 0x09) / 0xFF;
            var ambColorB = view.getUint8(lightChannelTableIdx + 0x0A) / 0xFF;
            var ambColorA = view.getUint8(lightChannelTableIdx + 0x0B) / 0xFF;
            var chanCtrlC = view.getUint32(lightChannelTableIdx + 0x0C);
            var chanCtrlA = view.getUint32(lightChannelTableIdx + 0x10);
            var chanCtrlCMatSrc = (chanCtrlC >>> 0) & 0x01;
            var chanCtrlCEnable = !!((chanCtrlC >>> 1) & 0x01);
            var chanCtrlCAmbSrc = (chanCtrlC >>> 6) & 0x01;
            var colorChannel = { lightingEnabled: chanCtrlCEnable, matColorSource: chanCtrlCMatSrc, ambColorSource: chanCtrlCAmbSrc };
            var chanCtrlAMatSrc = (chanCtrlA >>> 0) & 0x01;
            var chanCtrlAEnable = !!((chanCtrlA >>> 1) & 0x01);
            var chanCtrlAAmbSrc = (chanCtrlA >>> 6) & 0x01;
            var alphaChannel = { lightingEnabled: chanCtrlAEnable, matColorSource: chanCtrlAMatSrc, ambColorSource: chanCtrlAAmbSrc };
            colorMatRegs.push(new GX_Material.Color(matColorR, matColorG, matColorB, matColorA));
            colorAmbRegs.push(new GX_Material.Color(ambColorR, ambColorG, ambColorB, ambColorA));
            lightChannels.push({ colorChannel: colorChannel, alphaChannel: alphaChannel });
            lightChannelTableIdx += 0x14;
        }
        var gxMaterial = {
            index: index, name: name,
            lightChannels: lightChannels, cullMode: cullMode,
            tevStages: tevStages, texGens: texGens,
            colorRegisters: colorRegisters, colorConstants: colorConstants,
            indTexStages: indTexStages, alphaTest: alphaTest, ropInfo: ropInfo,
        };
        return { index: index, name: name, translucent: translucent, gxMaterial: gxMaterial, samplers: samplers, texSrts: texSrts, indTexMatrices: indTexMatrices, colorMatRegs: colorMatRegs, colorAmbRegs: colorAmbRegs };
    }
    function parseMDL0_VtxData(buffer, vtxAttrib) {
        var view = buffer.createDataView();
        var dataOffs = view.getUint32(0x08);
        var nameOffs = view.getUint32(0x0C);
        var name = util_50.readString(buffer, nameOffs);
        var id = view.getUint32(0x10);
        var compCnt = view.getUint32(0x14);
        var compType = view.getUint32(0x18);
        var compShift = view.getUint8(0x1C);
        var stride = view.getUint8(0x1D);
        var count = view.getUint16(0x1E);
        // Color attributes don't have shift -- they store stride in the shift field.
        if (vtxAttrib === 11 /* CLR0 */) {
            stride = compShift;
            compShift = 0;
        }
        var numComponents = gx_displaylist_4.getComponentCountRaw(vtxAttrib, compCnt);
        var compSize = gx_displaylist_4.getComponentSizeRaw(compType);
        var compByteSize = numComponents * compSize;
        var dataByteSize = compByteSize * count;
        var data = buffer.subarray(dataOffs, dataByteSize);
        return { name: name, id: id, compCnt: compCnt, compType: compType, compShift: compShift, stride: stride, count: count, data: data };
    }
    function parseInputBufferSet(buffer, vtxAttrib, resDic) {
        var vtxBuffers = [];
        for (var i = 0; i < resDic.length; i++) {
            var entry = resDic[i];
            var vtxBufferData = parseMDL0_VtxData(buffer.subarray(entry.offs), vtxAttrib);
            util_50.assert(vtxBufferData.name === entry.name);
            util_50.assert(vtxBufferData.id === i);
            vtxBuffers.push(vtxBufferData);
        }
        return vtxBuffers;
    }
    function parseInputVertexBuffers(buffer, vtxPosResDic, vtxNrmResDic, vtxClrResDic, vtxTxcResDic) {
        var pos = parseInputBufferSet(buffer, 9 /* POS */, vtxPosResDic);
        var nrm = parseInputBufferSet(buffer, 10 /* NRM */, vtxNrmResDic);
        var clr = parseInputBufferSet(buffer, 11 /* CLR0 */, vtxClrResDic);
        var txc = parseInputBufferSet(buffer, 13 /* TEX0 */, vtxTxcResDic);
        return { pos: pos, nrm: nrm, clr: clr, txc: txc };
    }
    function parseMDL0_ShapeEntry(buffer, inputBuffers) {
        var view = buffer.createDataView();
        var mtxIdx = view.getInt32(0x08);
        // These offsets are relative to the start of the structure.
        var prePrimDLSize = view.getUint32(0x18);
        var prePrimDLCmdSize = view.getUint32(0x1C);
        var prePrimDLOffs = 0x18 + view.getUint32(0x20);
        var primDLSize = view.getUint32(0x24);
        var primDLCmdSize = view.getUint32(0x28);
        var primDLOffs = 0x24 + view.getUint32(0x2C);
        var vcdFlags = view.getUint32(0x30);
        var flags = view.getUint32(0x34);
        var nameOffs = view.getUint32(0x38);
        var name = util_50.readString(buffer, nameOffs);
        var id = view.getUint32(0x3C);
        var numVertices = view.getUint32(0x40);
        var numPolygons = view.getUint32(0x44);
        var idVtxPos = view.getInt16(0x48);
        util_50.assert(idVtxPos >= 0);
        var idVtxNrm = view.getInt16(0x4A);
        var idVtxClr0 = view.getInt16(0x4C);
        var idVtxClr1 = view.getInt16(0x4E);
        var idVtxTxc0 = view.getInt16(0x50);
        var idVtxTxc1 = view.getInt16(0x52);
        var idVtxTxc2 = view.getInt16(0x54);
        var idVtxTxc3 = view.getInt16(0x56);
        var idVtxTxc4 = view.getInt16(0x58);
        var idVtxTxc5 = view.getInt16(0x5A);
        var idVtxTxc6 = view.getInt16(0x5C);
        var idVtxTxc7 = view.getInt16(0x5E);
        var idVtxFurVec = view.getInt16(0x60);
        var idVtxFurPos = view.getInt16(0x62);
        var mtxSetOffs = view.getUint32(0x64);
        // Run preprim. This should get us our VAT / VCD.
        var r = new DisplayListRegisters();
        runDisplayListRegisters(r, buffer.subarray(prePrimDLOffs, prePrimDLSize));
        // VCD. Describes primitive data.
        var vcdL = r.cp[80 /* VCD_LO_ID */];
        var vcdH = r.cp[96 /* VCD_HI_ID */];
        var vcd = [];
        vcd[0 /* PNMTXIDX */] = { type: (vcdL >>> 0) & 0x01 };
        vcd[1 /* TEX0MTXIDX */] = { type: (vcdL >>> 1) & 0x01 };
        vcd[2 /* TEX1MTXIDX */] = { type: (vcdL >>> 2) & 0x01 };
        vcd[3 /* TEX2MTXIDX */] = { type: (vcdL >>> 3) & 0x01 };
        vcd[4 /* TEX3MTXIDX */] = { type: (vcdL >>> 4) & 0x01 };
        vcd[5 /* TEX4MTXIDX */] = { type: (vcdL >>> 5) & 0x01 };
        vcd[6 /* TEX5MTXIDX */] = { type: (vcdL >>> 6) & 0x01 };
        vcd[7 /* TEX6MTXIDX */] = { type: (vcdL >>> 7) & 0x01 };
        vcd[8 /* TEX7MTXIDX */] = { type: (vcdL >>> 8) & 0x01 };
        vcd[9 /* POS */] = { type: (vcdL >>> 9) & 0x03 };
        vcd[10 /* NRM */] = { type: (vcdL >>> 11) & 0x03 };
        vcd[11 /* CLR0 */] = { type: (vcdL >>> 13) & 0x03 };
        vcd[12 /* CLR1 */] = { type: (vcdL >>> 15) & 0x03 };
        vcd[13 /* TEX0 */] = { type: (vcdH >>> 0) & 0x03 };
        vcd[14 /* TEX1 */] = { type: (vcdH >>> 2) & 0x03 };
        vcd[15 /* TEX2 */] = { type: (vcdH >>> 4) & 0x03 };
        vcd[16 /* TEX3 */] = { type: (vcdH >>> 6) & 0x03 };
        vcd[17 /* TEX4 */] = { type: (vcdH >>> 8) & 0x03 };
        vcd[18 /* TEX5 */] = { type: (vcdH >>> 10) & 0x03 };
        vcd[19 /* TEX6 */] = { type: (vcdH >>> 12) & 0x03 };
        vcd[20 /* TEX7 */] = { type: (vcdH >>> 14) & 0x03 };
        // Validate against our VCD flags.
        for (var attr = 0; attr <= 20 /* TEX7 */; attr++) {
            var vcdFlagsEnabled = !!(vcdFlags & (1 << attr));
            var vcdEnabled = !!(vcd[attr].type !== 0 /* NONE */);
            util_50.assert(vcdFlagsEnabled === vcdEnabled);
        }
        // VAT. Describes attribute formats.
        // BRRES always uses VTXFMT0.
        var vatA = r.cp[112 /* VAT_A_ID */ + 0 /* VTXFMT0 */];
        var vatB = r.cp[128 /* VAT_B_ID */ + 0 /* VTXFMT0 */];
        var vatC = r.cp[144 /* VAT_C_ID */ + 0 /* VTXFMT0 */];
        function vatFmt(compCnt, compType, compShift) {
            return { compCnt: compCnt, compType: compType, compShift: compShift };
        }
        var vat = [];
        //                                        compCnt               compType              compShift
        vat[9 /* POS */] = vatFmt((vatA >>> 0) & 0x01, (vatA >>> 1) & 0x07, (vatA >>> 4) & 0x1F);
        var nrm3 = !!(vatA >>> 31);
        var nrmCnt = nrm3 ? 2 /* NRM_NBT3 */ : (vatA >>> 9) & 0x01;
        vat[10 /* NRM */] = vatFmt(nrmCnt, (vatA >>> 10) & 0x07, 0);
        vat[11 /* CLR0 */] = vatFmt((vatA >>> 13) & 0x01, (vatA >>> 14) & 0x07, 0);
        vat[12 /* CLR1 */] = vatFmt((vatA >>> 17) & 0x01, (vatA >>> 18) & 0x07, 0);
        vat[13 /* TEX0 */] = vatFmt((vatA >>> 21) & 0x01, (vatA >>> 22) & 0x07, (vatA >>> 25) & 0x1F);
        vat[14 /* TEX1 */] = vatFmt((vatB >>> 0) & 0x01, (vatB >>> 1) & 0x07, (vatB >>> 4) & 0x1F);
        vat[15 /* TEX2 */] = vatFmt((vatB >>> 9) & 0x01, (vatB >>> 10) & 0x07, (vatB >>> 13) & 0x1F);
        vat[16 /* TEX3 */] = vatFmt((vatB >>> 18) & 0x01, (vatB >>> 19) & 0x07, (vatB >>> 22) & 0x1F);
        vat[17 /* TEX4 */] = vatFmt((vatB >>> 27) & 0x01, (vatB >>> 28) & 0x07, (vatC >>> 0) & 0x1F);
        vat[18 /* TEX5 */] = vatFmt((vatC >>> 5) & 0x01, (vatC >>> 6) & 0x07, (vatC >>> 9) & 0x1F);
        vat[19 /* TEX6 */] = vatFmt((vatC >>> 14) & 0x01, (vatC >>> 15) & 0x07, (vatC >>> 18) & 0x1F);
        vat[20 /* TEX7 */] = vatFmt((vatC >>> 23) & 0x01, (vatC >>> 24) & 0x07, (vatC >>> 27) & 0x1F);
        var vtxArrays = [];
        util_50.assert(idVtxPos >= 0);
        if (idVtxPos >= 0)
            vtxArrays[9 /* POS */] = { buffer: inputBuffers.pos[idVtxPos].data, offs: 0 };
        if (idVtxNrm >= 0)
            vtxArrays[10 /* NRM */] = { buffer: inputBuffers.nrm[idVtxNrm].data, offs: 0 };
        if (idVtxClr0 >= 0)
            vtxArrays[11 /* CLR0 */] = { buffer: inputBuffers.clr[idVtxClr0].data, offs: 0 };
        if (idVtxClr1 >= 0)
            vtxArrays[12 /* CLR1 */] = { buffer: inputBuffers.clr[idVtxClr1].data, offs: 0 };
        if (idVtxTxc0 >= 0)
            vtxArrays[13 /* TEX0 */] = { buffer: inputBuffers.txc[idVtxTxc0].data, offs: 0 };
        if (idVtxTxc1 >= 0)
            vtxArrays[14 /* TEX1 */] = { buffer: inputBuffers.txc[idVtxTxc1].data, offs: 0 };
        if (idVtxTxc2 >= 0)
            vtxArrays[15 /* TEX2 */] = { buffer: inputBuffers.txc[idVtxTxc2].data, offs: 0 };
        if (idVtxTxc3 >= 0)
            vtxArrays[16 /* TEX3 */] = { buffer: inputBuffers.txc[idVtxTxc3].data, offs: 0 };
        if (idVtxTxc4 >= 0)
            vtxArrays[17 /* TEX4 */] = { buffer: inputBuffers.txc[idVtxTxc4].data, offs: 0 };
        if (idVtxTxc5 >= 0)
            vtxArrays[18 /* TEX5 */] = { buffer: inputBuffers.txc[idVtxTxc5].data, offs: 0 };
        if (idVtxTxc6 >= 0)
            vtxArrays[19 /* TEX6 */] = { buffer: inputBuffers.txc[idVtxTxc6].data, offs: 0 };
        if (idVtxTxc7 >= 0)
            vtxArrays[20 /* TEX7 */] = { buffer: inputBuffers.txc[idVtxTxc7].data, offs: 0 };
        var vtxLoader = gx_displaylist_4.compileVtxLoader(vat, vcd);
        var loadedVertexLayout = vtxLoader.loadedVertexLayout;
        var loadedVertexData = vtxLoader.runVertices(vtxArrays, buffer.subarray(primDLOffs, primDLSize));
        util_50.assert(loadedVertexData.totalVertexCount === numVertices);
        return { name: name, loadedVertexLayout: loadedVertexLayout, loadedVertexData: loadedVertexData };
    }
    function parseMDL0_NodeEntry(buffer) {
        var view = buffer.createDataView();
        var nameOffs = view.getUint32(0x08);
        var name = util_50.readString(buffer, nameOffs);
        var id = view.getUint32(0x0C);
        var mtxId = view.getUint32(0x10);
        var flags = view.getUint32(0x14);
        var billboardMode = view.getUint32(0x18);
        var bbrefNodeId = view.getUint32(0x1C);
        var scaleX = view.getFloat32(0x20);
        var scaleY = view.getFloat32(0x24);
        var scaleZ = view.getFloat32(0x28);
        var rotationX = view.getFloat32(0x2C);
        var rotationY = view.getFloat32(0x30);
        var rotationZ = view.getFloat32(0x34);
        var translationX = view.getFloat32(0x38);
        var translationY = view.getFloat32(0x3C);
        var translationZ = view.getFloat32(0x40);
        // TODO(jstpierre): NW4R doesn't appear to use this anymore?
        var bboxMinX = view.getFloat32(0x44);
        var bboxMinY = view.getFloat32(0x48);
        var bboxMinZ = view.getFloat32(0x4C);
        var bboxMaxX = view.getFloat32(0x50);
        var bboxMaxY = view.getFloat32(0x54);
        var bboxMaxZ = view.getFloat32(0x58);
        var bbox = new Camera_13.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
        var modelMatrix = gl_matrix_20.mat4.create();
        calcModelMtx(modelMatrix, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ, translationX, translationY, translationZ);
        return { name: name, id: id, mtxId: mtxId, flags: flags, billboardMode: billboardMode, modelMatrix: modelMatrix, bbox: bbox };
    }
    function parseMDL0_NodeTreeBytecode(buffer) {
        var view = buffer.createDataView();
        var nodeTreeOps = [];
        var i = 0;
        while (true) {
            var op = view.getUint8(i);
            if (op === 1 /* RET */) {
                break;
            }
            else if (op === 2 /* NODEDESC */) {
                var nodeId = view.getUint16(i + 1);
                var parentMtxId = view.getUint16(i + 3);
                i += 5;
                nodeTreeOps.push({ op: op, nodeId: nodeId, parentMtxId: parentMtxId });
            }
            else if (op === 6 /* MTXDUP */) {
                var toMtxId = view.getUint16(i + 1);
                var fromMtxId = view.getUint16(i + 3);
                i += 5;
                nodeTreeOps.push({ op: op, toMtxId: toMtxId, fromMtxId: fromMtxId });
            }
            else {
                throw "whoops";
            }
        }
        return nodeTreeOps;
    }
    function parseMDL0_DrawBytecode(buffer) {
        var view = buffer.createDataView();
        var drawOps = [];
        var i = 0;
        while (true) {
            var op = view.getUint8(i);
            if (op === 1 /* RET */) {
                break;
            }
            else if (op === 4 /* DRAW */) {
                var matId = view.getUint16(i + 1);
                var shpId = view.getUint16(i + 3);
                var nodeId = view.getUint16(i + 5);
                i += 8;
                drawOps.push({ matId: matId, shpId: shpId, nodeId: nodeId });
            }
            else {
                throw "whoops";
            }
        }
        return drawOps;
    }
    function parseMDL0_SceneGraph(buffer, byteCodeResDic) {
        var nodeTreeResDicEntry = byteCodeResDic.find(function (entry) { return entry.name === "NodeTree"; });
        util_50.assert(nodeTreeResDicEntry !== null);
        var nodeTreeBuffer = buffer.subarray(nodeTreeResDicEntry.offs);
        var nodeTreeOps = parseMDL0_NodeTreeBytecode(nodeTreeBuffer);
        var drawOpaOps = [];
        var drawOpaResDicEntry = byteCodeResDic.find((function (entry) { return entry.name === "DrawOpa"; }));
        if (drawOpaResDicEntry) {
            var drawOpaBuffer = buffer.subarray(drawOpaResDicEntry.offs);
            drawOpaOps = parseMDL0_DrawBytecode(drawOpaBuffer);
        }
        var drawXluOps = [];
        var drawXluResDicEntry = byteCodeResDic.find((function (entry) { return entry.name === "DrawXlu"; }));
        if (drawXluResDicEntry) {
            var drawXluBuffer = buffer.subarray(drawXluResDicEntry.offs);
            drawXluOps = parseMDL0_DrawBytecode(drawXluBuffer);
        }
        return { nodeTreeOps: nodeTreeOps, drawOpaOps: drawOpaOps, drawXluOps: drawXluOps };
    }
    function parseMDL0(buffer) {
        var view = buffer.createDataView();
        util_50.assert(util_50.readString(buffer, 0x00, 0x04) === 'MDL0');
        var version = view.getUint32(0x08);
        var supportedVersions = [0x08, 0x0B];
        util_50.assert(supportedVersions.includes(version));
        var offs = 0x10;
        function nextResDic() {
            var resDic = parseResDic(buffer, view.getUint32(offs));
            offs += 0x04;
            return resDic;
        }
        var byteCodeResDic = nextResDic();
        var nodeResDic = nextResDic();
        var vtxPosResDic = nextResDic();
        var vtxNrmResDic = nextResDic();
        var vtxClrResDic = nextResDic();
        var vtxTxcResDic = nextResDic();
        if (version >= 0x0A) {
            var furVecResDic = nextResDic();
            var furPosResDic = nextResDic();
        }
        var materialResDic = nextResDic();
        var tevResDic = nextResDic();
        var shpResDic = nextResDic();
        offs += 0x04; // Texture information
        offs += 0x04; // Palette information
        if (version >= 0x0A) {
            offs += 0x04; // User data
        }
        var nameOffs = view.getUint32(offs + 0x00);
        var name = util_50.readString(buffer, nameOffs);
        var infoOffs = offs + 0x04;
        var scalingRule = view.getUint32(infoOffs + 0x08);
        var texMtxMode = view.getUint32(infoOffs + 0x0C);
        var numVerts = view.getUint32(infoOffs + 0x10);
        var numPolygons = view.getUint32(infoOffs + 0x14);
        var isValidBBox = view.getUint8(infoOffs + 0x26);
        // TODO(jstpierre): Skyward Sword doesn't use this.
        var bbox = null;
        if (isValidBBox) {
            var bboxMinX = view.getFloat32(infoOffs + 0x28);
            var bboxMinY = view.getFloat32(infoOffs + 0x2C);
            var bboxMinZ = view.getFloat32(infoOffs + 0x30);
            var bboxMaxX = view.getFloat32(infoOffs + 0x34);
            var bboxMaxY = view.getFloat32(infoOffs + 0x38);
            var bboxMaxZ = view.getFloat32(infoOffs + 0x3C);
            bbox = new Camera_13.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
        }
        var materials = [];
        try {
            for (var materialResDic_1 = __values(materialResDic), materialResDic_1_1 = materialResDic_1.next(); !materialResDic_1_1.done; materialResDic_1_1 = materialResDic_1.next()) {
                var materialResDicEntry = materialResDic_1_1.value;
                var material = parseMDL0_MaterialEntry(buffer.subarray(materialResDicEntry.offs), version);
                util_50.assert(material.name === materialResDicEntry.name);
                materials.push(material);
            }
        }
        catch (e_64_1) { e_64 = { error: e_64_1 }; }
        finally {
            try {
                if (materialResDic_1_1 && !materialResDic_1_1.done && (_a = materialResDic_1.return)) _a.call(materialResDic_1);
            }
            finally { if (e_64) throw e_64.error; }
        }
        var inputBuffers = parseInputVertexBuffers(buffer, vtxPosResDic, vtxNrmResDic, vtxClrResDic, vtxTxcResDic);
        var shapes = [];
        for (var i = 0; i < shpResDic.length; i++) {
            var shpResDicEntry = shpResDic[i];
            var shape = parseMDL0_ShapeEntry(buffer.subarray(shpResDicEntry.offs), inputBuffers);
            util_50.assert(shape.name === shpResDicEntry.name);
            shapes.push(shape);
        }
        var nodes = [];
        try {
            for (var nodeResDic_1 = __values(nodeResDic), nodeResDic_1_1 = nodeResDic_1.next(); !nodeResDic_1_1.done; nodeResDic_1_1 = nodeResDic_1.next()) {
                var nodeResDicEntry = nodeResDic_1_1.value;
                var node = parseMDL0_NodeEntry(buffer.subarray(nodeResDicEntry.offs));
                util_50.assert(node.name === nodeResDicEntry.name);
                nodes.push(node);
            }
        }
        catch (e_65_1) { e_65 = { error: e_65_1 }; }
        finally {
            try {
                if (nodeResDic_1_1 && !nodeResDic_1_1.done && (_b = nodeResDic_1.return)) _b.call(nodeResDic_1);
            }
            finally { if (e_65) throw e_65.error; }
        }
        var sceneGraph = parseMDL0_SceneGraph(buffer, byteCodeResDic);
        return { name: name, bbox: bbox, materials: materials, shapes: shapes, nodes: nodes, sceneGraph: sceneGraph };
        var e_64, _a, e_65, _b;
    }
    function getAnimFrame(anim, frame) {
        // Be careful of floating point precision.
        var lastFrame = anim.duration;
        if (anim.loopMode === 0 /* ONCE */) {
            if (frame > lastFrame)
                frame = lastFrame;
            return frame;
        }
        else if (anim.loopMode === 1 /* REPEAT */) {
            while (frame > lastFrame)
                frame -= lastFrame;
            return frame;
        }
        else {
            throw "whoops";
        }
    }
    function lerp(k0, k1, t) {
        return k0 + (k1 - k0) * t;
    }
    function lerpPeriodic(k0, k1, t, kp) {
        if (kp === void 0) { kp = 180; }
        var ga = (k1 - k0) % kp;
        var g = 2 * ga % kp - ga;
        return k0 + g * t;
    }
    function sampleFloatAnimationTrackLinear(track, frame) {
        var frames = track.frames;
        var n = frames.length;
        if (n === 1)
            return frames[0];
        if (frame === 0)
            return frames[0];
        else if (frame > n - 1)
            return frames[n - 1];
        // Find the first frame.
        var idx0 = (frame | 0);
        var k0 = frames[idx0];
        var idx1 = idx0 + 1;
        var k1 = frames[idx1];
        var t = (frame - idx0);
        // Linear data is always used only with angles, so we always use periodic lerp here.
        return lerpPeriodic(k0, k1, t);
    }
    function cubicEval(cf0, cf1, cf2, cf3, t) {
        return (((cf0 * t + cf1) * t + cf2) * t + cf3);
    }
    function hermiteInterpolate(k0, k1, frame) {
        var length = k1.frame - k0.frame;
        var t = (frame - k0.frame) / length;
        var p0 = k0.value;
        var p1 = k1.value;
        var s0 = k0.tangent * length;
        var s1 = k1.tangent * length;
        var cf0 = (p0 * 2) + (p1 * -2) + (s0 * 1) + (s1 * 1);
        var cf1 = (p0 * -3) + (p1 * 3) + (s0 * -2) + (s1 * -1);
        var cf2 = (p0 * 0) + (p1 * 0) + (s0 * 1) + (s1 * 0);
        var cf3 = (p0 * 1) + (p1 * 0) + (s0 * 0) + (s1 * 0);
        return cubicEval(cf0, cf1, cf2, cf3, t);
    }
    function sampleFloatAnimationTrackHermite(track, frame) {
        var frames = track.frames;
        if (frames.length === 1)
            return frames[0].value;
        // Find the right-hand frame.
        var idx1 = 0;
        for (; idx1 < frames.length; idx1++) {
            if (frame < frames[idx1].frame)
                break;
        }
        if (idx1 === 0)
            return frames[0].value;
        else if (idx1 === frames.length)
            return frames[frames.length - 1].value;
        var idx0 = idx1 - 1;
        var k0 = frames[idx0];
        var k1 = frames[idx1];
        return hermiteInterpolate(k0, k1, frame);
    }
    function sampleFloatAnimationTrack(track, frame) {
        if (track.type === 0 /* LINEAR */)
            return sampleFloatAnimationTrackLinear(track, frame);
        else if (track.type === 1 /* HERMITE */)
            return sampleFloatAnimationTrackHermite(track, frame);
        else
            throw "whoops";
    }
    function makeConstantAnimationTrack(value) {
        return { type: 0 /* LINEAR */, frames: Float32Array.of(value) };
    }
    function parseAnimationTrackC32(buffer, numKeyframes) {
        var frames = buffer.createTypedArray(Float32Array, 0x00, numKeyframes + 1, 1 /* BIG_ENDIAN */);
        return { type: 0 /* LINEAR */, frames: frames };
    }
    function parseAnimationTrackF48(buffer) {
        var view = buffer.createDataView();
        var numKeyframes = view.getUint16(0x00);
        var invKeyframeRange = view.getFloat32(0x04);
        var scale = view.getFloat32(0x08);
        var offset = view.getFloat32(0x0C);
        var keyframeTableIdx = 0x10;
        var frames = [];
        for (var i = 0; i < numKeyframes; i++) {
            var frame = view.getInt16(keyframeTableIdx + 0x00) / 0x20; // S10.5
            var value = view.getUint16(keyframeTableIdx + 0x02) * scale + offset;
            var tangent = view.getInt16(keyframeTableIdx + 0x04) / 0x100; // S7.8
            var keyframe = { frame: frame, value: value, tangent: tangent };
            frames.push(keyframe);
            keyframeTableIdx += 0x06;
        }
        return { type: 1 /* HERMITE */, frames: frames };
    }
    function parseAnimationTrackF96(buffer) {
        var view = buffer.createDataView();
        var numKeyframes = view.getUint16(0x00);
        var invKeyframeRange = view.getFloat32(0x04);
        var keyframeTableIdx = 0x08;
        var frames = [];
        for (var i = 0; i < numKeyframes; i++) {
            var frame = view.getFloat32(keyframeTableIdx + 0x00);
            var value = view.getFloat32(keyframeTableIdx + 0x04);
            var tangent = view.getFloat32(keyframeTableIdx + 0x08);
            var keyframe = { frame: frame, value: value, tangent: tangent };
            frames.push(keyframe);
            keyframeTableIdx += 0x0C;
        }
        return { type: 1 /* HERMITE */, frames: frames };
    }
    function stepF(f, maxt, step, callback) {
        for (var t = 0; t < maxt; t += step) {
            callback(t, f(t));
        }
    }
    function cv() {
        var canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 400;
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        [].forEach.call(document.querySelectorAll('canvas.cv'), function (e) { return document.body.removeChild(e); });
        canvas.classList.add('cv');
        document.body.appendChild(canvas);
        return ctx;
    }
    function findAnimationData_SRT0(srt0, materialName, texMtxIndex) {
        var matData = srt0.matAnimations.find(function (m) { return m.materialName === materialName; });
        if (matData === undefined)
            return null;
        var texData = matData.texAnimations[texMtxIndex];
        if (texData === undefined)
            return null;
        return texData;
    }
    function parseSRT0_TexData(buffer) {
        var view = buffer.createDataView();
        var flags = view.getUint32(0x00);
        var scaleS = null;
        var scaleT = null;
        var rotation = null;
        var translationS = null;
        var translationT = null;
        var animationTableIdx = 0x04;
        function nextAnimationTrack(isConstant) {
            var animationTrack;
            if (isConstant) {
                var value = view.getFloat32(animationTableIdx);
                animationTrack = makeConstantAnimationTrack(value);
            }
            else {
                // Relative to the table idx.
                var animationTrackOffs = animationTableIdx + view.getUint32(animationTableIdx);
                animationTrack = parseAnimationTrackF96(buffer.slice(animationTrackOffs));
            }
            animationTableIdx += 0x04;
            return animationTrack;
        }
        if (!(flags & 2 /* SCALE_ONE */))
            scaleS = nextAnimationTrack(!!(flags & 32 /* SCALE_S_CONSTANT */));
        if (!(flags & 16 /* SCALE_UNIFORM */))
            scaleT = nextAnimationTrack(!!(flags & 64 /* SCALE_T_CONSTANT */));
        else
            scaleT = scaleS;
        if (!(flags & 4 /* ROT_ZERO */))
            rotation = nextAnimationTrack(!!(flags & 128 /* ROT_CONSTANT */));
        if (!(flags & 8 /* TRANS_ZERO */)) {
            translationS = nextAnimationTrack(!!(flags & 256 /* TRANS_S_CONSTANT */));
            translationT = nextAnimationTrack(!!(flags & 512 /* TRANS_T_CONSTANT */));
        }
        return { scaleS: scaleS, scaleT: scaleT, rotation: rotation, translationS: translationS, translationT: translationT };
    }
    function parseSRT0_MatData(buffer) {
        var view = buffer.createDataView();
        var materialNameOffs = view.getUint32(0x00);
        var materialName = util_50.readString(buffer, materialNameOffs);
        var texFlags = view.getUint32(0x04);
        var indFlags = view.getUint32(0x08);
        var flags = indFlags << 8 | texFlags;
        var texAnimationTableIdx = 0x0C;
        var texAnimations = [];
        // 8 normal animations, 4 indtex animations
        for (var i = 0; i < TexMtxIndex.COUNT; i++) {
            if (!(flags & (1 << i)))
                continue;
            var texAnimationOffs = view.getUint32(texAnimationTableIdx);
            texAnimationTableIdx += 0x04;
            texAnimations[i] = parseSRT0_TexData(buffer.slice(texAnimationOffs));
        }
        return { materialName: materialName, texAnimations: texAnimations };
    }
    function parseSRT0(buffer) {
        var view = buffer.createDataView();
        util_50.assert(util_50.readString(buffer, 0x00, 0x04) === 'SRT0');
        var version = view.getUint32(0x08);
        var supportedVersions = [0x04, 0x05];
        util_50.assert(supportedVersions.includes(version));
        var texSrtMatDataResDicOffs = view.getUint32(0x10);
        var texSrtMatDataResDic = parseResDic(buffer, texSrtMatDataResDicOffs);
        var offs = 0x14;
        if (version >= 0x05) {
            // user data
            offs += 0x04;
        }
        var nameOffs = view.getUint32(offs + 0x00);
        var name = util_50.readString(buffer, nameOffs);
        var duration = view.getUint16(offs + 0x08);
        var numMaterials = view.getUint16(offs + 0x0A);
        var texMtxMode = view.getUint32(offs + 0x0C);
        var loopMode = view.getUint32(offs + 0x10);
        var matAnimations = [];
        try {
            for (var texSrtMatDataResDic_1 = __values(texSrtMatDataResDic), texSrtMatDataResDic_1_1 = texSrtMatDataResDic_1.next(); !texSrtMatDataResDic_1_1.done; texSrtMatDataResDic_1_1 = texSrtMatDataResDic_1.next()) {
                var texSrtMatEntry = texSrtMatDataResDic_1_1.value;
                var matData = parseSRT0_MatData(buffer.slice(texSrtMatEntry.offs));
                matAnimations.push(matData);
            }
        }
        catch (e_66_1) { e_66 = { error: e_66_1 }; }
        finally {
            try {
                if (texSrtMatDataResDic_1_1 && !texSrtMatDataResDic_1_1.done && (_a = texSrtMatDataResDic_1.return)) _a.call(texSrtMatDataResDic_1);
            }
            finally { if (e_66) throw e_66.error; }
        }
        util_50.assert(matAnimations.length === numMaterials);
        return { name: name, loopMode: loopMode, duration: duration, texMtxMode: texMtxMode, matAnimations: matAnimations };
        var e_66, _a;
    }
    function bindSRT0Animator(animationController, srt0, materialName, texMtxIndex) {
        var texData = findAnimationData_SRT0(srt0, materialName, texMtxIndex);
        if (texData === null)
            return null;
        return new SRT0TexMtxAnimator(animationController, srt0, texData);
    }
    exports_80("bindSRT0Animator", bindSRT0Animator);
    function findAnimationData_PAT0(pat0, materialName, texMapID) {
        var matData = pat0.matAnimations.find(function (m) { return m.materialName === materialName; });
        if (matData === undefined)
            return null;
        var texData = matData.texAnimations[texMapID];
        if (texData === undefined)
            return null;
        return texData;
    }
    function parsePAT0_MatData(buffer) {
        var view = buffer.createDataView();
        var materialNameOffs = view.getUint32(0x00);
        var materialName = util_50.readString(buffer, materialNameOffs);
        var flags = view.getUint32(0x04);
        ;
        function parseAnimationTrackPAT0_TexFrameData(buffer) {
            var view = buffer.createDataView();
            var numKeyframes = view.getUint16(0x00);
            var invKeyframeRange = view.getFloat32(0x04);
            var keyframeTableIdx = 0x08;
            var frames = [];
            for (var i = 0; i < numKeyframes; i++) {
                var frame = view.getFloat32(keyframeTableIdx + 0x00);
                var texIndex = view.getUint16(keyframeTableIdx + 0x04);
                var palIndex = view.getUint16(keyframeTableIdx + 0x06);
                var keyframe = { frame: frame, texIndex: texIndex, palIndex: palIndex };
                frames.push(keyframe);
                keyframeTableIdx += 0x08;
            }
            return frames;
        }
        var animationTableIdx = 0x08;
        function nextAnimationTrack(isConstant) {
            var animationTrack;
            if (isConstant) {
                var texIndex = view.getUint16(animationTableIdx + 0x00);
                var palIndex = view.getUint16(animationTableIdx + 0x02);
                animationTrack = [{ frame: 0, texIndex: texIndex, palIndex: palIndex }];
            }
            else {
                var animationTrackOffs = view.getUint32(animationTableIdx);
                animationTrack = parseAnimationTrackPAT0_TexFrameData(buffer.slice(animationTrackOffs));
            }
            animationTableIdx += 0x04;
            return animationTrack;
        }
        var texAnimations = [];
        for (var i = 0; i < 8; i++) {
            var texFlags = (flags >>> (i * 4)) & 0x0F;
            if (!(texFlags & 1 /* EXISTS */))
                continue;
            var texIndexValid = !!(texFlags & 4 /* TEX_EXISTS */);
            var palIndexValid = !!(texFlags & 8 /* PAL_EXISTS */);
            var isConstant = !!(texFlags & 2 /* CONSTANT */);
            util_50.assert(texIndexValid && !palIndexValid);
            var animationTrack = nextAnimationTrack(isConstant);
            texAnimations[i] = { animationTrack: animationTrack, texIndexValid: texIndexValid, palIndexValid: palIndexValid };
        }
        return { materialName: materialName, texAnimations: texAnimations };
    }
    function parsePAT0(buffer) {
        var view = buffer.createDataView();
        util_50.assert(util_50.readString(buffer, 0x00, 0x04) === 'PAT0');
        var version = view.getUint32(0x08);
        var supportedVersions = [0x04];
        util_50.assert(supportedVersions.includes(version));
        var texPatMatDataResDicOffs = view.getUint32(0x10);
        var texPatMatDataResDic = parseResDic(buffer, texPatMatDataResDicOffs);
        var texNameOffsetTableOffs = view.getUint32(0x14);
        var palNameOffsetTableOffs = view.getUint32(0x18);
        var offs = 0x24;
        if (version >= 0x04) {
            // user data
            offs += 0x04;
        }
        var nameOffs = view.getUint32(offs + 0x00);
        var name = util_50.readString(buffer, nameOffs);
        var duration = view.getUint16(offs + 0x08);
        var numMaterials = view.getUint16(offs + 0x0A);
        var numTexNames = view.getUint16(offs + 0x0C);
        var numPalNames = view.getUint16(offs + 0x0E);
        var loopMode = view.getUint32(offs + 0x10);
        util_50.assert(numPalNames === 0);
        var matAnimations = [];
        try {
            for (var texPatMatDataResDic_1 = __values(texPatMatDataResDic), texPatMatDataResDic_1_1 = texPatMatDataResDic_1.next(); !texPatMatDataResDic_1_1.done; texPatMatDataResDic_1_1 = texPatMatDataResDic_1.next()) {
                var texPatMatEntry = texPatMatDataResDic_1_1.value;
                var matData = parsePAT0_MatData(buffer.slice(texPatMatEntry.offs));
                matAnimations.push(matData);
            }
        }
        catch (e_67_1) { e_67 = { error: e_67_1 }; }
        finally {
            try {
                if (texPatMatDataResDic_1_1 && !texPatMatDataResDic_1_1.done && (_a = texPatMatDataResDic_1.return)) _a.call(texPatMatDataResDic_1);
            }
            finally { if (e_67) throw e_67.error; }
        }
        util_50.assert(matAnimations.length === numMaterials);
        var texNames = [];
        var texNameOffsetTableIdx = texNameOffsetTableOffs;
        for (var i = 0; i < numTexNames; i++) {
            var nameOffs_2 = view.getUint32(texNameOffsetTableIdx);
            var texName = util_50.readString(buffer, texNameOffsetTableOffs + nameOffs_2);
            texNames.push(texName);
            texNameOffsetTableIdx += 0x04;
        }
        return { name: name, loopMode: loopMode, duration: duration, matAnimations: matAnimations, texNames: texNames };
        var e_67, _a;
    }
    function findFrameData(frames, frame) {
        if (frames.length === 1)
            return frames[0];
        // Find the left-hand frame.
        var idx0 = frames.length;
        while (idx0-- > 0) {
            if (frame > frames[idx0].frame)
                break;
        }
        return frames[idx0];
    }
    function bindPAT0Animator(animationController, pat0, materialName, texMapID) {
        var texData = findAnimationData_PAT0(pat0, materialName, texMapID);
        if (texData === null)
            return null;
        return new PAT0TexAnimator(animationController, pat0, texData);
    }
    exports_80("bindPAT0Animator", bindPAT0Animator);
    function findAnimationData_CLR0(clr0, materialName, color) {
        var matData = clr0.matAnimations.find(function (m) { return m.materialName === materialName; });
        if (matData === undefined)
            return null;
        var clrData = matData.clrAnimations[color];
        if (clrData === undefined)
            return null;
        return clrData;
    }
    function parseColorDataFrames(buffer, numKeyframes, isConstant) {
        var view = buffer.createDataView();
        var frames;
        if (isConstant) {
            var color = view.getUint32(0x00);
            return Uint32Array.of(color);
        }
        else {
            var animationTrackOffs = view.getUint32(0x00);
            return buffer.createTypedArray(Uint32Array, animationTrackOffs, numKeyframes + 1, 1 /* BIG_ENDIAN */);
        }
    }
    function parseCLR0_MatData(buffer, numKeyframes) {
        var view = buffer.createDataView();
        var materialNameOffs = view.getUint32(0x00);
        var materialName = util_50.readString(buffer, materialNameOffs);
        var flags = view.getUint32(0x04);
        ;
        var animationTableIdx = 0x08;
        function nextColorData(isConstant) {
            var mask = view.getUint32(animationTableIdx + 0x00);
            var frames = parseColorDataFrames(buffer.slice(animationTableIdx + 0x04), numKeyframes, isConstant);
            animationTableIdx += 0x08;
            return { mask: mask, frames: frames };
        }
        var clrAnimations = [];
        for (var i = 0; i < AnimatableColor.COUNT; i++) {
            var clrFlags = (flags >>> (i * 2)) & 0x03;
            if (!(clrFlags & 1 /* EXISTS */))
                continue;
            var isConstant = !!(clrFlags & 2 /* CONSTANT */);
            clrAnimations[i] = nextColorData(isConstant);
        }
        return { materialName: materialName, clrAnimations: clrAnimations };
    }
    function parseCLR0(buffer) {
        var view = buffer.createDataView();
        util_50.assert(util_50.readString(buffer, 0x00, 0x04) === 'CLR0');
        var version = view.getUint32(0x08);
        var supportedVersions = [0x03, 0x04];
        util_50.assert(supportedVersions.includes(version));
        var clrMatDataResDicOffs = view.getUint32(0x10);
        var clrMatDataResDic = parseResDic(buffer, clrMatDataResDicOffs);
        var offs = 0x14;
        if (version >= 0x04) {
            // user data
            offs += 0x04;
        }
        var nameOffs = view.getUint32(offs + 0x00);
        var name = util_50.readString(buffer, nameOffs);
        var duration = view.getUint16(offs + 0x08);
        var numMaterials = view.getUint16(offs + 0x0A);
        var loopMode = view.getUint32(offs + 0x0C);
        var matAnimations = [];
        try {
            for (var clrMatDataResDic_1 = __values(clrMatDataResDic), clrMatDataResDic_1_1 = clrMatDataResDic_1.next(); !clrMatDataResDic_1_1.done; clrMatDataResDic_1_1 = clrMatDataResDic_1.next()) {
                var clrMatEntry = clrMatDataResDic_1_1.value;
                var matData = parseCLR0_MatData(buffer.slice(clrMatEntry.offs), duration);
                matAnimations.push(matData);
            }
        }
        catch (e_68_1) { e_68 = { error: e_68_1 }; }
        finally {
            try {
                if (clrMatDataResDic_1_1 && !clrMatDataResDic_1_1.done && (_a = clrMatDataResDic_1.return)) _a.call(clrMatDataResDic_1);
            }
            finally { if (e_68) throw e_68.error; }
        }
        util_50.assert(matAnimations.length === numMaterials);
        return { name: name, loopMode: loopMode, duration: duration, matAnimations: matAnimations };
        var e_68, _a;
    }
    function lerpColor(k0, k1, t) {
        var k0r = (k0 >>> 24) & 0xFF;
        var k0g = (k0 >>> 16) & 0xFF;
        var k0b = (k0 >>> 8) & 0xFF;
        var k0a = (k0 >>> 0) & 0xFF;
        var k1r = (k1 >>> 24) & 0xFF;
        var k1g = (k1 >>> 16) & 0xFF;
        var k1b = (k1 >>> 8) & 0xFF;
        var k1a = (k1 >>> 0) & 0xFF;
        var r = lerp(k0r, k1r, t);
        var g = lerp(k0g, k1g, t);
        var b = lerp(k0b, k1b, t);
        var a = lerp(k0a, k1a, t);
        return (r << 24) | (g << 16) | (b << 8) | a;
    }
    function sampleColorData(frames, frame) {
        var n = frames.length;
        if (n === 1)
            return frames[0];
        if (frame === 0)
            return frames[0];
        else if (frame > n - 1)
            return frames[n - 1];
        // Find the first frame.
        var idx0 = (frame | 0);
        var k0 = frames[idx0];
        var idx1 = idx0 + 1;
        var k1 = frames[idx1];
        var t = (frame - idx0);
        return lerpColor(k0, k1, t);
    }
    function bindCLR0Animator(animationController, clr0, materialName, color) {
        var clrData = findAnimationData_CLR0(clr0, materialName, color);
        if (clrData === null)
            return null;
        return new CLR0ColorAnimator(animationController, clr0, clrData);
    }
    exports_80("bindCLR0Animator", bindCLR0Animator);
    function parseCHR0_NodeData(buffer, numKeyframes) {
        ;
        var TrackFormat;
        (function (TrackFormat) {
            TrackFormat[TrackFormat["CONSTANT"] = 0] = "CONSTANT";
            TrackFormat[TrackFormat["_32"] = 1] = "_32";
            TrackFormat[TrackFormat["_48"] = 2] = "_48";
            TrackFormat[TrackFormat["_96"] = 3] = "_96";
            TrackFormat[TrackFormat["FRM_8"] = 4] = "FRM_8";
            TrackFormat[TrackFormat["FRM_16"] = 5] = "FRM_16";
            TrackFormat[TrackFormat["FRM_32"] = 6] = "FRM_32";
        })(TrackFormat || (TrackFormat = {}));
        ;
        var view = buffer.createDataView();
        var nodeNameOffs = view.getUint32(0x00);
        var nodeName = util_50.readString(buffer, nodeNameOffs);
        var flags = view.getUint32(0x04);
        var animationTableIdx = 0x08;
        function nextAnimationTrack(trackFormat, isConstant) {
            var animationTrack;
            if (isConstant || trackFormat === TrackFormat.CONSTANT) {
                var value = view.getFloat32(animationTableIdx);
                animationTrack = makeConstantAnimationTrack(value);
            }
            else if (trackFormat === TrackFormat._96) {
                // Relative to the beginning of the node.
                var animationTrackOffs = view.getUint32(animationTableIdx);
                animationTrack = parseAnimationTrackF96(buffer.slice(animationTrackOffs));
            }
            else if (trackFormat === TrackFormat._48) {
                var animationTrackOffs = view.getUint32(animationTableIdx);
                animationTrack = parseAnimationTrackF48(buffer.slice(animationTrackOffs));
            }
            else if (trackFormat === TrackFormat.FRM_32) {
                var animationTrackOffs = view.getUint32(animationTableIdx);
                animationTrack = parseAnimationTrackC32(buffer.slice(animationTrackOffs), numKeyframes);
            }
            else {
                console.warn("Unsupported animation track format", trackFormat);
                animationTrack = null;
            }
            animationTableIdx += 0x04;
            return animationTrack;
        }
        var scaleFormat = (flags >>> 25) & 0x03;
        var rotationFormat = (flags >>> 27) & 0x07;
        var translationFormat = (flags >>> 30) & 0x03;
        var scaleX = null, scaleY = null, scaleZ = null;
        if (!(flags & 138 /* SCALE_NOT_EXIST */))
            scaleX = nextAnimationTrack(scaleFormat, !!(flags & 8192 /* SCALE_X_CONSTANT */));
        if (!(flags & 16 /* SCALE_UNIFORM */)) {
            scaleY = nextAnimationTrack(scaleFormat, !!(flags & 16384 /* SCALE_Y_CONSTANT */));
            scaleZ = nextAnimationTrack(scaleFormat, !!(flags & 32768 /* SCALE_Z_CONSTANT */));
        }
        else {
            scaleY = scaleX;
            scaleZ = scaleX;
        }
        var rotationX = null, rotationY = null, rotationZ = null;
        if (!(flags & 294 /* ROTATE_NOT_EXIST */)) {
            rotationX = nextAnimationTrack(rotationFormat, !!(flags & 65536 /* ROTATE_X_CONSTANT */));
            rotationY = nextAnimationTrack(rotationFormat, !!(flags & 131072 /* ROTATE_Y_CONSTANT */));
            rotationZ = nextAnimationTrack(rotationFormat, !!(flags & 262144 /* ROTATE_Z_CONSTANT */));
        }
        var translationX = null, translationY = null, translationZ = null;
        if (!(flags & 582 /* TRANS_NOT_EXIST */)) {
            translationX = nextAnimationTrack(translationFormat, !!(flags & 524288 /* TRANS_X_CONSTANT */));
            translationY = nextAnimationTrack(translationFormat, !!(flags & 1048576 /* TRANS_Y_CONSTANT */));
            translationZ = nextAnimationTrack(translationFormat, !!(flags & 2097152 /* TRANS_Z_CONSTANT */));
        }
        return {
            nodeName: nodeName,
            scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ,
            rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ,
            translationX: translationX, translationY: translationY, translationZ: translationZ,
        };
    }
    function parseCHR0(buffer) {
        var view = buffer.createDataView();
        util_50.assert(util_50.readString(buffer, 0x00, 0x04) === 'CHR0');
        var version = view.getUint32(0x08);
        var supportedVersions = [0x03, 0x05];
        util_50.assert(supportedVersions.includes(version));
        var chrNodeDataResDicOffs = view.getUint32(0x10);
        var chrNodeDataResDic = parseResDic(buffer, chrNodeDataResDicOffs);
        var offs = 0x14;
        if (version >= 0x05) {
            // user data
            offs += 0x04;
        }
        var nameOffs = view.getUint32(offs + 0x00);
        var name = util_50.readString(buffer, nameOffs);
        var duration = view.getUint16(offs + 0x08);
        var numNodes = view.getUint16(offs + 0x0A);
        var loopMode = view.getUint32(offs + 0x0C);
        var scalingRule = view.getUint32(offs + 0x10);
        var nodeAnimations = [];
        try {
            for (var chrNodeDataResDic_1 = __values(chrNodeDataResDic), chrNodeDataResDic_1_1 = chrNodeDataResDic_1.next(); !chrNodeDataResDic_1_1.done; chrNodeDataResDic_1_1 = chrNodeDataResDic_1.next()) {
                var chrNodeEntry = chrNodeDataResDic_1_1.value;
                var nodeData = parseCHR0_NodeData(buffer.slice(chrNodeEntry.offs), duration);
                nodeAnimations.push(nodeData);
            }
        }
        catch (e_69_1) { e_69 = { error: e_69_1 }; }
        finally {
            try {
                if (chrNodeDataResDic_1_1 && !chrNodeDataResDic_1_1.done && (_a = chrNodeDataResDic_1.return)) _a.call(chrNodeDataResDic_1);
            }
            finally { if (e_69) throw e_69.error; }
        }
        util_50.assert(nodeAnimations.length === numNodes);
        return { name: name, loopMode: loopMode, duration: duration, nodeAnimations: nodeAnimations };
        var e_69, _a;
    }
    function bindCHR0Animator(animationController, chr0, nodes) {
        var nodeData = [];
        var _loop_14 = function (nodeAnimation) {
            var node = nodes.find(function (node) { return node.name === nodeAnimation.nodeName; });
            if (!node)
                return "continue";
            nodeData[node.id] = nodeAnimation;
        };
        try {
            for (var _a = __values(chr0.nodeAnimations), _b = _a.next(); !_b.done; _b = _a.next()) {
                var nodeAnimation = _b.value;
                _loop_14(nodeAnimation);
            }
        }
        catch (e_70_1) { e_70 = { error: e_70_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_70) throw e_70.error; }
        }
        // No nodes found.
        if (nodeData.length === 0)
            return null;
        return new CHR0NodesAnimator(animationController, chr0, nodeData);
        var e_70, _c;
    }
    exports_80("bindCHR0Animator", bindCHR0Animator);
    function parse(buffer) {
        var view = buffer.createDataView();
        util_50.assert(util_50.readString(buffer, 0x00, 0x04) === 'bres');
        var littleEndian;
        switch (view.getUint16(0x04, false)) {
            case 0xFEFF:
                littleEndian = false;
                break;
            case 0xFFFE:
                littleEndian = true;
                break;
            default:
                throw new Error("Invalid BOM");
        }
        util_50.assert(!littleEndian);
        var fileLength = view.getUint32(0x08);
        var rootSectionOffs = view.getUint16(0x0C);
        var numSections = view.getUint16(0x0E);
        // Parse out root section.
        util_50.assert(util_50.readString(buffer, rootSectionOffs + 0x00, 0x04) === 'root');
        var rootResDic = parseResDic(buffer, rootSectionOffs + 0x08);
        // Models
        var mdl0 = [];
        var modelsEntry = rootResDic.find(function (entry) { return entry.name === '3DModels(NW4R)'; });
        if (modelsEntry) {
            var modelsResDic = parseResDic(buffer, modelsEntry.offs);
            try {
                for (var modelsResDic_1 = __values(modelsResDic), modelsResDic_1_1 = modelsResDic_1.next(); !modelsResDic_1_1.done; modelsResDic_1_1 = modelsResDic_1.next()) {
                    var mdl0Entry = modelsResDic_1_1.value;
                    var mdl0_ = parseMDL0(buffer.subarray(mdl0Entry.offs));
                    util_50.assert(mdl0_.name === mdl0Entry.name);
                    mdl0.push(mdl0_);
                }
            }
            catch (e_71_1) { e_71 = { error: e_71_1 }; }
            finally {
                try {
                    if (modelsResDic_1_1 && !modelsResDic_1_1.done && (_a = modelsResDic_1.return)) _a.call(modelsResDic_1);
                }
                finally { if (e_71) throw e_71.error; }
            }
        }
        // Textures
        var tex0 = [];
        var texturesEntry = rootResDic.find(function (entry) { return entry.name === 'Textures(NW4R)'; });
        if (texturesEntry) {
            var texturesResDic = parseResDic(buffer, texturesEntry.offs);
            try {
                for (var texturesResDic_1 = __values(texturesResDic), texturesResDic_1_1 = texturesResDic_1.next(); !texturesResDic_1_1.done; texturesResDic_1_1 = texturesResDic_1.next()) {
                    var tex0Entry = texturesResDic_1_1.value;
                    var tex0_ = parseTEX0(buffer.subarray(tex0Entry.offs));
                    util_50.assert(tex0_.name === tex0Entry.name);
                    tex0.push(tex0_);
                }
            }
            catch (e_72_1) { e_72 = { error: e_72_1 }; }
            finally {
                try {
                    if (texturesResDic_1_1 && !texturesResDic_1_1.done && (_b = texturesResDic_1.return)) _b.call(texturesResDic_1);
                }
                finally { if (e_72) throw e_72.error; }
            }
        }
        // Tex SRT Animations
        var srt0 = [];
        var animTexSrtsEntry = rootResDic.find(function (entry) { return entry.name === 'AnmTexSrt(NW4R)'; });
        if (animTexSrtsEntry) {
            var animTexSrtResDic = parseResDic(buffer, animTexSrtsEntry.offs);
            try {
                for (var animTexSrtResDic_1 = __values(animTexSrtResDic), animTexSrtResDic_1_1 = animTexSrtResDic_1.next(); !animTexSrtResDic_1_1.done; animTexSrtResDic_1_1 = animTexSrtResDic_1.next()) {
                    var srt0Entry = animTexSrtResDic_1_1.value;
                    var srt0_ = parseSRT0(buffer.subarray(srt0Entry.offs));
                    util_50.assert(srt0_.name === srt0Entry.name);
                    srt0.push(srt0_);
                }
            }
            catch (e_73_1) { e_73 = { error: e_73_1 }; }
            finally {
                try {
                    if (animTexSrtResDic_1_1 && !animTexSrtResDic_1_1.done && (_c = animTexSrtResDic_1.return)) _c.call(animTexSrtResDic_1);
                }
                finally { if (e_73) throw e_73.error; }
            }
        }
        // Tex Pattern Animations
        var pat0 = [];
        var animTexPatsEntry = rootResDic.find(function (entry) { return entry.name === 'AnmTexPat(NW4R)'; });
        if (animTexPatsEntry) {
            var animTexPatResDic = parseResDic(buffer, animTexPatsEntry.offs);
            try {
                for (var animTexPatResDic_1 = __values(animTexPatResDic), animTexPatResDic_1_1 = animTexPatResDic_1.next(); !animTexPatResDic_1_1.done; animTexPatResDic_1_1 = animTexPatResDic_1.next()) {
                    var pat0Entry = animTexPatResDic_1_1.value;
                    var pat0_ = parsePAT0(buffer.subarray(pat0Entry.offs));
                    util_50.assert(pat0_.name === pat0Entry.name);
                    pat0.push(pat0_);
                }
            }
            catch (e_74_1) { e_74 = { error: e_74_1 }; }
            finally {
                try {
                    if (animTexPatResDic_1_1 && !animTexPatResDic_1_1.done && (_d = animTexPatResDic_1.return)) _d.call(animTexPatResDic_1);
                }
                finally { if (e_74) throw e_74.error; }
            }
        }
        // Color Animations
        var clr0 = [];
        var animClrsEntry = rootResDic.find(function (entry) { return entry.name === 'AnmClr(NW4R)'; });
        if (animClrsEntry) {
            var animClrResDic = parseResDic(buffer, animClrsEntry.offs);
            try {
                for (var animClrResDic_1 = __values(animClrResDic), animClrResDic_1_1 = animClrResDic_1.next(); !animClrResDic_1_1.done; animClrResDic_1_1 = animClrResDic_1.next()) {
                    var clr0Entry = animClrResDic_1_1.value;
                    var clr0_ = parseCLR0(buffer.subarray(clr0Entry.offs));
                    util_50.assert(clr0_.name === clr0Entry.name);
                    clr0.push(clr0_);
                }
            }
            catch (e_75_1) { e_75 = { error: e_75_1 }; }
            finally {
                try {
                    if (animClrResDic_1_1 && !animClrResDic_1_1.done && (_e = animClrResDic_1.return)) _e.call(animClrResDic_1);
                }
                finally { if (e_75) throw e_75.error; }
            }
        }
        // Node Animations
        var chr0 = [];
        var animChrsEntry = rootResDic.find(function (entry) { return entry.name === 'AnmChr(NW4R)'; });
        if (animChrsEntry) {
            var animChrResDic = parseResDic(buffer, animChrsEntry.offs);
            try {
                for (var animChrResDic_1 = __values(animChrResDic), animChrResDic_1_1 = animChrResDic_1.next(); !animChrResDic_1_1.done; animChrResDic_1_1 = animChrResDic_1.next()) {
                    var chr0Entry = animChrResDic_1_1.value;
                    var chr0_ = parseCHR0(buffer.subarray(chr0Entry.offs));
                    util_50.assert(chr0_.name === chr0Entry.name);
                    chr0.push(chr0_);
                }
            }
            catch (e_76_1) { e_76 = { error: e_76_1 }; }
            finally {
                try {
                    if (animChrResDic_1_1 && !animChrResDic_1_1.done && (_f = animChrResDic_1.return)) _f.call(animChrResDic_1);
                }
                finally { if (e_76) throw e_76.error; }
            }
        }
        return { mdl0: mdl0, tex0: tex0, srt0: srt0, pat0: pat0, clr0: clr0, chr0: chr0 };
        var e_71, _a, e_72, _b, e_73, _c, e_74, _d, e_75, _e, e_76, _f;
    }
    exports_80("parse", parse);
    var util_50, GX_Material, gx_displaylist_4, gl_matrix_20, Camera_13, DisplayListRegisters, AnimationController, Graph, SRT0TexMtxAnimator, TexMtxIndex, PAT0TexAnimator, AnimatableColor, CLR0ColorAnimator, CHR0NodesAnimator;
    return {
        setters: [
            function (util_50_1) {
                util_50 = util_50_1;
            },
            function (GX_Material_10) {
                GX_Material = GX_Material_10;
            },
            function (gx_displaylist_4_1) {
                gx_displaylist_4 = gx_displaylist_4_1;
            },
            function (gl_matrix_20_1) {
                gl_matrix_20 = gl_matrix_20_1;
            },
            function (Camera_13_1) {
                Camera_13 = Camera_13_1;
            }
        ],
        execute: function () {
            ;
            //#endregion
            //#region MDL0
            DisplayListRegisters = /** @class */ (function () {
                function DisplayListRegisters() {
                    this.bp = new Uint32Array(0x100);
                    this.cp = new Uint32Array(0x100);
                    // Can have up to 16 values per register.
                    this.xf = new Uint32Array(0x1000);
                    // TEV colors are weird and are two things under the hood
                    // with the same register address.
                    this.kc = new Uint32Array(4 * 2 * 2);
                    // Initialize defaults.
                    this.bp[254 /* SS_MASK */] = 0x00FFFFFF;
                }
                DisplayListRegisters.prototype.bps = function (regBag) {
                    // First byte has register address, other 3 have value.
                    var regAddr = regBag >>> 24;
                    var regWMask = this.bp[254 /* SS_MASK */];
                    // Retrieve existing value, overwrite w/ mask.
                    var regValue = (this.bp[regAddr] & ~regWMask) | (regBag & regWMask);
                    // The mask resets after use.
                    this.bp[254 /* SS_MASK */] = 0x00FFFFFF;
                    // Set new value.
                    this.bp[regAddr] = regValue;
                    // Copy TEV colors internally.
                    if (regAddr >= 224 /* TEV_REGISTERL_0_ID */ && regAddr <= 224 /* TEV_REGISTERL_0_ID */ + 4 * 2) {
                        var kci = regAddr - 224 /* TEV_REGISTERL_0_ID */;
                        var bank = (regValue >>> 23) & 0x01;
                        this.kc[bank * 4 * 2 + kci] = regValue;
                    }
                };
                DisplayListRegisters.prototype.xfs = function (idx, sub, v) {
                    util_50.assert(idx >= 0x1000);
                    idx -= 0x1000;
                    this.xf[idx * 0x10 + sub] = v;
                };
                DisplayListRegisters.prototype.xfg = function (idx, sub) {
                    if (sub === void 0) { sub = 0; }
                    util_50.assert(idx >= 0x1000);
                    idx -= 0x1000;
                    return this.xf[idx * 0x10 + sub];
                };
                return DisplayListRegisters;
            }());
            ;
            ;
            AnimationController = /** @class */ (function () {
                function AnimationController() {
                    this.fps = 30;
                }
                AnimationController.prototype.getTimeInFrames = function () {
                    var ms = this.timeMilliseconds;
                    return (ms / 1000) * this.fps;
                };
                AnimationController.prototype.updateTime = function (newTime) {
                    this.timeMilliseconds = newTime;
                };
                return AnimationController;
            }());
            exports_80("AnimationController", AnimationController);
            Graph = /** @class */ (function () {
                function Graph(ctx) {
                    this.minv = undefined;
                    this.maxv = undefined;
                    this.ctx = ctx;
                }
                Graph.prototype.graphF = function (color, f, range) {
                    var _this = this;
                    var step = 1;
                    stepF(f, range, step, function (t, v) {
                        if (_this.minv === undefined)
                            _this.minv = v;
                        if (_this.maxv === undefined)
                            _this.maxv = v;
                        _this.minv = Math.min(_this.minv, v);
                        _this.maxv = Math.max(_this.maxv, v);
                    });
                    // pad
                    var displayMinV = this.minv;
                    var displayMaxV = this.maxv;
                    var ctx = this.ctx;
                    var width = ctx.canvas.width;
                    var height = ctx.canvas.height;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    stepF(f, range, step, function (t, v) {
                        var xa = (t / range) * 1 / step;
                        var ya = (v - displayMinV) / (displayMaxV - displayMinV);
                        var x = xa * width;
                        var y = (1 - ya) * height;
                        ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                };
                return Graph;
            }());
            SRT0TexMtxAnimator = /** @class */ (function () {
                function SRT0TexMtxAnimator(animationController, srt0, texData) {
                    this.animationController = animationController;
                    this.srt0 = srt0;
                    this.texData = texData;
                    this.scratch = gl_matrix_20.mat4.create();
                }
                SRT0TexMtxAnimator.prototype._calcTexMtx = function (dst, texMtxMode) {
                    var texData = this.texData;
                    var frame = this.animationController.getTimeInFrames();
                    var animFrame = getAnimFrame(this.srt0, frame);
                    var scaleS = texData.scaleS ? sampleFloatAnimationTrack(texData.scaleS, animFrame) : 1;
                    var scaleT = texData.scaleT ? sampleFloatAnimationTrack(texData.scaleT, animFrame) : 1;
                    var rotation = texData.rotation ? sampleFloatAnimationTrack(texData.rotation, animFrame) : 0;
                    var translationS = texData.translationS ? sampleFloatAnimationTrack(texData.translationS, animFrame) : 0;
                    var translationT = texData.translationS ? sampleFloatAnimationTrack(texData.translationT, animFrame) : 0;
                    calcTexMtx(dst, texMtxMode, scaleS, scaleT, rotation, translationS, translationT);
                };
                SRT0TexMtxAnimator.prototype.calcIndTexMtx = function (dst) {
                    this._calcTexMtx(this.scratch, -1 /* BASIC */);
                    calc2dMtx(dst, this.scratch);
                };
                SRT0TexMtxAnimator.prototype.calcTexMtx = function (dst) {
                    this._calcTexMtx(dst, this.srt0.texMtxMode);
                };
                return SRT0TexMtxAnimator;
            }());
            exports_80("SRT0TexMtxAnimator", SRT0TexMtxAnimator);
            (function (TexMtxIndex) {
                // Texture.
                TexMtxIndex[TexMtxIndex["TEX0"] = 0] = "TEX0";
                TexMtxIndex[TexMtxIndex["TEX1"] = 1] = "TEX1";
                TexMtxIndex[TexMtxIndex["TEX2"] = 2] = "TEX2";
                TexMtxIndex[TexMtxIndex["TEX3"] = 3] = "TEX3";
                TexMtxIndex[TexMtxIndex["TEX4"] = 4] = "TEX4";
                TexMtxIndex[TexMtxIndex["TEX5"] = 5] = "TEX5";
                TexMtxIndex[TexMtxIndex["TEX6"] = 6] = "TEX6";
                TexMtxIndex[TexMtxIndex["TEX7"] = 7] = "TEX7";
                // Indirect.
                TexMtxIndex[TexMtxIndex["IND0"] = 8] = "IND0";
                TexMtxIndex[TexMtxIndex["IND1"] = 9] = "IND1";
                TexMtxIndex[TexMtxIndex["IND2"] = 10] = "IND2";
                TexMtxIndex[TexMtxIndex["COUNT"] = 11] = "COUNT";
            })(TexMtxIndex || (TexMtxIndex = {}));
            exports_80("TexMtxIndex", TexMtxIndex);
            PAT0TexAnimator = /** @class */ (function () {
                function PAT0TexAnimator(animationController, pat0, texData) {
                    this.animationController = animationController;
                    this.pat0 = pat0;
                    this.texData = texData;
                }
                PAT0TexAnimator.prototype.calcTextureMapping = function (textureMapping, textureHolder) {
                    var texData = this.texData;
                    var frame = this.animationController.getTimeInFrames();
                    var animFrame = getAnimFrame(this.pat0, frame);
                    var texFrameData = findFrameData(texData.animationTrack, animFrame);
                    if (texData.texIndexValid) {
                        var texName = this.pat0.texNames[texFrameData.texIndex];
                        textureHolder.fillTextureMapping(textureMapping, texName);
                    }
                };
                return PAT0TexAnimator;
            }());
            exports_80("PAT0TexAnimator", PAT0TexAnimator);
            //#endregion
            //#region CLR0
            (function (AnimatableColor) {
                AnimatableColor[AnimatableColor["MAT0"] = 0] = "MAT0";
                AnimatableColor[AnimatableColor["MAT1"] = 1] = "MAT1";
                AnimatableColor[AnimatableColor["AMB0"] = 2] = "AMB0";
                AnimatableColor[AnimatableColor["AMB1"] = 3] = "AMB1";
                AnimatableColor[AnimatableColor["C0"] = 4] = "C0";
                AnimatableColor[AnimatableColor["C1"] = 5] = "C1";
                AnimatableColor[AnimatableColor["C2"] = 6] = "C2";
                AnimatableColor[AnimatableColor["K0"] = 7] = "K0";
                AnimatableColor[AnimatableColor["K1"] = 8] = "K1";
                AnimatableColor[AnimatableColor["K2"] = 9] = "K2";
                AnimatableColor[AnimatableColor["K3"] = 10] = "K3";
                AnimatableColor[AnimatableColor["COUNT"] = 11] = "COUNT";
            })(AnimatableColor || (AnimatableColor = {}));
            exports_80("AnimatableColor", AnimatableColor);
            CLR0ColorAnimator = /** @class */ (function () {
                function CLR0ColorAnimator(animationController, clr0, clrData) {
                    this.animationController = animationController;
                    this.clr0 = clr0;
                    this.clrData = clrData;
                }
                CLR0ColorAnimator.prototype.calcColor = function (dst, orig) {
                    var clrData = this.clrData;
                    var frame = this.animationController.getTimeInFrames();
                    var animFrame = getAnimFrame(this.clr0, frame);
                    var animColor = sampleColorData(clrData.frames, animFrame);
                    var c = (orig.get32() & clrData.mask) | animColor;
                    dst.copy32(c);
                };
                return CLR0ColorAnimator;
            }());
            exports_80("CLR0ColorAnimator", CLR0ColorAnimator);
            CHR0NodesAnimator = /** @class */ (function () {
                function CHR0NodesAnimator(animationController, chr0, nodeData) {
                    this.animationController = animationController;
                    this.chr0 = chr0;
                    this.nodeData = nodeData;
                    this.disabled = [];
                    this.vizNodeId = undefined;
                }
                CHR0NodesAnimator.prototype.viz = function (nodeId) {
                    this.vizNodeId = nodeId;
                    this.vizGraph = new Graph(cv());
                };
                CHR0NodesAnimator.prototype.updviz = function (animFrame, nodeData) {
                    var _this = this;
                    var numFrames = this.chr0.duration;
                    var ctx = this.vizGraph.ctx;
                    var scale = 10;
                    var maxt = (numFrames / scale) | 0;
                    var offt = animFrame - maxt / 2;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    if (nodeData.rotationX) {
                        this.vizGraph.graphF('red', function (t) {
                            var animFrame = getAnimFrame(_this.chr0, t + offt);
                            return sampleFloatAnimationTrack(nodeData.rotationX, animFrame);
                        }, maxt);
                    }
                    if (nodeData.rotationY) {
                        this.vizGraph.graphF('green', function (t) {
                            var animFrame = getAnimFrame(_this.chr0, t + offt);
                            return sampleFloatAnimationTrack(nodeData.rotationY, animFrame);
                        }, maxt);
                    }
                    if (nodeData.rotationZ) {
                        this.vizGraph.graphF('blue', function (t) {
                            var animFrame = getAnimFrame(_this.chr0, t + offt);
                            return sampleFloatAnimationTrack(nodeData.rotationZ, animFrame);
                        }, maxt);
                    }
                    // const xa = (animFrame / numFrames) * ctx.canvas.width;
                    var xa = (0.5) * ctx.canvas.width;
                    ctx.beginPath();
                    ctx.strokeStyle = 'black';
                    ctx.lineTo(xa, 0);
                    ctx.lineTo(xa, ctx.canvas.height);
                    ctx.stroke();
                };
                CHR0NodesAnimator.prototype.calcModelMtx = function (dst, nodeId) {
                    var nodeData = this.nodeData[nodeId];
                    if (!nodeData)
                        return false;
                    if (this.disabled[nodeId])
                        return false;
                    var frame = this.animationController.getTimeInFrames();
                    var animFrame = getAnimFrame(this.chr0, frame);
                    if (this.vizNodeId === nodeId)
                        this.updviz(animFrame, nodeData);
                    var scaleX = nodeData.scaleX ? sampleFloatAnimationTrack(nodeData.scaleX, animFrame) : 1;
                    var scaleY = nodeData.scaleY ? sampleFloatAnimationTrack(nodeData.scaleY, animFrame) : 1;
                    var scaleZ = nodeData.scaleZ ? sampleFloatAnimationTrack(nodeData.scaleZ, animFrame) : 1;
                    var rotationX = nodeData.rotationX ? sampleFloatAnimationTrack(nodeData.rotationX, animFrame) : 0;
                    var rotationY = nodeData.rotationY ? sampleFloatAnimationTrack(nodeData.rotationY, animFrame) : 0;
                    var rotationZ = nodeData.rotationZ ? sampleFloatAnimationTrack(nodeData.rotationZ, animFrame) : 0;
                    var translationX = nodeData.translationX ? sampleFloatAnimationTrack(nodeData.translationX, animFrame) : 0;
                    var translationY = nodeData.translationY ? sampleFloatAnimationTrack(nodeData.translationY, animFrame) : 0;
                    var translationZ = nodeData.translationZ ? sampleFloatAnimationTrack(nodeData.translationZ, animFrame) : 0;
                    calcModelMtx(dst, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ, translationX, translationY, translationZ);
                    return true;
                };
                return CHR0NodesAnimator;
            }());
            exports_80("CHR0NodesAnimator", CHR0NodesAnimator);
        }
    };
});
// Nintendo "U8" filesystem archives.
// http://wiki.tockdom.com/wiki/U8_(File_Format)
// http://wiibrew.org/wiki/U8_archive
System.register("rres/u8", ["util"], function (exports_81, context_81) {
    "use strict";
    var __moduleName = context_81 && context_81.id;
    function parse(buffer) {
        var view = buffer.createDataView();
        util_51.assert(util_51.readString(buffer, 0x00, 0x04) === '\x55\xAA\x38\x2D');
        var tocOffs = view.getUint32(0x04, false);
        var headerSize = view.getUint32(0x08, false);
        // Pointer to data -- unused.
        var dataOffs = view.getUint32(0x0C, false);
        // Read root node to find string table.
        var NodeType;
        (function (NodeType) {
            NodeType[NodeType["File"] = 0] = "File";
            NodeType[NodeType["Directory"] = 1] = "Directory";
        })(NodeType || (NodeType = {}));
        var rootNodeType = view.getUint8(tocOffs + 0x00);
        util_51.assert(rootNodeType === NodeType.Directory);
        var rootNodeChildCount = view.getUint32(tocOffs + 0x08, false);
        var stringTableOffs = tocOffs + (rootNodeChildCount * 0x0C);
        function readNode(nodeIndex, parentIndex) {
            var nodeOffs = tocOffs + (nodeIndex * 0x0C);
            var nodeType = view.getUint8(nodeOffs + 0x00);
            var nodeNameOffs = view.getUint32(nodeOffs + 0x00) & 0x00FFFFFF;
            var nodeName = util_51.readString(buffer, stringTableOffs + nodeNameOffs);
            if (nodeType === NodeType.Directory) {
                var nodeParentIndex = view.getUint32(nodeOffs + 0x04, false);
                util_51.assert(nodeParentIndex === parentIndex);
                // The index of the first node *not* in this directory.
                var nextNodeIndex = view.getUint32(nodeOffs + 0x08, false);
                // Recurse.
                var files = [];
                var subdirs = [];
                for (var i = nodeIndex + 1; i < nextNodeIndex;) {
                    var subNode = readNode(i, nodeIndex);
                    if (subNode.kind === 'directory') {
                        subdirs.push(subNode);
                        i = subNode.nextNodeIndex;
                    }
                    else {
                        files.push(subNode);
                        i++;
                    }
                }
                return { kind: 'directory', name: nodeName, files: files, subdirs: subdirs, nextNodeIndex: nextNodeIndex };
            }
            else if (nodeType === NodeType.File) {
                var nodeDataBegin = view.getUint32(nodeOffs + 0x04, false);
                var nodeDataSize = view.getUint32(nodeOffs + 0x08, false);
                var nodeBuffer = buffer.subarray(nodeDataBegin, nodeDataSize);
                return { kind: 'file', name: nodeName, buffer: nodeBuffer };
            }
            else {
                throw "whoops";
            }
        }
        // Root node (0) has parent index 0...
        var rootNode = readNode(0, 0);
        util_51.assert(rootNode.kind === 'directory');
        var archive = new U8Archive();
        archive.root = rootNode;
        return archive;
    }
    exports_81("parse", parse);
    var util_51, U8Archive;
    return {
        setters: [
            function (util_51_1) {
                util_51 = util_51_1;
            }
        ],
        execute: function () {
            U8Archive = /** @class */ (function () {
                function U8Archive() {
                }
                U8Archive.prototype.findDirParts = function (parts) {
                    var dir = this.root;
                    var _loop_15 = function (part) {
                        dir = dir.subdirs.find(function (subdir) { return subdir.name === part; });
                        if (dir === undefined)
                            return { value: null };
                    };
                    try {
                        for (var parts_2 = __values(parts), parts_2_1 = parts_2.next(); !parts_2_1.done; parts_2_1 = parts_2.next()) {
                            var part = parts_2_1.value;
                            var state_3 = _loop_15(part);
                            if (typeof state_3 === "object")
                                return state_3.value;
                        }
                    }
                    catch (e_77_1) { e_77 = { error: e_77_1 }; }
                    finally {
                        try {
                            if (parts_2_1 && !parts_2_1.done && (_a = parts_2.return)) _a.call(parts_2);
                        }
                        finally { if (e_77) throw e_77.error; }
                    }
                    return dir;
                    var e_77, _a;
                };
                U8Archive.prototype.findDir = function (path) {
                    return this.findDirParts(path.split('/'));
                };
                U8Archive.prototype.findFile = function (path) {
                    var parts = path.split('/');
                    var filename = parts.pop();
                    var dir = this.findDirParts(parts);
                    if (dir === null)
                        return null;
                    var file = dir.files.find(function (file) { return file.name === filename; });
                    if (!file)
                        return null;
                    return file;
                };
                return U8Archive;
            }());
            exports_81("U8Archive", U8Archive);
        }
    };
});
// Skyward Sword
System.register("rres/zss_scenes", ["ui", "compression/CX", "rres/brres", "rres/u8", "util", "Progressable", "render", "rres/render", "gx/gx_material", "gl-matrix", "j3d/render"], function (exports_82, context_82) {
    "use strict";
    var __moduleName = context_82 && context_82.id;
    var UI, CX, BRRES, U8, util_52, Progressable_10, render_32, render_33, gx_material_4, gl_matrix_21, render_34, SAND_CLOCK_ICON, materialHacks, ModelArchiveCollection, SkywardSwordScene, SkywardSwordSceneDesc, id, name, sceneDescs, sceneGroup;
    return {
        setters: [
            function (UI_7) {
                UI = UI_7;
            },
            function (CX_2) {
                CX = CX_2;
            },
            function (BRRES_2) {
                BRRES = BRRES_2;
            },
            function (U8_1) {
                U8 = U8_1;
            },
            function (util_52_1) {
                util_52 = util_52_1;
            },
            function (Progressable_10_1) {
                Progressable_10 = Progressable_10_1;
            },
            function (render_32_1) {
                render_32 = render_32_1;
            },
            function (render_33_1) {
                render_33 = render_33_1;
            },
            function (gx_material_4_1) {
                gx_material_4 = gx_material_4_1;
            },
            function (gl_matrix_21_1) {
                gl_matrix_21 = gl_matrix_21_1;
            },
            function (render_34_1) {
                render_34 = render_34_1;
            }
        ],
        execute: function () {
            SAND_CLOCK_ICON = '<svg viewBox="0 0 100 100" height="20" fill="white"><g><path d="M79.3,83.3h-6.2H24.9h-6.2c-1.7,0-3,1.3-3,3s1.3,3,3,3h60.6c1.7,0,3-1.3,3-3S81,83.3,79.3,83.3z"/><path d="M18.7,14.7h6.2h48.2h6.2c1.7,0,3-1.3,3-3s-1.3-3-3-3H18.7c-1.7,0-3,1.3-3,3S17,14.7,18.7,14.7z"/><path d="M73.1,66c0-0.9-0.4-1.8-1.1-2.4L52.8,48.5L72,33.4c0.7-0.6,1.1-1.4,1.1-2.4V20.7H24.9V31c0,0.9,0.4,1.8,1.1,2.4l19.1,15.1   L26,63.6c-0.7,0.6-1.1,1.4-1.1,2.4v11.3h48.2V66z"/></g></svg>';
            materialHacks = {
                colorLightingFudge: function (p) { return "0.5 * " + p.matSource; },
                alphaLightingFudge: function (p) { return "1.0"; },
            };
            ModelArchiveCollection = /** @class */ (function () {
                function ModelArchiveCollection() {
                    this.search = [];
                    this.loaded = new Map();
                }
                ModelArchiveCollection.prototype.addSearchPath = function (archive) {
                    this.search.push(archive);
                };
                ModelArchiveCollection.prototype.findFile = function (path) {
                    try {
                        for (var _a = __values(this.search), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var archive = _b.value;
                            var file = archive.findFile(path);
                            if (file)
                                return file;
                        }
                    }
                    catch (e_78_1) { e_78 = { error: e_78_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_78) throw e_78.error; }
                    }
                    return null;
                    var e_78, _c;
                };
                ModelArchiveCollection.prototype.loadRRESFromArc = function (gl, textureHolder, path) {
                    if (this.loaded.has(path))
                        return this.loaded.get(path);
                    var file = util_52.assertExists(this.findFile(path));
                    var arch = U8.parse(file.buffer);
                    var rres = BRRES.parse(arch.findFile('g3d/model.brres').buffer);
                    textureHolder.addRRESTextures(gl, rres);
                    this.loaded.set(path, rres);
                    return rres;
                };
                return ModelArchiveCollection;
            }());
            SkywardSwordScene = /** @class */ (function () {
                function SkywardSwordScene(gl, stageId, systemArchive, objPackArchive, stageArchive) {
                    this.stageId = stageId;
                    this.systemArchive = systemArchive;
                    this.objPackArchive = objPackArchive;
                    this.stageArchive = stageArchive;
                    this.mainColorTarget = new render_32.ColorTarget();
                    this.stageBZS = null;
                    this.roomBZSes = [];
                    this.oarcCollection = new ModelArchiveCollection();
                    this.models = [];
                    // Uses WaterDummy. Have to render after everything else. TODO(jstpierre): How does engine know this?
                    this.indirectModels = [];
                    // Skybox is rendered specially...
                    this.vrboxModel = null;
                    this.textureHolder = new render_33.RRESTextureHolder();
                    this.animationController = new BRRES.AnimationController();
                    this.textures = this.textureHolder.viewerTextures;
                    this.oarcCollection.addSearchPath(this.stageArchive);
                    this.oarcCollection.addSearchPath(this.objPackArchive);
                    var systemRRES = BRRES.parse(systemArchive.findFile('g3d/model.brres').buffer);
                    this.textureHolder.addRRESTextures(gl, systemRRES);
                    var needsSkyCmn = this.stageId.startsWith('F0') || this.stageId === 'F406';
                    if (needsSkyCmn)
                        this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, 'oarc/SkyCmn.arc');
                    // Water animations appear in Common.arc.
                    this.commonRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, 'oarc/Common.arc');
                    // Load stage.
                    this.stageRRES = BRRES.parse(stageArchive.findFile('g3d/stage.brres').buffer);
                    this.textureHolder.addRRESTextures(gl, this.stageRRES);
                    this.stageBZS = this.parseBZS(stageArchive.findFile('dat/stage.bzs').buffer);
                    var stageLayout = this.stageBZS.layouts[0];
                    this.spawnLayout(gl, stageLayout);
                    // Load rooms.
                    var roomArchivesDir = stageArchive.findDir('rarc');
                    if (roomArchivesDir) {
                        try {
                            for (var _a = __values(roomArchivesDir.files), _b = _a.next(); !_b.done; _b = _a.next()) {
                                var roomArchiveFile = _b.value;
                                var roomArchive = U8.parse(roomArchiveFile.buffer);
                                var roomRRES = BRRES.parse(roomArchive.findFile('g3d/room.brres').buffer);
                                this.textureHolder.addRRESTextures(gl, roomRRES);
                                try {
                                    for (var _c = __values(roomRRES.mdl0), _d = _c.next(); !_d.done; _d = _c.next()) {
                                        var mdl0 = _d.value;
                                        this.spawnModel(gl, mdl0, roomRRES, roomArchiveFile.name);
                                    }
                                }
                                catch (e_79_1) { e_79 = { error: e_79_1 }; }
                                finally {
                                    try {
                                        if (_d && !_d.done && (_e = _c.return)) _e.call(_c);
                                    }
                                    finally { if (e_79) throw e_79.error; }
                                }
                                var roomBZS = this.parseBZS(roomArchive.findFile('dat/room.bzs').buffer);
                                this.roomBZSes.push(roomBZS);
                                var layout = roomBZS.layouts[0];
                                this.spawnLayout(gl, layout);
                            }
                        }
                        catch (e_80_1) { e_80 = { error: e_80_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_f = _a.return)) _f.call(_a);
                            }
                            finally { if (e_80) throw e_80.error; }
                        }
                    }
                    try {
                        outer: 
                        // Find any indirect scenes.
                        for (var _g = __values(this.models), _h = _g.next(); !_h.done; _h = _g.next()) {
                            var modelRenderer = _h.value;
                            try {
                                for (var _j = __values(modelRenderer.mdl0.materials), _k = _j.next(); !_k.done; _k = _j.next()) {
                                    var material = _k.value;
                                    try {
                                        for (var _l = __values(material.samplers), _m = _l.next(); !_m.done; _m = _l.next()) {
                                            var sampler = _m.value;
                                            if (sampler.name === 'DummyWater') {
                                                this.indirectModels.push(modelRenderer);
                                                continue outer;
                                            }
                                        }
                                    }
                                    catch (e_81_1) { e_81 = { error: e_81_1 }; }
                                    finally {
                                        try {
                                            if (_m && !_m.done && (_o = _l.return)) _o.call(_l);
                                        }
                                        finally { if (e_81) throw e_81.error; }
                                    }
                                }
                            }
                            catch (e_82_1) { e_82 = { error: e_82_1 }; }
                            finally {
                                try {
                                    if (_k && !_k.done && (_p = _j.return)) _p.call(_j);
                                }
                                finally { if (e_82) throw e_82.error; }
                            }
                        }
                    }
                    catch (e_83_1) { e_83 = { error: e_83_1 }; }
                    finally {
                        try {
                            if (_h && !_h.done && (_q = _g.return)) _q.call(_g);
                        }
                        finally { if (e_83) throw e_83.error; }
                    }
                    var e_80, _f, e_79, _e, e_83, _q, e_82, _p, e_81, _o;
                }
                SkywardSwordScene.prototype.createPanels = function () {
                    var panels = [];
                    var layersPanel = new UI.LayerPanel();
                    layersPanel.setLayers(this.models);
                    panels.push(layersPanel);
                    // Construct a list of past/future models.
                    var futureModels = [];
                    var pastModels = [];
                    try {
                        for (var _a = __values(this.models), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var modelRenderer = _b.value;
                            if (modelRenderer.mdl0.name.startsWith('model_obj'))
                                futureModels.push(modelRenderer);
                            // Lanayru Sand Sea has a "past" decal on top of a future zone.
                            if (this.stageId === 'F301_1' && modelRenderer.mdl0.name === 'model1_s')
                                pastModels.push(modelRenderer);
                        }
                    }
                    catch (e_84_1) { e_84 = { error: e_84_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_84) throw e_84.error; }
                    }
                    if (futureModels.length || pastModels.length) {
                        var futurePanel = new UI.Panel();
                        futurePanel.setTitle(SAND_CLOCK_ICON, "Time Stones");
                        var selector = new UI.SimpleSingleSelect();
                        selector.setStrings(['Past', 'Future']);
                        selector.onselectionchange = function (index) {
                            var isFuture = (index === 1);
                            try {
                                for (var futureModels_1 = __values(futureModels), futureModels_1_1 = futureModels_1.next(); !futureModels_1_1.done; futureModels_1_1 = futureModels_1.next()) {
                                    var modelRenderer = futureModels_1_1.value;
                                    modelRenderer.setVisible(isFuture);
                                }
                            }
                            catch (e_85_1) { e_85 = { error: e_85_1 }; }
                            finally {
                                try {
                                    if (futureModels_1_1 && !futureModels_1_1.done && (_a = futureModels_1.return)) _a.call(futureModels_1);
                                }
                                finally { if (e_85) throw e_85.error; }
                            }
                            try {
                                for (var pastModels_1 = __values(pastModels), pastModels_1_1 = pastModels_1.next(); !pastModels_1_1.done; pastModels_1_1 = pastModels_1.next()) {
                                    var modelRenderer = pastModels_1_1.value;
                                    modelRenderer.setVisible(!isFuture);
                                }
                            }
                            catch (e_86_1) { e_86 = { error: e_86_1 }; }
                            finally {
                                try {
                                    if (pastModels_1_1 && !pastModels_1_1.done && (_b = pastModels_1.return)) _b.call(pastModels_1);
                                }
                                finally { if (e_86) throw e_86.error; }
                            }
                            layersPanel.syncLayerVisibility();
                            var e_85, _a, e_86, _b;
                        };
                        selector.selectItem(0); // Past
                        futurePanel.contents.appendChild(selector.elem);
                        panels.push(futurePanel);
                    }
                    return panels;
                    var e_84, _c;
                };
                SkywardSwordScene.prototype.destroy = function (gl) {
                    this.textureHolder.destroy(gl);
                    this.models.forEach(function (model) { return model.destroy(gl); });
                };
                SkywardSwordScene.prototype.render = function (state) {
                    var _this = this;
                    var gl = state.gl;
                    this.animationController.updateTime(state.time);
                    this.mainColorTarget.setParameters(gl, state.onscreenColorTarget.width, state.onscreenColorTarget.height);
                    state.useRenderTarget(this.mainColorTarget);
                    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
                    // Skybox is rendered first. Also, use larger clip planes for the skybox, since it's so large.
                    // The actual game probably renders this with a different reference camera..
                    state.setClipPlanes(10, 90000000);
                    if (this.vrboxModel) {
                        this.vrboxModel.render(state);
                    }
                    state.useFlags(render_32.depthClearFlags);
                    gl.clear(gl.DEPTH_BUFFER_BIT);
                    state.setClipPlanes(10, 500000);
                    this.models.forEach(function (model) {
                        if (_this.indirectModels.includes(model))
                            return;
                        model.render(state);
                    });
                    // Copy to main render target.
                    state.useRenderTarget(state.onscreenColorTarget);
                    state.blitColorTarget(this.mainColorTarget);
                    if (this.indirectModels.length) {
                        var textureOverride = { glTexture: this.mainColorTarget.resolvedColorTexture, width: gx_material_4.EFB_WIDTH, height: gx_material_4.EFB_HEIGHT, flipY: true };
                        this.textureHolder.setTextureOverride("DummyWater", textureOverride);
                    }
                    this.indirectModels.forEach(function (modelRenderer) {
                        modelRenderer.render(state);
                    });
                };
                SkywardSwordScene.prototype.spawnModel = function (gl, mdl0, rres, namePrefix) {
                    var modelRenderer = new render_33.ModelRenderer(gl, this.textureHolder, mdl0, namePrefix, materialHacks);
                    this.models.push(modelRenderer);
                    try {
                        // Bind animations.
                        for (var _a = __values(rres.srt0), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var srt0 = _b.value;
                            modelRenderer.bindSRT0(this.animationController, srt0);
                        }
                    }
                    catch (e_87_1) { e_87 = { error: e_87_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_87) throw e_87.error; }
                    }
                    try {
                        // Water animations are in the common archive.
                        for (var _d = __values(this.commonRRES.srt0), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var srt0 = _e.value;
                            modelRenderer.bindSRT0(this.animationController, srt0);
                        }
                    }
                    catch (e_88_1) { e_88 = { error: e_88_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                        }
                        finally { if (e_88) throw e_88.error; }
                    }
                    return modelRenderer;
                    var e_87, _c, e_88, _f;
                };
                SkywardSwordScene.prototype.spawnModelName = function (gl, rres, modelName, namePrefix) {
                    var mdl0 = rres.mdl0.find(function (model) { return model.name === modelName; });
                    return this.spawnModel(gl, mdl0, rres, namePrefix);
                };
                SkywardSwordScene.prototype.spawnObj = function (gl, name, unk1, unk2) {
                    // In the actual engine, each obj is handled by a separate .rel (runtime module)
                    // which knows the actual layout. The mapping of obj name to .rel is stored in main.dol.
                    // We emulate that here.
                    var models = [];
                    if (name === 'CityWtr') {
                        // For City Water, we spawn three objects, the second one being an indirect object.
                        models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Water0', name));
                        models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Water1', name));
                        models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Water2', name));
                    }
                    else if (name === 'Grave') {
                        models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Grave', name));
                    }
                    else if (name === 'Shed') {
                        // Door to Batreaux's lair
                        models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Shed', name));
                    }
                    else if (name === 'Windmil') {
                        var model = this.spawnModelName(gl, this.stageRRES, 'StageF000Windmill', name);
                        var StageF000WindmillCHR0 = this.stageRRES.chr0.find(function (c) { return c.name === 'StageF000Windmill'; });
                        model.bindCHR0(this.animationController, StageF000WindmillCHR0);
                        models.push(model);
                    }
                    else if (name === 'Blade') {
                        // Skyloft decorations... flags, pinwheels, etc.
                        var model = this.spawnModelName(gl, this.stageRRES, 'StageF000Blade', name);
                        var StageF000BladeCHR0 = this.stageRRES.chr0.find(function (c) { return c.name === 'StageF000Blade'; });
                        model.bindCHR0(this.animationController, StageF000BladeCHR0);
                        models.push(model);
                    }
                    else if (name === 'LHHarp') {
                        // "Lighthouse Harp"
                        models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Harp', name));
                    }
                    else if (name === 'LHLight') {
                        // "Lighthouse Light"
                        models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Light', name));
                    }
                    else if (name === 'Heartf') {
                        var FlowerHeartRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, 'oarc/FlowerHeart.arc');
                        models.push(this.spawnModelName(gl, FlowerHeartRRES, 'FlowerHeart', name));
                    }
                    else if (name === 'Pumpkin') {
                        var PumpkinRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, 'oarc/Pumpkin.arc');
                        models.push(this.spawnModelName(gl, PumpkinRRES, 'Pumpkin', name));
                    }
                    else if (name === 'DmtGate') {
                        // "Dormitory Gate"
                        // Seems it can also use StageF400Gate, probably when Skyloft crashes to the ground (spoilers).
                        // Seems to make two of them... skip for now, not that important...
                    }
                    else if (name === 'IslLOD') {
                        // First parameter appears to contain the island LOD to load...
                        var islId = unk1 & 0x0F;
                        var islName = ['IslLODA', 'IslLODB', 'IslLODC', 'IslLODD', 'IslLODE'][islId];
                        var IslLODRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/" + islName + ".arc");
                        var model = this.spawnModelName(gl, IslLODRRES, islName, name);
                        models.push(model);
                    }
                    else if (name === 'ClawSTg') {
                        // Clawshot Target
                        var ShotMarkRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/ShotMark.arc");
                        models.push(this.spawnModelName(gl, ShotMarkRRES, 'ShotMark', name));
                    }
                    else if (name === 'Vrbox') {
                        // First parameter appears to contain the Vrbox to load.
                        var boxId = unk1 & 0x0F;
                        var boxName = ['Vrbox00', 'Vrbox01', 'Vrbox02', 'Vrbox03'][boxId];
                        var VrboxRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/" + boxName + ".arc");
                        var model = this.spawnModelName(gl, VrboxRRES, boxName, name);
                        model.isSkybox = true;
                        this.vrboxModel = model;
                        // This color is probably set by the day/night system...
                        model.setColorOverride(render_34.ColorOverride.C2, new gx_material_4.Color(1, 1, 1, 1));
                        model.setColorOverride(render_34.ColorOverride.K3, new gx_material_4.Color(1, 1, 1, 1));
                        models.push(model);
                    }
                    else if (name === 'CmCloud') {
                        // Cumulus Cloud
                        var F020CloudRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/F020Cloud.arc");
                        var model = this.spawnModelName(gl, F020CloudRRES, 'F020Cloud', name);
                        models.push(model);
                    }
                    else if (name === 'UdCloud') {
                        // Under Clouds
                        var F020UnderCloudRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/F020UnderCloud.arc");
                        var model = this.spawnModelName(gl, F020UnderCloudRRES, 'F020UnderCloud', name);
                        models.push(model);
                    }
                    else if (name === 'ObjBld') {
                        // Object Building. Appears to only be used for the dowsing station? Why?
                        var DowsingZoneE300RRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/DowsingZoneE300.arc");
                        models.push(this.spawnModelName(gl, DowsingZoneE300RRES, 'DowsingZoneE300', name));
                    }
                    else if (name === 'WtrF100') {
                        var WaterF100RRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/WaterF100.arc");
                        models.push(this.spawnModelName(gl, WaterF100RRES, 'model0', name));
                        models.push(this.spawnModelName(gl, WaterF100RRES, 'model1', name));
                        models.push(this.spawnModelName(gl, WaterF100RRES, 'model2', name));
                        models.push(this.spawnModelName(gl, WaterF100RRES, 'model3', name));
                    }
                    else if (name === 'GodCube') {
                        var GoddessCubeRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/GoddessCube.arc");
                        models.push(this.spawnModelName(gl, GoddessCubeRRES, 'GoddessCube', name));
                    }
                    else if (name === 'LavF200') {
                        var LavaF200RRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/LavaF200.arc");
                        models.push(this.spawnModelName(gl, LavaF200RRES, 'LavaF200', name));
                    }
                    else if (name === 'UDLava') {
                        var UpdwnLavaRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/UpdwnLava.arc");
                        models.push(this.spawnModelName(gl, UpdwnLavaRRES, 'UpdwnLavaA', name));
                        models.push(this.spawnModelName(gl, UpdwnLavaRRES, 'UpdwnLavaB', name));
                        models.push(this.spawnModelName(gl, UpdwnLavaRRES, 'UpdwnLavaC', name));
                    }
                    else {
                        console.log("Unknown object", name);
                    }
                    return models;
                };
                SkywardSwordScene.prototype.spawnLayout = function (gl, layout) {
                    var q = gl_matrix_21.quat.create();
                    try {
                        for (var _a = __values(layout.obj), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var obj = _b.value;
                            var models = this.spawnObj(gl, obj.name, obj.unk1, obj.unk2);
                            // Set model matrix.
                            var rotationX = 180 * (obj.rotX / 0x7FFF);
                            var rotationY = 180 * (obj.rotY / 0x7FFF);
                            gl_matrix_21.quat.fromEuler(q, rotationX, rotationY, 0);
                            try {
                                for (var models_1 = __values(models), models_1_1 = models_1.next(); !models_1_1.done; models_1_1 = models_1.next()) {
                                    var modelRenderer = models_1_1.value;
                                    gl_matrix_21.mat4.fromRotationTranslation(modelRenderer.modelMatrix, q, [obj.tx, obj.ty, obj.tz]);
                                }
                            }
                            catch (e_89_1) { e_89 = { error: e_89_1 }; }
                            finally {
                                try {
                                    if (models_1_1 && !models_1_1.done && (_c = models_1.return)) _c.call(models_1);
                                }
                                finally { if (e_89) throw e_89.error; }
                            }
                        }
                    }
                    catch (e_90_1) { e_90 = { error: e_90_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                        }
                        finally { if (e_90) throw e_90.error; }
                    }
                    try {
                        // Now do scalable objects...
                        for (var _e = __values(layout.sobj), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var obj = _f.value;
                            var models = this.spawnObj(gl, obj.name, obj.unk1, obj.unk2);
                            // Set model matrix.
                            var rotation = 180 * (obj.rotY / 0x7FFF);
                            gl_matrix_21.quat.fromEuler(q, 0, rotation, 0);
                            try {
                                for (var models_2 = __values(models), models_2_1 = models_2.next(); !models_2_1.done; models_2_1 = models_2.next()) {
                                    var modelRenderer = models_2_1.value;
                                    gl_matrix_21.mat4.fromRotationTranslationScale(modelRenderer.modelMatrix, q, [obj.tx, obj.ty, obj.tz], [obj.sx, obj.sy, obj.sz]);
                                }
                            }
                            catch (e_91_1) { e_91 = { error: e_91_1 }; }
                            finally {
                                try {
                                    if (models_2_1 && !models_2_1.done && (_g = models_2.return)) _g.call(models_2);
                                }
                                finally { if (e_91) throw e_91.error; }
                            }
                        }
                    }
                    catch (e_92_1) { e_92 = { error: e_92_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_h = _e.return)) _h.call(_e);
                        }
                        finally { if (e_92) throw e_92.error; }
                    }
                    var e_90, _d, e_89, _c, e_92, _h, e_91, _g;
                };
                SkywardSwordScene.prototype.parseBZS = function (buffer) {
                    var view = buffer.createDataView();
                    function parseChunkTable(tableOffs, count) {
                        var chunks = [];
                        var tableIdx = tableOffs;
                        for (var i = 0; i < count; i++) {
                            var name_17 = util_52.readString(buffer, tableIdx + 0x00, 0x04, false);
                            var count_1 = view.getUint16(tableIdx + 0x04);
                            // pad
                            // offs is relative to this entry.
                            var offs = tableIdx + view.getUint32(tableIdx + 0x08);
                            chunks.push({ name: name_17, count: count_1, offs: offs });
                            tableIdx += 0x0C;
                        }
                        return chunks;
                    }
                    // Header.
                    var headerChunkTable = parseChunkTable(0x00, 0x01);
                    util_52.assert(headerChunkTable.length === 1);
                    var v001 = headerChunkTable[0];
                    util_52.assert(v001.name === 'V001' && v001.offs === 0x0C);
                    var roomChunkTable = parseChunkTable(v001.offs, v001.count);
                    function parseObj(offs) {
                        var unk1 = view.getUint32(offs + 0x00);
                        var unk2 = view.getUint32(offs + 0x04);
                        var tx = view.getFloat32(offs + 0x08);
                        var ty = view.getFloat32(offs + 0x0C);
                        var tz = view.getFloat32(offs + 0x10);
                        var rotX = view.getInt16(offs + 0x14);
                        var rotY = view.getInt16(offs + 0x16);
                        var unk4 = view.getInt16(offs + 0x18);
                        var unk5 = view.getUint8(offs + 0x1A);
                        var unk6 = view.getUint8(offs + 0x1B);
                        var name = util_52.readString(buffer, offs + 0x1C, 0x08, true);
                        return { unk1: unk1, unk2: unk2, tx: tx, ty: ty, tz: tz, rotX: rotX, rotY: rotY, unk4: unk4, unk5: unk5, unk6: unk6, name: name };
                    }
                    function parseSobj(offs) {
                        var unk1 = view.getUint32(offs + 0x00);
                        var unk2 = view.getUint32(offs + 0x04);
                        var tx = view.getFloat32(offs + 0x08);
                        var ty = view.getFloat32(offs + 0x0C);
                        var tz = view.getFloat32(offs + 0x10);
                        var sx = view.getFloat32(offs + 0x14);
                        var sy = view.getFloat32(offs + 0x18);
                        var sz = view.getFloat32(offs + 0x1C);
                        var rotY = view.getInt16(offs + 0x20);
                        var unk4 = view.getUint16(offs + 0x22);
                        var unk5 = view.getUint8(offs + 0x26);
                        var unk6 = view.getUint8(offs + 0x27);
                        var name = util_52.readString(buffer, offs + 0x28, 0x08, true);
                        return { unk1: unk1, unk2: unk2, tx: tx, ty: ty, tz: tz, sx: sx, sy: sy, sz: sz, rotY: rotY, unk4: unk4, unk5: unk5, unk6: unk6, name: name };
                    }
                    var layoutsChunk = roomChunkTable.find(function (chunk) { return chunk.name === 'LAY '; });
                    // Parse layouts table.
                    function parseLayout(index) {
                        var layoutsTableIdx = layoutsChunk.offs + (index * 0x08);
                        var layoutChunkTableCount = view.getUint16(layoutsTableIdx + 0x00);
                        // pad
                        var layoutChunkTableOffs = layoutsTableIdx + view.getUint32(layoutsTableIdx + 0x04);
                        var layoutChunkTable = parseChunkTable(layoutChunkTableOffs, layoutChunkTableCount);
                        // Look for objects table.
                        var obj = [];
                        var objChunk = layoutChunkTable.find(function (chunk) { return chunk.name === 'OBJ '; });
                        if (objChunk)
                            for (var i = 0; i < objChunk.count; i++)
                                obj.push(parseObj(objChunk.offs + i * 0x24));
                        var sobj = [];
                        var sobjChunk = layoutChunkTable.find(function (chunk) { return chunk.name === 'SOBJ'; });
                        if (sobjChunk)
                            for (var i = 0; i < sobjChunk.count; i++)
                                sobj.push(parseSobj(sobjChunk.offs + i * 0x30));
                        var stagChunk = layoutChunkTable.find(function (chunk) { return chunk.name === 'STAG'; });
                        if (stagChunk)
                            for (var i = 0; i < stagChunk.count; i++)
                                sobj.push(parseSobj(stagChunk.offs + i * 0x30));
                        return { obj: obj, sobj: sobj };
                    }
                    var layouts = [];
                    layouts.push(parseLayout(0));
                    return { layouts: layouts };
                };
                return SkywardSwordScene;
            }());
            SkywardSwordSceneDesc = /** @class */ (function () {
                function SkywardSwordSceneDesc(id, name) {
                    this.id = id;
                    this.name = name;
                }
                SkywardSwordSceneDesc.prototype.createScene = function (gl) {
                    var _this = this;
                    var basePath = "data/zss";
                    var systemPath = basePath + "/System.arc";
                    var objPackPath = basePath + "/ObjectPack.arc.LZ";
                    var stagePath = basePath + "/" + this.id + "_stg_l0.arc.LZ";
                    return Progressable_10.default.all([util_52.fetch(systemPath), util_52.fetch(objPackPath), util_52.fetch(stagePath)]).then(function (buffers) {
                        var _a = __read(buffers, 3), systemBuffer = _a[0], objPackBuffer = _a[1], stageBuffer = _a[2];
                        var commonRRESes = [];
                        var systemArchive = U8.parse(systemBuffer);
                        var objPackArchive = U8.parse(CX.decompress(objPackBuffer));
                        var stageArchive = U8.parse(CX.decompress(stageBuffer));
                        return new SkywardSwordScene(gl, _this.id, systemArchive, objPackArchive, stageArchive);
                    });
                };
                return SkywardSwordSceneDesc;
            }());
            id = "zss";
            name = "The Legend of Zelda: Skyward Sword";
            sceneDescs = [
                new SkywardSwordSceneDesc("D100", "Skyview Temple"),
                new SkywardSwordSceneDesc("D101", "Ancient Cistern"),
                new SkywardSwordSceneDesc("D200", "Earth Temple"),
                new SkywardSwordSceneDesc("D201", "Fire Sanctuary (A)"),
                new SkywardSwordSceneDesc("D201_1", "Fire Sanctuary (B)"),
                new SkywardSwordSceneDesc("D300", "Lanayru Mining Facility (A)"),
                new SkywardSwordSceneDesc("D300_1", "Lanayru Mining Facility (B)"),
                new SkywardSwordSceneDesc("D301", "Sandship"),
                new SkywardSwordSceneDesc("F000", "Skyloft"),
                new SkywardSwordSceneDesc("F001r", "Skyloft - Knight's Academy"),
                new SkywardSwordSceneDesc("D000", "Skyloft - Waterfall Cave"),
                new SkywardSwordSceneDesc("F100", "Faron Woods"),
                new SkywardSwordSceneDesc("F100_1", "Faron Woods - Inside the Great Tree"),
                new SkywardSwordSceneDesc("F101", "Faron Woods - Deep Woods"),
                new SkywardSwordSceneDesc("F102", "Faron Woods - Lake Floria"),
                new SkywardSwordSceneDesc("F102_1", "Faron Woods - Outside Skyview Temple"),
                new SkywardSwordSceneDesc("F102_2", "Faron Woods - Faron's Lair"),
                new SkywardSwordSceneDesc("F103", "Faron Woods (Flooded)"),
                new SkywardSwordSceneDesc("F200", "Eldin Volcano"),
                new SkywardSwordSceneDesc("F201_1", "Eldin Volcano - Inside Volcano"),
                new SkywardSwordSceneDesc("F201_3", "Eldin Volcano - Fire Sanctuary Entrance"),
                new SkywardSwordSceneDesc("F201_4", "Eldin Volcano - Volcano Summit - Waterfall"),
                new SkywardSwordSceneDesc("F202_1", "Eldin Volcano - Despacito 202_1"),
                new SkywardSwordSceneDesc("F210", "Eldin Volcano - Caves"),
                new SkywardSwordSceneDesc("F211", "Eldin Volcano - Thrill Digger"),
                new SkywardSwordSceneDesc("F221", "Eldin Volcano - Despacito 221"),
                new SkywardSwordSceneDesc("F300", "Lanayru Desert"),
                new SkywardSwordSceneDesc("F300_1", "Lanayru Desert - Ancient Harbor"),
                new SkywardSwordSceneDesc("F300_2", "Lanayru Desert - Lanayru Mine"),
                new SkywardSwordSceneDesc("F300_3", "Lanayru Desert - Power Generator #1"),
                new SkywardSwordSceneDesc("F300_4", "Lanayru Desert - Power Generator #2"),
                new SkywardSwordSceneDesc("F300_5", "Lanayru Desert - Temple of Time"),
                new SkywardSwordSceneDesc("F301", "Lanayru Sand Sea - Docks"),
                new SkywardSwordSceneDesc("F301_1", "Lanayru Sand Sea - The Sea"),
                new SkywardSwordSceneDesc("F301_2", "Lanayru Desert - Pirate Stronghold"),
                new SkywardSwordSceneDesc("F301_3", "Lanayru Desert - Skipper's Retreat"),
                new SkywardSwordSceneDesc("F301_4", "Lanayru Desert - Shipyard"),
                new SkywardSwordSceneDesc("F301_5", "Lanayru Desert - Skipper's Retreat Shack"),
                new SkywardSwordSceneDesc("F301_7", "Lanayru Desert - Shipyard Construction Bay"),
                new SkywardSwordSceneDesc("F302", "Lanayru Desert - Lanayru Gorge"),
                new SkywardSwordSceneDesc("F303", "Lanayru Desert - Lanayru Caves"),
                new SkywardSwordSceneDesc("F400", "Sacred Grounds - Despacito 400"),
                new SkywardSwordSceneDesc("F401", "Sacred Grounds - Despacito 401"),
                new SkywardSwordSceneDesc("F402", "Sacred Grounds - Despacito 402"),
                new SkywardSwordSceneDesc("F403", "Sacred Grounds - Despacito 403"),
                new SkywardSwordSceneDesc("F404", "Sacred Grounds - Despacito 404"),
                new SkywardSwordSceneDesc("F405", "Sacred Grounds - Despacito 405"),
                new SkywardSwordSceneDesc("F406", "Sacred Grounds - Despacito 406"),
                new SkywardSwordSceneDesc("F407", "Sacred Grounds - Despacito 407"),
            ];
            exports_82("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
// Elebits
System.register("rres/elb_scenes", ["ui", "rres/brres", "util", "Progressable", "rres/render"], function (exports_83, context_83) {
    "use strict";
    var __moduleName = context_83 && context_83.id;
    function makeElbPath(stg, room) {
        var z = util_53.leftPad('' + room, 2);
        return "data/elb/" + stg + "_" + z + "_disp01.brres";
    }
    function createBasicRRESSceneFromBuffer(gl, buffer) {
        var stageRRES = BRRES.parse(buffer);
        return new BasicRRESScene(gl, [stageRRES]);
    }
    exports_83("createBasicRRESSceneFromBuffer", createBasicRRESSceneFromBuffer);
    function range(start, count) {
        if (start === void 0) { start = 1; }
        if (count === void 0) { count = 18; }
        var L = [];
        for (var i = start; i < start + count; i++)
            L.push(i);
        return L;
    }
    var UI, BRRES, util_53, Progressable_11, render_35, materialHacks, BasicRRESScene, ElebitsSceneDesc, id, name, sceneDescs, sceneGroup;
    return {
        setters: [
            function (UI_8) {
                UI = UI_8;
            },
            function (BRRES_3) {
                BRRES = BRRES_3;
            },
            function (util_53_1) {
                util_53 = util_53_1;
            },
            function (Progressable_11_1) {
                Progressable_11 = Progressable_11_1;
            },
            function (render_35_1) {
                render_35 = render_35_1;
            }
        ],
        execute: function () {
            materialHacks = {
                colorLightingFudge: function (p) { return "" + p.matSource; },
                alphaLightingFudge: function (p) { return '1.0'; },
            };
            BasicRRESScene = /** @class */ (function () {
                function BasicRRESScene(gl, stageRRESes) {
                    this.stageRRESes = stageRRESes;
                    this.models = [];
                    this.textureHolder = new render_35.RRESTextureHolder();
                    this.animationController = new BRRES.AnimationController();
                    this.textures = this.textureHolder.viewerTextures;
                    try {
                        for (var stageRRESes_1 = __values(stageRRESes), stageRRESes_1_1 = stageRRESes_1.next(); !stageRRESes_1_1.done; stageRRESes_1_1 = stageRRESes_1.next()) {
                            var stageRRES = stageRRESes_1_1.value;
                            this.textureHolder.addRRESTextures(gl, stageRRES);
                            util_53.assert(stageRRES.mdl0.length === 1);
                            var modelRenderer = new render_35.ModelRenderer(gl, this.textureHolder, stageRRES.mdl0[0], '', materialHacks);
                            this.models.push(modelRenderer);
                            modelRenderer.bindRRESAnimations(this.animationController, stageRRES);
                        }
                    }
                    catch (e_93_1) { e_93 = { error: e_93_1 }; }
                    finally {
                        try {
                            if (stageRRESes_1_1 && !stageRRESes_1_1.done && (_a = stageRRESes_1.return)) _a.call(stageRRESes_1);
                        }
                        finally { if (e_93) throw e_93.error; }
                    }
                    var e_93, _a;
                }
                BasicRRESScene.prototype.createPanels = function () {
                    var panels = [];
                    if (this.models.length > 1) {
                        var layersPanel = new UI.LayerPanel();
                        layersPanel.setLayers(this.models);
                        panels.push(layersPanel);
                    }
                    return panels;
                };
                BasicRRESScene.prototype.destroy = function (gl) {
                    this.textureHolder.destroy(gl);
                    this.models.forEach(function (model) { return model.destroy(gl); });
                };
                BasicRRESScene.prototype.render = function (state) {
                    this.animationController.updateTime(state.time);
                    this.models.forEach(function (model) {
                        model.render(state);
                    });
                };
                return BasicRRESScene;
            }());
            exports_83("BasicRRESScene", BasicRRESScene);
            ElebitsSceneDesc = /** @class */ (function () {
                function ElebitsSceneDesc(id, name, rooms) {
                    this.id = id;
                    this.name = name;
                    this.rooms = rooms;
                }
                ElebitsSceneDesc.prototype.createScene = function (gl) {
                    var _this = this;
                    var paths = this.rooms.map(function (room) { return makeElbPath(_this.id, room); });
                    var progressables = paths.map(function (path) { return util_53.fetch(path); });
                    return Progressable_11.default.all(progressables).then(function (buffers) {
                        var stageRRESes = buffers.map(function (buffer) { return BRRES.parse(buffer); });
                        return new BasicRRESScene(gl, stageRRESes);
                    });
                };
                return ElebitsSceneDesc;
            }());
            id = "elb";
            name = "Elebits";
            sceneDescs = [
                new ElebitsSceneDesc("stg01", "Mom and Dad's House", range(1, 18)),
                new ElebitsSceneDesc("stg03", "The Town", [1]),
                new ElebitsSceneDesc("stg02", "Amusement Park - Main Hub", [1, 5]),
                new ElebitsSceneDesc("stg02", "Amusement Park - Castle", [2]),
                new ElebitsSceneDesc("stg02", "Amusement Park - Entrance", [3, 6]),
                new ElebitsSceneDesc("stg02", "Amusement Park - Space", [4]),
                new ElebitsSceneDesc("stg04", "Tutorial", [1, 2]),
            ];
            exports_83("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
// Mario Kart Wii
System.register("rres/mkwii_scenes", ["rres/brres", "rres/u8", "compression/Yaz0", "util", "gl-matrix", "rres/render", "render"], function (exports_84, context_84) {
    "use strict";
    var __moduleName = context_84 && context_84.id;
    var BRRES, U8, Yaz0, util_54, gl_matrix_22, render_36, render_37, MarioKartRenderer, MarioKartWiiSceneDesc, id, name, sceneDescs, sceneGroup;
    return {
        setters: [
            function (BRRES_4) {
                BRRES = BRRES_4;
            },
            function (U8_2) {
                U8 = U8_2;
            },
            function (Yaz0_6) {
                Yaz0 = Yaz0_6;
            },
            function (util_54_1) {
                util_54 = util_54_1;
            },
            function (gl_matrix_22_1) {
                gl_matrix_22 = gl_matrix_22_1;
            },
            function (render_36_1) {
                render_36 = render_36_1;
            },
            function (render_37_1) {
                render_37 = render_37_1;
            }
        ],
        execute: function () {
            MarioKartRenderer = /** @class */ (function () {
                function MarioKartRenderer(gl, courseRRES, skyboxRRES) {
                    this.courseRRES = courseRRES;
                    this.skyboxRRES = skyboxRRES;
                    this.textureHolder = new render_36.RRESTextureHolder();
                    this.textures = this.textureHolder.viewerTextures;
                    this.animationController = new BRRES.AnimationController();
                    this.textureHolder.addRRESTextures(gl, skyboxRRES);
                    this.textureHolder.addRRESTextures(gl, courseRRES);
                    util_54.assert(skyboxRRES.mdl0.length === 1);
                    this.skyboxRenderer = new render_36.ModelRenderer(gl, this.textureHolder, skyboxRRES.mdl0[0], 'vrbox');
                    this.skyboxRenderer.isSkybox = true;
                    util_54.assert(courseRRES.mdl0.length === 1);
                    this.courseRenderer = new render_36.ModelRenderer(gl, this.textureHolder, courseRRES.mdl0[0], 'course');
                    // Mario Kart Wii courses appear to be very, very big. Scale them down a bit.
                    var scaleFactor = 0.1;
                    gl_matrix_22.mat4.fromScaling(this.courseRenderer.modelMatrix, [scaleFactor, scaleFactor, scaleFactor]);
                    gl_matrix_22.mat4.fromScaling(this.skyboxRenderer.modelMatrix, [scaleFactor, scaleFactor, scaleFactor]);
                    // Bind animations.
                    this.skyboxRenderer.bindRRESAnimations(this.animationController, skyboxRRES);
                    this.courseRenderer.bindRRESAnimations(this.animationController, courseRRES);
                }
                MarioKartRenderer.prototype.destroy = function (gl) {
                    this.textureHolder.destroy(gl);
                };
                MarioKartRenderer.prototype.render = function (state) {
                    var gl = state.gl;
                    this.animationController.updateTime(state.time);
                    this.skyboxRenderer.render(state);
                    state.useFlags(render_37.depthClearFlags);
                    gl.clear(gl.DEPTH_BUFFER_BIT);
                    this.courseRenderer.render(state);
                };
                return MarioKartRenderer;
            }());
            MarioKartWiiSceneDesc = /** @class */ (function () {
                function MarioKartWiiSceneDesc(id, name) {
                    this.id = id;
                    this.name = name;
                }
                MarioKartWiiSceneDesc.prototype.createScene = function (gl) {
                    return util_54.fetch("data/mkwii/" + this.id + ".szs").then(function (buffer) {
                        return Yaz0.decompress(buffer);
                    }).then(function (buffer) {
                        var arch = U8.parse(buffer);
                        var courseRRES = BRRES.parse(arch.findFile('./course_model.brres').buffer);
                        var skyboxRRES = BRRES.parse(arch.findFile('./vrcorn_model.brres').buffer);
                        var scene = new MarioKartRenderer(gl, courseRRES, skyboxRRES);
                        return scene;
                    });
                };
                return MarioKartWiiSceneDesc;
            }());
            id = 'mkwii';
            name = 'Mario Kart Wii';
            sceneDescs = [
                new MarioKartWiiSceneDesc('beginner_course', "Luigi Circuit"),
                new MarioKartWiiSceneDesc('farm_course', "Moo Moo Meadows"),
                new MarioKartWiiSceneDesc('kinoko_course', "Mushroom Gorge"),
                new MarioKartWiiSceneDesc('factory_course', "Toad's Factory"),
                new MarioKartWiiSceneDesc('castle_course', "Mario Circuit"),
                new MarioKartWiiSceneDesc('shopping_course', "Coconut Mall"),
                new MarioKartWiiSceneDesc('boardcross_course', "DK Summit"),
                new MarioKartWiiSceneDesc('truck_course', "Wario's Gold Mine"),
                new MarioKartWiiSceneDesc('senior_course', "Daisy Circuit"),
                new MarioKartWiiSceneDesc('water_course', "Koopa Cape"),
                new MarioKartWiiSceneDesc('treehouse_course', "Maple Treeway"),
                new MarioKartWiiSceneDesc('volcano_course', "Grumble Volcano"),
                new MarioKartWiiSceneDesc('desert_course', "Dry Dry Ruins"),
                new MarioKartWiiSceneDesc('ridgehighway_course', "Moonview Highway"),
                new MarioKartWiiSceneDesc('koopa_course', "Bowser's Castle"),
                new MarioKartWiiSceneDesc('rainbow_course', "Rainbow Road"),
                new MarioKartWiiSceneDesc('old_peach_gc', "GCN Peach Beach"),
                new MarioKartWiiSceneDesc('old_falls_ds', "DS Yoshi Falls"),
                new MarioKartWiiSceneDesc('old_obake_sfc', "SNES Ghost Valley 2"),
                new MarioKartWiiSceneDesc('old_mario_64', "N64 Mario Raceway"),
                new MarioKartWiiSceneDesc('old_sherbet_64', "N64 Sherbet Land"),
                new MarioKartWiiSceneDesc('old_heyho_gba', "GBA Shy Guy Beach"),
                new MarioKartWiiSceneDesc('old_town_ds', "DS Delfino Square"),
                new MarioKartWiiSceneDesc('old_waluigi_gc', "GCN Waluigi Stadium"),
                new MarioKartWiiSceneDesc('old_desert_ds', "DS Desert Hills"),
                new MarioKartWiiSceneDesc('old_donkey_64', "N64 DK's Jungle Parkway"),
                new MarioKartWiiSceneDesc('old_mario_gc', "GC Mario Circuit"),
                new MarioKartWiiSceneDesc('old_mario_sfc', "SNES Mario Circuit 3"),
                new MarioKartWiiSceneDesc('old_garden_ds', "DS Peach Gardens"),
                new MarioKartWiiSceneDesc('old_donkey_gc', "GCN DK Mountain"),
                new MarioKartWiiSceneDesc('old_koopa_64', "N64 Bowser's Castle"),
                new MarioKartWiiSceneDesc('block_battle', "Block Plaza"),
                new MarioKartWiiSceneDesc('venice_battle', "Delfino Pier"),
                new MarioKartWiiSceneDesc('skate_battle', "Funky Stadium"),
                new MarioKartWiiSceneDesc('casino_battle', "Chain Chomp Wheel"),
                new MarioKartWiiSceneDesc('sand_battle', "Thwomp Desert"),
                new MarioKartWiiSceneDesc('old_battle4_sfc', "SNES Battle Course 4"),
                new MarioKartWiiSceneDesc('old_battle3_gba', "GBA Battle Course 3"),
                new MarioKartWiiSceneDesc('old_matenro_64', "N64 Skyscraper"),
                new MarioKartWiiSceneDesc('old_CookieLand_gc', "GCN Cookie Land"),
                new MarioKartWiiSceneDesc('old_House_ds', "DS Twilight House"),
                new MarioKartWiiSceneDesc('ring_mission', "Galaxy Colosseum"),
            ];
            exports_84("sceneGroup", sceneGroup = { id: id, name: name, sceneDescs: sceneDescs });
        }
    };
});
System.register("main", ["viewer", "ArrayBufferSlice", "Progressable", "j3d/ztp_scenes", "j3d/mkdd_scenes", "j3d/zww_scenes", "j3d/sms_scenes", "j3d/smg_scenes", "sm64ds/scenes", "mdl0/scenes", "zelview/scenes", "oot3d/scenes", "fres/scenes", "fres/splatoon_scenes", "dksiv/scenes", "metroid_prime/scenes", "luigis_mansion/scenes", "rres/zss_scenes", "rres/elb_scenes", "rres/mkwii_scenes", "j3d/scenes", "ui", "Camera"], function (exports_85, context_85) {
    "use strict";
    var __moduleName = context_85 && context_85.id;
    var viewer_1, ArrayBufferSlice_10, Progressable_12, ZTP, MKDD, ZWW, SMS, SMG, SM64DS, MDL0, ZELVIEW, OOT3D, FRES, SPL, DKSIV, MP1, LM, ZSS, ELB, MKWII, J3D, ui_1, Camera_14, sceneGroups, DroppedFileSceneDesc, SceneLoader, Main;
    return {
        setters: [
            function (viewer_1_1) {
                viewer_1 = viewer_1_1;
            },
            function (ArrayBufferSlice_10_1) {
                ArrayBufferSlice_10 = ArrayBufferSlice_10_1;
            },
            function (Progressable_12_1) {
                Progressable_12 = Progressable_12_1;
            },
            function (ZTP_1) {
                ZTP = ZTP_1;
            },
            function (MKDD_1) {
                MKDD = MKDD_1;
            },
            function (ZWW_1) {
                ZWW = ZWW_1;
            },
            function (SMS_1) {
                SMS = SMS_1;
            },
            function (SMG_1) {
                SMG = SMG_1;
            },
            function (SM64DS_1) {
                SM64DS = SM64DS_1;
            },
            function (MDL0_2) {
                MDL0 = MDL0_2;
            },
            function (ZELVIEW_1) {
                ZELVIEW = ZELVIEW_1;
            },
            function (OOT3D_1) {
                OOT3D = OOT3D_1;
            },
            function (FRES_1) {
                FRES = FRES_1;
            },
            function (SPL_1) {
                SPL = SPL_1;
            },
            function (DKSIV_1) {
                DKSIV = DKSIV_1;
            },
            function (MP1_1) {
                MP1 = MP1_1;
            },
            function (LM_1) {
                LM = LM_1;
            },
            function (ZSS_1) {
                ZSS = ZSS_1;
            },
            function (ELB_1) {
                ELB = ELB_1;
            },
            function (MKWII_1) {
                MKWII = MKWII_1;
            },
            function (J3D_1) {
                J3D = J3D_1;
            },
            function (ui_1_1) {
                ui_1 = ui_1_1;
            },
            function (Camera_14_1) {
                Camera_14 = Camera_14_1;
            }
        ],
        execute: function () {
            sceneGroups = [
                ZTP.sceneGroup,
                ZSS.sceneGroup,
                ZWW.sceneGroup,
                SMS.sceneGroup,
                SMG.sceneGroup,
                MKDD.sceneGroup,
                MKWII.sceneGroup,
                ELB.sceneGroup,
                LM.sceneGroup,
                SM64DS.sceneGroup,
                SPL.sceneGroup,
                MDL0.sceneGroup,
                ZELVIEW.sceneGroup,
                OOT3D.sceneGroup,
                DKSIV.sceneGroup,
                MP1.sceneGroup,
            ];
            DroppedFileSceneDesc = /** @class */ (function () {
                function DroppedFileSceneDesc(file) {
                    this.file = file;
                    this.id = file.name;
                    this.name = file.name;
                }
                DroppedFileSceneDesc.prototype._loadFileAsPromise = function (file) {
                    var request = new FileReader();
                    request.readAsArrayBuffer(file);
                    var p = new Promise(function (resolve, reject) {
                        request.onload = function () {
                            var buffer = request.result;
                            var slice = new ArrayBufferSlice_10.default(buffer);
                            resolve(slice);
                        };
                        request.onerror = function () {
                            reject();
                        };
                        request.onprogress = function (e) {
                            if (e.lengthComputable)
                                pr.setProgress(e.loaded / e.total);
                        };
                    });
                    var pr = new Progressable_12.default(p);
                    return pr;
                };
                DroppedFileSceneDesc.prototype.createSceneFromFile = function (gl, file, buffer) {
                    if (file.name.endsWith('.brres'))
                        return Promise.resolve(ELB.createBasicRRESSceneFromBuffer(gl, buffer));
                    if (file.name.endsWith('.bfres'))
                        return Promise.resolve(FRES.createSceneFromFRESBuffer(gl, buffer));
                    if (file.name.endsWith('.szs'))
                        return FRES.createSceneFromSARCBuffer(gl, buffer);
                    // XXX(jstpierre): Figure out WTF to do here...
                    var promise = J3D.createMultiSceneFromBuffer(gl, buffer);
                    if (promise)
                        return promise;
                    return null;
                };
                DroppedFileSceneDesc.prototype.createScene = function (gl) {
                    var _this = this;
                    return this._loadFileAsPromise(this.file).then(function (result) {
                        return _this.createSceneFromFile(gl, _this.file, result);
                    });
                };
                return DroppedFileSceneDesc;
            }());
            SceneLoader = /** @class */ (function () {
                function SceneLoader(viewer) {
                    this.viewer = viewer;
                }
                SceneLoader.prototype.setScene = function (scene, sceneDesc, cameraState) {
                    this.currentScene = scene;
                    var cameraControllerClass;
                    if (sceneDesc !== null)
                        cameraControllerClass = sceneDesc.defaultCameraController;
                    if (cameraControllerClass === undefined)
                        cameraControllerClass = Camera_14.FPSCameraController;
                    var cameraController = new cameraControllerClass();
                    this.viewer.setCameraController(cameraController);
                    if (cameraState !== null) {
                        cameraController.deserialize(cameraState);
                    }
                    else if (scene !== null && scene.resetCamera) {
                        scene.resetCamera(cameraController.camera);
                    }
                    else {
                        cameraController.camera.identity();
                    }
                    this.viewer.setScene(scene);
                    this.onscenechanged();
                };
                SceneLoader.prototype.loadSceneDesc = function (sceneDesc, cameraState) {
                    var _this = this;
                    this.setScene(null, null, null);
                    var gl = this.viewer.renderState.gl;
                    var progressable = sceneDesc.createScene(gl);
                    progressable.then(function (scene) {
                        _this.setScene(scene, sceneDesc, cameraState);
                    });
                    return progressable;
                };
                return SceneLoader;
            }());
            Main = /** @class */ (function () {
                function Main() {
                    var _this = this;
                    this.canvas = document.createElement('canvas');
                    this.canvas.onmousedown = function () {
                        _this._deselectUI();
                    };
                    this.canvas.ondragover = function (e) {
                        _this.dragHighlight.style.display = 'block';
                        e.preventDefault();
                    };
                    this.canvas.ondragleave = function (e) {
                        _this.dragHighlight.style.display = 'none';
                        e.preventDefault();
                    };
                    this.canvas.ondrop = this._onDrop.bind(this);
                    document.body.appendChild(this.canvas);
                    window.onresize = this._onResize.bind(this);
                    this._onResize();
                    window.addEventListener('keydown', this._onKeyDown.bind(this));
                    this.viewer = new viewer_1.Viewer(this.canvas);
                    this.viewer.oncamerachanged = function () {
                        _this._queueSaveState();
                    };
                    this.viewer.start();
                    this.sceneLoader = new SceneLoader(this.viewer);
                    this.sceneLoader.onscenechanged = this._onSceneChanged.bind(this);
                    this._makeUI();
                    this.groups = sceneGroups;
                    this.droppedFileGroup = { id: "drops", name: "Dropped Files", sceneDescs: [] };
                    this.groups.push(this.droppedFileGroup);
                    this._loadSceneGroups();
                    // Load the state from the hash
                    this._loadState(window.location.hash.slice(1));
                    // Make the user choose a scene if there's nothing loaded by default...
                    if (this.currentSceneDesc === undefined)
                        this.ui.sceneSelect.setExpanded(true);
                }
                Main.prototype._deselectUI = function () {
                    this.canvas.focus();
                };
                Main.prototype._onDrop = function (e) {
                    this.dragHighlight.style.display = 'none';
                    e.preventDefault();
                    var transfer = e.dataTransfer;
                    var file = transfer.files[0];
                    var sceneDesc = new DroppedFileSceneDesc(file);
                    this.droppedFileGroup.sceneDescs.push(sceneDesc);
                    this._loadSceneGroups();
                    this._loadSceneDesc(this.droppedFileGroup, sceneDesc);
                };
                Main.prototype._onResize = function () {
                    var devicePixelRatio = window.devicePixelRatio || 1;
                    this.canvas.setAttribute('style', "width: " + window.innerWidth + "px; height: " + window.innerHeight + "px;");
                    this.canvas.width = window.innerWidth * devicePixelRatio;
                    this.canvas.height = window.innerHeight * devicePixelRatio;
                };
                Main.prototype._loadState = function (state) {
                    var parts = state.split(';');
                    var _a = __read(parts, 2), sceneState = _a[0], cameraState = _a[1];
                    var _b = __read(sceneState.split('/')), groupId = _b[0], sceneRest = _b.slice(1);
                    var sceneId = decodeURIComponent(sceneRest.join('/'));
                    var group = this.groups.find(function (g) { return g.id === groupId; });
                    if (!group)
                        return;
                    var desc = group.sceneDescs.find(function (d) { return d.id === sceneId; });
                    var hasDesc = desc !== undefined;
                    this.lastSavedState = state;
                    this._loadSceneDesc(group, desc, cameraState);
                };
                Main.prototype._getState = function () {
                    var groupId = this.currentSceneGroup.id;
                    var sceneId = this.currentSceneDesc.id;
                    var camera = this.viewer.cameraController.serialize();
                    return groupId + "/" + sceneId + ";" + camera;
                };
                Main.prototype._saveState = function () {
                    // If we're currently loading a scene, don't save out...
                    if (this.sceneLoader.currentScene === null)
                        return;
                    var newState = this._getState();
                    if (this.lastSavedState !== newState) {
                        window.history.replaceState('', '', '#' + newState);
                        this.lastSavedState = newState;
                    }
                };
                Main.prototype._queueSaveState = function () {
                    var _this = this;
                    if (this.saveTimeout !== 0)
                        clearTimeout(this.saveTimeout);
                    this.saveTimeout = setTimeout(function () {
                        _this._saveState();
                        _this.saveTimeout = 0;
                    }, 100);
                };
                Main.prototype._onSceneChanged = function () {
                    var scene = this.viewer.scene;
                    this.ui.sceneChanged();
                    if (scene && scene.createPanels)
                        this.ui.setScenePanels(scene.createPanels());
                    else
                        this.ui.setScenePanels([]);
                };
                Main.prototype._onSceneDescSelected = function (sceneGroup, sceneDesc) {
                    this._loadSceneDesc(sceneGroup, sceneDesc);
                };
                Main.prototype._loadSceneDesc = function (sceneGroup, sceneDesc, cameraState) {
                    if (cameraState === void 0) { cameraState = null; }
                    if (this.currentSceneDesc === sceneDesc)
                        return;
                    this.currentSceneGroup = sceneGroup;
                    this.currentSceneDesc = sceneDesc;
                    this.ui.sceneSelect.setCurrentDesc(this.currentSceneGroup, this.currentSceneDesc);
                    var progressable = this.sceneLoader.loadSceneDesc(sceneDesc, cameraState);
                    this.ui.sceneSelect.setProgressable(progressable);
                    // TODO(jstpierre): Probably a better place to put this.
                    // Set window title.
                    document.title = sceneDesc.name + " - " + sceneGroup.name + " - Model Viewer";
                    this._deselectUI();
                    this._saveState();
                };
                Main.prototype._loadSceneGroups = function () {
                    this.ui.sceneSelect.setSceneGroups(this.groups);
                };
                Main.prototype._makeUI = function () {
                    this.uiContainers = document.createElement('div');
                    document.body.appendChild(this.uiContainers);
                    this.ui = new ui_1.UI(this.viewer);
                    this.ui.elem.style.position = 'absolute';
                    this.ui.elem.style.left = '2em';
                    this.ui.elem.style.top = '2em';
                    this.uiContainers.appendChild(this.ui.elem);
                    this.ui.sceneSelect.onscenedescselected = this._onSceneDescSelected.bind(this);
                    this.dragHighlight = document.createElement('div');
                    this.uiContainers.appendChild(this.dragHighlight);
                    this.dragHighlight.style.position = 'absolute';
                    this.dragHighlight.style.left = '0';
                    this.dragHighlight.style.right = '0';
                    this.dragHighlight.style.top = '0';
                    this.dragHighlight.style.bottom = '0';
                    this.dragHighlight.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
                    this.dragHighlight.style.boxShadow = '0 0 40px 5px white inset';
                    this.dragHighlight.style.display = 'none';
                    this.dragHighlight.style.pointerEvents = 'none';
                };
                Main.prototype._toggleUI = function () {
                    this.uiContainers.style.display = this.uiContainers.style.display === 'none' ? '' : 'none';
                };
                Main.prototype._onKeyDown = function (e) {
                    if (e.code === 'KeyZ') {
                        this._toggleUI();
                        e.preventDefault();
                    }
                };
                return Main;
            }());
            window.main = new Main();
        }
    };
});
System.register("embeds/main", ["viewer", "Camera"], function (exports_86, context_86) {
    "use strict";
    var __moduleName = context_86 && context_86.id;
    var Viewer, Camera_15, FsButton, Main;
    return {
        setters: [
            function (Viewer_1) {
                Viewer = Viewer_1;
            },
            function (Camera_15_1) {
                Camera_15 = Camera_15_1;
            }
        ],
        execute: function () {
            FsButton = /** @class */ (function () {
                function FsButton() {
                    var _this = this;
                    this.hover = false;
                    this.elem = document.createElement('div');
                    this.elem.style.border = '1px solid rgba(255, 255, 255, 0.4)';
                    this.elem.style.borderRadius = '4px';
                    this.elem.style.color = 'white';
                    this.elem.style.position = 'absolute';
                    this.elem.style.bottom = '8px';
                    this.elem.style.right = '8px';
                    this.elem.style.width = '32px';
                    this.elem.style.height = '32px';
                    this.elem.style.font = '130% bold sans-serif';
                    this.elem.style.textAlign = 'center';
                    this.elem.style.cursor = 'pointer';
                    this.elem.onmouseover = function () {
                        _this.hover = true;
                        _this.style();
                    };
                    this.elem.onmouseout = function () {
                        _this.hover = false;
                        _this.style();
                    };
                    this.elem.onclick = this.onClick.bind(this);
                    document.addEventListener('fullscreenchange', this.style.bind(this));
                    this.style();
                }
                FsButton.prototype.isFS = function () {
                    return document.fullscreenElement === document.body;
                };
                FsButton.prototype.style = function () {
                    this.elem.style.backgroundColor = this.hover ? 'rgba(50, 50, 50, 0.8)' : 'rgba(0, 0, 0, 0.8)';
                    this.elem.textContent = this.isFS() ? '' : '';
                };
                FsButton.prototype.onClick = function () {
                    if (this.isFS())
                        document.exitFullscreen();
                    else
                        document.body.requestFullscreen();
                };
                return FsButton;
            }());
            Main = /** @class */ (function () {
                function Main() {
                    this.canvas = document.createElement('canvas');
                    document.body.appendChild(this.canvas);
                    window.onresize = this.onResize.bind(this);
                    this.fsButton = new FsButton();
                    document.body.appendChild(this.fsButton.elem);
                    this.viewer = new Viewer.Viewer(this.canvas);
                    this.viewer.start();
                    // Dispatch to the main embed.
                    var hash = window.location.hash.slice(1);
                    this.onResize();
                    this.loadScene(hash);
                }
                Main.prototype.loadScene = function (hash) {
                    var _this = this;
                    var _a = __read(hash.split('/'), 2), file = _a[0], name = _a[1];
                    SystemJS.import("embeds/" + file).then(function (embedModule) {
                        var gl = _this.viewer.renderState.gl;
                        embedModule.createScene(gl, name).then(function (scene) {
                            _this.viewer.setCameraController(new Camera_15.OrbitCameraController());
                            _this.viewer.setScene(scene);
                        });
                    });
                };
                Main.prototype.onResize = function () {
                    var devicePixelRatio = window.devicePixelRatio || 1;
                    this.canvas.width = Math.ceil(window.innerWidth * devicePixelRatio);
                    this.canvas.height = Math.ceil(window.innerHeight * devicePixelRatio);
                };
                return Main;
            }());
            window.main = new Main();
        }
    };
});
System.register("embeds/sunshine_water", ["gl-matrix", "util", "gx/gx_material", "j3d/j3d", "j3d/rarc", "j3d/render", "j3d/sms_scenes", "compression/Yaz0", "gx/gx_render"], function (exports_87, context_87) {
    "use strict";
    var __moduleName = context_87 && context_87.id;
    function createScene(gl, name) {
        return util_55.fetch("data/j3d/sms/dolpic0.szs").then(function (buffer) {
            return Yaz0.decompress(buffer);
        }).then(function (buffer) {
            var rarc = RARC.parse(buffer);
            var textureHolder = new render_38.J3DTextureHolder();
            var skyScene = sms_scenes_1.SunshineSceneDesc.createSunshineSceneForBasename(gl, textureHolder, rarc, 'map/map/sky', true);
            var bmdFile = rarc.findFile('map/map/sea.bmd');
            var btkFile = rarc.findFile('map/map/sea.btk');
            var bmd = j3d_6.BMD.parse(bmdFile.buffer);
            var btk = j3d_6.BTK.parse(btkFile.buffer);
            textureHolder.addJ3DTextures(gl, bmd);
            var seaScene = new SeaPlaneScene(gl, textureHolder, bmd, btk, name);
            return new sms_scenes_1.SunshineRenderer(textureHolder, skyScene, null, // map
            seaScene, null, // seaindirect
            []);
        });
    }
    exports_87("createScene", createScene);
    var gl_matrix_23, util_55, GX_Material, j3d_6, RARC, render_38, sms_scenes_1, Yaz0, gx_render_5, scale, posMtx, SeaPlaneScene, PlaneShape;
    return {
        setters: [
            function (gl_matrix_23_1) {
                gl_matrix_23 = gl_matrix_23_1;
            },
            function (util_55_1) {
                util_55 = util_55_1;
            },
            function (GX_Material_11) {
                GX_Material = GX_Material_11;
            },
            function (j3d_6_1) {
                j3d_6 = j3d_6_1;
            },
            function (RARC_7) {
                RARC = RARC_7;
            },
            function (render_38_1) {
                render_38 = render_38_1;
            },
            function (sms_scenes_1_1) {
                sms_scenes_1 = sms_scenes_1_1;
            },
            function (Yaz0_7) {
                Yaz0 = Yaz0_7;
            },
            function (gx_render_5_1) {
                gx_render_5 = gx_render_5_1;
            }
        ],
        execute: function () {
            scale = 200;
            posMtx = gl_matrix_23.mat4.create();
            gl_matrix_23.mat4.fromScaling(posMtx, [scale, scale, scale]);
            SeaPlaneScene = /** @class */ (function () {
                function SeaPlaneScene(gl, textureHolder, bmd, btk, configName) {
                    this.textureHolder = textureHolder;
                    this.animationScale = 5;
                    // Play make-believe for Command_Material.
                    this.btk = null;
                    this.brk = null;
                    this.colorOverrides = [];
                    this.alphaOverrides = [];
                    this.sceneParams = new gx_render_5.SceneParams();
                    // Play make-believe for translateTextures
                    this.bmt = null;
                    this.fps = 30;
                    this.btk = btk;
                    var sceneLoader = new render_38.SceneLoader(textureHolder, bmd, null);
                    render_38.Scene.prototype.translateTextures.call(this, gl, sceneLoader);
                    var seaMaterial = bmd.mat3.materialEntries.find(function (m) { return m.name === '_umi'; });
                    this.seaCmd = this.makeMaterialCommand(gl, seaMaterial, configName);
                    this.plane = new PlaneShape(gl);
                    this.renderHelper = new gx_render_5.GXRenderHelper(gl);
                }
                SeaPlaneScene.prototype.makeMaterialCommand = function (gl, material, configName) {
                    var gxMaterial = material.gxMaterial;
                    if (configName.includes('noalpha')) {
                        // Disable alpha test
                        gxMaterial.alphaTest.compareA = 7 /* ALWAYS */;
                        gxMaterial.alphaTest.op = 1 /* OR */;
                    }
                    if (configName.includes('noblend')) {
                        // Disable blending.
                        gxMaterial.tevStages[0].alphaInD = 6 /* KONST */;
                        gxMaterial.tevStages[1].alphaInD = 6 /* KONST */;
                        gxMaterial.ropInfo.blendMode.srcFactor = 1 /* ONE */;
                        gxMaterial.ropInfo.blendMode.dstFactor = 0 /* ZERO */;
                    }
                    if (configName.includes('opaque')) {
                        // Make it always opaque.
                        gxMaterial.tevStages[0].colorInB = 9 /* TEXA */;
                        gxMaterial.tevStages[0].colorInC = 11 /* RASA */;
                        gxMaterial.tevStages[0].colorInD = 0 /* CPREV */;
                        gxMaterial.tevStages[0].colorScale = 0 /* SCALE_1 */;
                        gxMaterial.tevStages[1].colorInB = 9 /* TEXA */;
                        gxMaterial.tevStages[1].colorInC = 11 /* RASA */;
                        gxMaterial.tevStages[1].colorInD = 0 /* CPREV */;
                        gxMaterial.tevStages[1].colorScale = 0 /* SCALE_1 */;
                        gxMaterial.tevStages[1].colorClamp = true;
                        // Use one TEV stage.
                        if (configName.includes('layer0')) {
                            gxMaterial.tevStages.length = 1;
                        }
                        else if (configName.includes('layer1')) {
                            gxMaterial.tevStages[0] = gxMaterial.tevStages[1];
                            gxMaterial.tevStages.length = 1;
                        }
                    }
                    var cmd = new render_38.Command_Material(gl, this, material);
                    if (configName.includes('nomip')) {
                        try {
                            for (var _a = __values(this.glSamplers), _b = _a.next(); !_b.done; _b = _a.next()) {
                                var sampler = _b.value;
                                gl.samplerParameterf(sampler, gl.TEXTURE_MIN_LOD, 1);
                                gl.samplerParameterf(sampler, gl.TEXTURE_MAX_LOD, 1);
                            }
                        }
                        catch (e_94_1) { e_94 = { error: e_94_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                            }
                            finally { if (e_94) throw e_94.error; }
                        }
                    }
                    return cmd;
                    var e_94, _c;
                };
                SeaPlaneScene.prototype.render = function (state) {
                    var gl = state.gl;
                    this.renderHelper.bindUniformBuffers(state);
                    gx_render_5.fillSceneParamsFromRenderState(this.sceneParams, state);
                    this.renderHelper.bindSceneParams(state, this.sceneParams);
                    this.seaCmd.exec(state);
                    this.plane.render(state, this.renderHelper);
                };
                SeaPlaneScene.prototype.destroy = function (gl) {
                    this.plane.destroy(gl);
                    this.seaCmd.destroy(gl);
                    this.renderHelper.destroy(gl);
                };
                SeaPlaneScene.prototype.getTimeInFrames = function (milliseconds) {
                    return (milliseconds / 1000) * this.fps * this.animationScale;
                };
                SeaPlaneScene.prototype.fillTextureMapping = function (m, texIndex) {
                    var tex1Sampler = this.tex1Samplers[texIndex];
                    this.textureHolder.fillTextureMapping(m, tex1Sampler.name);
                    m.glSampler = this.glSamplers[tex1Sampler.index];
                    m.lodBias = tex1Sampler.lodBias;
                };
                return SeaPlaneScene;
            }());
            PlaneShape = /** @class */ (function () {
                function PlaneShape(gl) {
                    this.packetParams = new gx_render_5.PacketParams();
                    this.createBuffers(gl);
                }
                PlaneShape.prototype.render = function (state, renderHelper) {
                    var gl = state.gl;
                    gl_matrix_23.mat4.mul(this.packetParams.u_PosMtx[0], state.updateModelView(), posMtx);
                    renderHelper.bindPacketParams(state, this.packetParams);
                    gl.bindVertexArray(this.vao);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    gl.bindVertexArray(null);
                };
                PlaneShape.prototype.destroy = function (gl) {
                    gl.deleteVertexArray(this.vao);
                    gl.deleteBuffer(this.posBuffer);
                    gl.deleteBuffer(this.txcBuffer);
                };
                PlaneShape.prototype.createBuffers = function (gl) {
                    this.vao = gl.createVertexArray();
                    gl.bindVertexArray(this.vao);
                    var posData = new Float32Array(4 * 3);
                    posData[0] = -1;
                    posData[1] = 0;
                    posData[2] = -1;
                    posData[3] = 1;
                    posData[4] = 0;
                    posData[5] = -1;
                    posData[6] = -1;
                    posData[7] = 0;
                    posData[8] = 1;
                    posData[9] = 1;
                    posData[10] = 0;
                    posData[11] = 1;
                    this.posBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, posData, gl.STATIC_DRAW);
                    var posAttribLocation = GX_Material.getVertexAttribLocation(9 /* POS */);
                    gl.vertexAttribPointer(posAttribLocation, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(posAttribLocation);
                    var txcData = new Float32Array(4 * 2);
                    txcData[0] = 0;
                    txcData[1] = 0;
                    txcData[2] = 2;
                    txcData[3] = 0;
                    txcData[4] = 0;
                    txcData[5] = 2;
                    txcData[6] = 2;
                    txcData[7] = 2;
                    this.txcBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.txcBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, txcData, gl.STATIC_DRAW);
                    var tex0AttribLocation = GX_Material.getVertexAttribLocation(13 /* TEX0 */);
                    gl.vertexAttribPointer(tex0AttribLocation, 2, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(tex0AttribLocation);
                    gl.bindVertexArray(null);
                };
                return PlaneShape;
            }());
        }
    };
});
System.register("luigis_mansion/jmp", ["util"], function (exports_88, context_88) {
    "use strict";
    var __moduleName = context_88 && context_88.id;
    function nameHash(str) {
        var hash = 0;
        for (var i = 0; i < str.length; i++) {
            hash <<= 8;
            hash += str.charCodeAt(i);
            // const r6 = Math.floor((4993 * hash) >>> 32);
            var r6 = Math.floor((4993 * hash) / 0x100000000);
            var r0 = (((hash - r6) / 2) + r6) >> 24;
            hash -= r0 * 33554393;
        }
        return hash;
    }
    function findNameFromHash(hash) {
        var name = hashLookup.get(hash);
        if (name !== undefined)
            return name;
        else
            return "Unk$" + hash;
    }
    function parse(buffer) {
        var view = buffer.createDataView();
        var recordCount = view.getUint32(0x00, false);
        var fieldCount = view.getUint32(0x04, false);
        var recordOffs = view.getUint32(0x08, false);
        var recordSize = view.getUint32(0x0C, false);
        var fieldTableIdx = 0x10;
        var fields = [];
        for (var i = 0; i < fieldCount; i++) {
            var nameHash_2 = view.getUint32(fieldTableIdx + 0x00);
            var bitmask = view.getUint32(fieldTableIdx + 0x04);
            var recordOffset = view.getUint16(fieldTableIdx + 0x08);
            var shift = view.getInt8(fieldTableIdx + 0x0A);
            var type = view.getUint8(fieldTableIdx + 0x0B);
            var name_18 = findNameFromHash(nameHash_2);
            fields.push({ nameHash: nameHash_2, name: name_18, bitmask: bitmask, recordOffset: recordOffset, shift: shift, type: type });
            fieldTableIdx += 0x0C;
        }
        var recordTableIdx = recordOffs;
        var records = [];
        for (var i = 0; i < recordCount; i++) {
            var record = {};
            try {
                for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
                    var field = fields_1_1.value;
                    var fieldOffs = recordTableIdx + field.recordOffset;
                    var value = void 0;
                    switch (field.type) {
                        case 0 /* Int */:
                            value = (view.getUint32(fieldOffs, false) >> field.shift) & field.bitmask;
                            break;
                        case 1 /* String */:
                            value = util_56.readString(buffer, fieldOffs, 0x20, true);
                            break;
                        case 2 /* Float */:
                            value = view.getFloat32(fieldOffs, false);
                            break;
                    }
                    record[field.name] = value;
                }
            }
            catch (e_95_1) { e_95 = { error: e_95_1 }; }
            finally {
                try {
                    if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);
                }
                finally { if (e_95) throw e_95.error; }
            }
            records.push(record);
            recordTableIdx += recordSize;
        }
        return records;
        var e_95, _a;
    }
    exports_88("parse", parse);
    var util_56, nameTable, hashLookup;
    return {
        setters: [
            function (util_56_1) {
                util_56 = util_56_1;
            }
        ],
        execute: function () {
            nameTable = [
                'pos_x', 'pos_y', 'pos_z',
                'dir_x', 'dir_y', 'dir_z',
                'scale_x', 'scale_y', 'scale_z',
                'pnt0_x', 'pnt0_y', 'pnt0_z',
                'furniture_x', 'furniture_y', 'furniture_z',
                'name', 'dmd_name', 'path_name', 'create_name', 'character_name', 'access_name', 'CodeName',
                'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'arg5', 'arg6', 'arg7', 'arg8',
                'room_no',
            ];
            hashLookup = new Map();
            nameTable.forEach(function (name) {
                hashLookup.set(nameHash(name), name);
            });
        }
    };
});
//# sourceMappingURL=main.js.map