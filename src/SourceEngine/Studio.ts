
// Source "Studio" models, which seem to be named because of their original ties to 3D Studio Max
// https://developer.valvesoftware.com/wiki/Studiomodel

import ArrayBufferSlice from "../ArrayBufferSlice";
import { GfxDevice, GfxBuffer, GfxInputLayout, GfxInputState, GfxBufferUsage, GfxVertexAttributeDescriptor, GfxFormat, GfxInputLayoutBufferDescriptor, GfxVertexBufferFrequency } from "../gfx/platform/GfxPlatform";
import { assert, readString, nArray, assertExists } from "../util";
import { SourceFileSystem, SourceRenderContext } from "./Main";
import { AABB } from "../Geometry";
import { GfxRenderCache } from "../gfx/render/GfxRenderCache";
import { makeStaticDataBuffer, makeStaticDataBufferFromSlice } from "../gfx/helpers/BufferHelpers";
import { MaterialProgramBase, BaseMaterial } from "./Materials";
import { GfxRenderInst, GfxRenderInstManager } from "../gfx/render/GfxRenderer";
import { mat4 } from "gl-matrix";

// Encompasses the MDL, VVD & VTX formats.

const enum StudioModelFlags {
    AUTOGENERATED_HITBOX           = 0x0001,
    FORCE_OPAQUE                   = 0x0004,
    STATIC_PROP                    = 0x0010,
    CONSTANT_DIRECTIONAL_LIGHT_DOT = 0x2000,
}

const enum OptimizeStripGroupFlags {
    IS_FLEXED                      = 0x01,
    IS_HWSKINNED                   = 0x02,
    IS_DELTA_FLEXED                = 0x04,
}

const enum OptimizeStripFlags {
    IS_TRILIST                     = 0x01,
    IS_TRISTRIP                    = 0x02,
}

class StudioModelStripData {
    constructor(public firstIndex: number, public indexCount: number) {
    }
}

// TODO(jstpierre): Coalesce all buffers for a studio model?
class StudioModelStripGroupData {
    private vertexBuffer: GfxBuffer;
    private indexBuffer: GfxBuffer;
    private inputLayout: GfxInputLayout;
    private inputState: GfxInputState;

    public stripData: StudioModelStripData[] = [];

    constructor(device: GfxDevice, cache: GfxRenderCache, vertexData: ArrayBuffer, indexData: ArrayBufferSlice) {
        this.vertexBuffer = makeStaticDataBuffer(device, GfxBufferUsage.VERTEX, vertexData);
        this.indexBuffer = makeStaticDataBufferFromSlice(device, GfxBufferUsage.INDEX, indexData);

        const vertexAttributeDescriptors: GfxVertexAttributeDescriptor[] = [
            { location: MaterialProgramBase.a_Position, bufferIndex: 0, bufferByteOffset: 0*0x04, format: GfxFormat.F32_RGB, },
            { location: MaterialProgramBase.a_Normal,   bufferIndex: 0, bufferByteOffset: 3*0x04, format: GfxFormat.F32_RGBA, },
            { location: MaterialProgramBase.a_TangentS, bufferIndex: 0, bufferByteOffset: 7*0x04, format: GfxFormat.F32_RGBA, },
            { location: MaterialProgramBase.a_TexCoord, bufferIndex: 0, bufferByteOffset: 11*0x04, format: GfxFormat.F32_RG, },

            // TODO(jstpierre): Dynamic color model?
        ];
        const vertexBufferDescriptors: GfxInputLayoutBufferDescriptor[] = [
            { byteStride: (3+4+4+2)*0x04, frequency: GfxVertexBufferFrequency.PER_VERTEX, },
        ];
        const indexBufferFormat = GfxFormat.U16_R;
        this.inputLayout = cache.createInputLayout(device, { vertexAttributeDescriptors, vertexBufferDescriptors, indexBufferFormat });

        this.inputState = device.createInputState(this.inputLayout, [
            { buffer: this.vertexBuffer, byteOffset: 0, },
        ], { buffer: this.indexBuffer, byteOffset: 0, });
    }

    public setOnRenderInst(renderInst: GfxRenderInst): void {
        renderInst.setInputLayoutAndState(this.inputLayout, this.inputState);
    }

    public destroy(device: GfxDevice): void {
        device.destroyBuffer(this.vertexBuffer);
        device.destroyBuffer(this.indexBuffer);
        device.destroyInputState(this.inputState);
    }
}

class StudioModelMeshData {
    public stripGroupData: StudioModelStripGroupData[] = [];

    constructor(public materialName: string) {
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.stripGroupData.length; i++)
            this.stripGroupData[i].destroy(device);
    }
}

class StudioModelLODData {
    public meshData: StudioModelMeshData[] = [];

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.meshData.length; i++)
            this.meshData[i].destroy(device);
    }
}

class StudioModelSubmodelData {
    public lodData: StudioModelLODData[] = [];

    constructor(public name: string) {
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.lodData.length; i++)
            this.lodData[i].destroy(device);
    }
}

class StudioModelBodyPartData {
    public submodelData: StudioModelSubmodelData[] = [];

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.submodelData.length; i++)
            this.submodelData[i].destroy(device);
    }
}

interface FixupRemapping { copySrc: number; copyDst: number; count: number; }
function fixupRemappingSearch(fixupTable: FixupRemapping[], dstIdx: number): number {
    for (let i = 0; i < fixupTable.length; i++) {
        const map = fixupTable[i];
        const idx = dstIdx - map.copyDst;
        if (idx >= 0 && idx < map.count)
            return map.copySrc + idx;
    }

    // remap did not copy over this vertex, return as is.
    return dstIdx;
}

export class StudioModelData {
    public bodyPartData: StudioModelBodyPartData[] = [];

    constructor(renderContext: SourceRenderContext, mdlBuffer: ArrayBufferSlice, vvdBuffer: ArrayBufferSlice, vtxBuffer: ArrayBufferSlice) {
        const mdlView = mdlBuffer.createDataView();

        // Parse MDL header
        assert(readString(mdlBuffer, 0x00, 0x04) === 'IDST');
        const mdlVersion = mdlView.getUint32(0x04, true);

        const supportedVersions = [44, 45, 46, 47, 48];
        assert(supportedVersions.includes(mdlVersion));

        const mdlChecksum = mdlView.getUint32(0x08, true);

        const name = readString(mdlBuffer, 0x0C, 0x40, true);
        const length = mdlView.getUint32(0x4C, true);

        const eyePositionX = mdlView.getFloat32(0x50, true);
        const eyePositionY = mdlView.getFloat32(0x54, true);
        const eyePositionZ = mdlView.getFloat32(0x58, true);

        const illumPositionX = mdlView.getFloat32(0x5C, true);
        const illumPositionY = mdlView.getFloat32(0x60, true);
        const illumPositionZ = mdlView.getFloat32(0x64, true);

        const moveHullMinX = mdlView.getFloat32(0x68, true);
        const moveHullMinY = mdlView.getFloat32(0x6C, true);
        const moveHullMinZ = mdlView.getFloat32(0x70, true);
        const moveHullMaxX = mdlView.getFloat32(0x74, true);
        const moveHullMaxY = mdlView.getFloat32(0x78, true);
        const moveHullMaxZ = mdlView.getFloat32(0x7C, true);

        const bboxMinX = mdlView.getFloat32(0x80, true);
        const bboxMinY = mdlView.getFloat32(0x84, true);
        const bboxMinZ = mdlView.getFloat32(0x88, true);
        const bboxMaxX = mdlView.getFloat32(0x8C, true);
        const bboxMaxY = mdlView.getFloat32(0x90, true);
        const bboxMaxZ = mdlView.getFloat32(0x94, true);
        const bbox = new AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);

        const flags: StudioModelFlags = mdlView.getUint32(0x98, true);
        const isStaticProp = !!(flags & StudioModelFlags.STATIC_PROP);
        // We only support static props right now.
        assert(isStaticProp);

        const numbones = mdlView.getUint32(0x9C, true);
        const boneindex = mdlView.getUint32(0xA0, true);

        const numbonecontrollers = mdlView.getUint32(0xA4, true);
        const bonecontrollerindex = mdlView.getUint32(0xA8, true);
        if (isStaticProp)
            assert(numbonecontrollers === 0);

        const numhitboxsets = mdlView.getUint32(0xAC, true);
        const hitboxsetindex = mdlView.getUint32(0xB0, true);

        const numlocalanims = mdlView.getUint32(0xB4, true);
        const localanimindex = mdlView.getUint32(0xB8, true);

        const numlocalseqs = mdlView.getUint32(0xBC, true);
        const localseqindex = mdlView.getUint32(0xC0, true);
        const activitylistversion = mdlView.getUint32(0xC4, true);
        const eventsindexed = mdlView.getUint32(0xC8, true);

        const numtextures = mdlView.getUint32(0xCC, true);
        const textureindex = mdlView.getUint32(0xD0, true);

        const numcdtextures = mdlView.getUint32(0xD4, true);
        const cdtextureindex = mdlView.getUint32(0xD8, true);

        const materialSearchDirs: string[] = [];
        let cdtextureIdx = cdtextureindex;
        for (let i = 0; i < numcdtextures; i++) {
            const textureDir = readString(mdlBuffer, mdlView.getUint32(cdtextureIdx + 0x00, true));
            const materialSearchDir = `materials/${textureDir}`;
            materialSearchDirs.push(materialSearchDir);
            cdtextureIdx += 0x04;
        }

        const numskinref = mdlView.getUint32(0xDC, true);
        const numskinfamilies = mdlView.getUint32(0xE0, true);
        const skinindex = mdlView.getUint32(0xE4, true);

        const numbodyparts = mdlView.getUint32(0xE8, true);
        const bodypartindex = mdlView.getUint32(0xEC, true);

        const numlocalattachments = mdlView.getUint32(0xF0, true);
        const localattachmentindex = mdlView.getUint32(0xF4, true);

        const numlocalnodes = mdlView.getUint32(0xF8, true);
        const localnodeindex = mdlView.getUint32(0xFC, true);
        const localnodenameindex = mdlView.getUint32(0x100, true);

        const numflexdesc = mdlView.getUint32(0x104, true);
        const flexdescindex = mdlView.getUint32(0x108, true);

        const numflexcontrollers = mdlView.getUint32(0x10C, true);
        const flexcontrollerindex = mdlView.getUint32(0x110, true);

        const numflexrules = mdlView.getUint32(0x114, true);
        const flexruleindex = mdlView.getUint32(0x118, true);

        const numikchains = mdlView.getUint32(0x11C, true);
        const ikchainindex = mdlView.getUint32(0x120, true);

        const nummouthss = mdlView.getUint32(0x124, true);
        const mouthsindex = mdlView.getUint32(0x128, true);

        const numlocalposeparameters = mdlView.getUint32(0x12C, true);
        const localposeparamindex = mdlView.getUint32(0x130, true);

        const surfacepropindex = mdlView.getUint32(0x134, true);
        const surfaceprop = readString(mdlBuffer, surfacepropindex);

        const keyvalueindex = mdlView.getUint32(0x138, true);
        const keyvaluesize = mdlView.getUint32(0x13C, true);

        const numlocalikautoplaylocks = mdlView.getUint32(0x140, true);
        const localikautoplaylockindex = mdlView.getUint32(0x144, true);

        const mass = mdlView.getFloat32(0x148, true);
        const contents = mdlView.getUint32(0x14C, true);

        const numincludemodels = mdlView.getUint32(0x150, true);
        const includemodelindex = mdlView.getUint32(0x154, true);

        // Runtime backpointer.
        const virtualModel = mdlView.getUint32(0x158, true);
        assert(virtualModel === 0);

        const animblocknameindex = mdlView.getUint32(0x15C, true);
        const numanimblocks = mdlView.getUint32(0x160, true);
        const animblockindex = mdlView.getUint32(0x164, true);
        const animblockModel = mdlView.getUint32(0x168, true);

        const bonetablebynameindex = mdlView.getUint32(0x16C, true);

        // Runtime backpointer.
        const vertexBase = mdlView.getUint32(0x170, true);
        const indexBase = mdlView.getUint32(0x174, true);
        assert(vertexBase === 0);
        assert(indexBase === 0);

        const constantdirectionallightdot = mdlView.getUint32(0x178, true);
        const rootLOD = mdlView.getUint32(0x179, true);
        const numAllowedRootLODs = mdlView.getUint32(0x17A, true);

        const numflexcontrollerui = mdlView.getUint32(0x180, true);
        const flexcontrollleruiindex = mdlView.getUint32(0x184, true);

        const vertAnimFixedPointScale = mdlView.getFloat32(0x188, true);
        const studiohdr2index = mdlView.getUint32(0x190, true);

        // Parse VVD header
        const vvdView = vvdBuffer.createDataView();

        assert(readString(vvdBuffer, 0x00, 0x04) === 'IDSV');
        const vvdVersion = vvdView.getUint32(0x04, true);
        assert(vvdVersion === 0x04);
        const vvdChecksum = vvdView.getUint32(0x08, true);
        assert(vvdChecksum === mdlChecksum);
        const vvdNumLODs = vvdView.getUint32(0x0C, true);
        const vvdNumLODVertexes = nArray(8, (i) => vvdView.getUint32(0x10 + i * 0x04, true));
        const vvdNumFixups = vvdView.getUint32(0x30, true);
        const vvdFixupTableStart = vvdView.getUint32(0x34, true);
        const vvdVertexDataStart = vvdView.getUint32(0x38, true);
        const vvdTangentDataStart = vvdView.getUint32(0x3C, true);

        const fixupRemappings: FixupRemapping[] = [];
        let vvdFixupTableIdx = vvdFixupTableStart;
        let fixupTableCopyDstIdx = 0;
        for (let i = 0; i < vvdNumFixups; i++) {
            const lod = vvdView.getUint32(vvdFixupTableIdx + 0x00, true);
            // The fixup table works by memcpy-ing vertex data from src -> dst. So the indices in the
            // MDL/VTX files are in copyDst range, and the vertices in the VVD file are in copySrc.
            const copySrc = vvdView.getUint32(vvdFixupTableIdx + 0x04, true);
            const copyDst = fixupTableCopyDstIdx;
            const count = vvdView.getUint32(vvdFixupTableIdx + 0x08, true);
            fixupRemappings.push({ copySrc, copyDst, count });
            fixupTableCopyDstIdx += count;
            vvdFixupTableIdx += 0x0C;
        }

        // Parse VTX header
        const vtxView = vtxBuffer.createDataView();

        const vtxVersion = vtxView.getUint32(0x00, true);
        assert(vtxVersion === 0x07);

        // VTX optimization settings.
        const vtxCacheSize = vtxView.getUint32(0x04, true);
        const vtxMaxBonesPerStrip = vtxView.getUint16(0x08, true);
        const vtxMaxBonesPerTri = vtxView.getUint16(0x0A, true);
        const vtxMaxBonesPerVert = vtxView.getUint32(0x0C, true);

        const vtxChecksum = vtxView.getUint32(0x10, true);
        assert(mdlChecksum === vtxChecksum);

        const vtxNumLODs = vtxView.getUint32(0x14, true);
        assert(vtxNumLODs === vvdNumLODs);
        const vtxMaterialReplacementListOffset = vtxView.getUint32(0x18, true);
        const vtxNumBodyParts = vtxView.getUint32(0x1C, true);
        assert(vtxNumBodyParts === numbodyparts);
        const vtxBodyPartOffset = vtxView.getUint32(0x20, true);

        // Gather our materials for each LOD.
        // First, gather our base material names.
        const baseMaterialNames: string[] = [];
        let textureIdx = textureindex;
        for (let i = 0; i < numtextures; i++) {
            const nameindex = textureIdx + mdlView.getUint32(textureIdx + 0x00, true);
            const materialName = readString(mdlBuffer, nameindex);
            const flags = mdlView.getUint32(textureIdx + 0x04, true);
            const used = mdlView.getUint32(textureIdx + 0x08, true);
            const unused1 = mdlView.getUint32(textureIdx + 0x0C, true);
            const material = mdlView.getUint32(textureIdx + 0x10, true);
            // This appears to be a stale pointer generated by studiomdl, lol.
            // assert(material === 0);
            const clientmaterial = mdlView.getUint32(textureIdx + 0x14, true);
            assert(clientmaterial === 0);
            baseMaterialNames.push(assertExists(renderContext.filesystem.searchPath(materialSearchDirs, materialName, '.vmt')));
            textureIdx += 0x40;
        }

        const lodMaterialNames: string[][] = [];
        let vtxMaterialReplacementListIdx = vtxMaterialReplacementListOffset;
        for (let i = 0; i < vtxNumLODs; i++) {
            const numReplacements = vtxView.getUint32(vtxMaterialReplacementListIdx + 0x00, true);
            const replacementOffset = vtxView.getUint32(vtxMaterialReplacementListIdx + 0x04, true);

            const materialNames: string[] = baseMaterialNames.slice();
            let replacementIdx = vtxMaterialReplacementListIdx + replacementOffset;
            for (let i = 0; i < numReplacements; i++) {
                const materialID = vtxView.getUint16(replacementIdx + 0x00, true);
                assert(materialID < materialNames.length);
                const nameOffset = replacementIdx + vtxView.getUint32(replacementIdx + 0x04, true);
                const replacementName = readString(vtxBuffer, nameOffset);
                materialNames[materialID] = assertExists(renderContext.filesystem.searchPath(materialSearchDirs, replacementName, '.vmt'));
            }

            lodMaterialNames.push(materialNames);
            vtxMaterialReplacementListIdx += 0x08;
        }

        // We have three separate files of data (MDL, VVD, VTX) to chew through.
        //
        // MDL = Studio Model Header, contains skeleton, most aux data, animations, etc.
        // VVD = Valve Vertex Data, contains actual vertex data.
        // VTX = Optimized Model, contains per-LOD information (index buffer, optimized trilist information & material replacement).

        // The hierarchy of a model is Body Part -> Submodel -> Submodel LOD -> Mesh -> Mesh Group -> Strip
        // Note that "strips" might not actually be tristrips. They appear to be trilists in modern models.

        let mdlBodyPartIdx = bodypartindex;
        let vtxBodyPartIdx = vtxBodyPartOffset;
        for (let i = 0; i < numbodyparts; i++) {
            const bodyPartName = readString(mdlBuffer, mdlBodyPartIdx + mdlView.getUint32(mdlBodyPartIdx + 0x00, true));
            const mdlNumModels = mdlView.getUint32(mdlBodyPartIdx + 0x04, true);
            const mdlBase = mdlView.getUint32(mdlBodyPartIdx + 0x08, true);
            const mdlModelindex = mdlView.getUint32(mdlBodyPartIdx + 0x0C, true);

            const vtxNumModels = vtxView.getUint32(vtxBodyPartIdx + 0x00, true);
            assert(mdlNumModels === vtxNumModels);
            const vtxModelOffs = vtxView.getUint32(vtxBodyPartOffset + 0x04, true);

            const bodyPartData = new StudioModelBodyPartData();
            this.bodyPartData.push(bodyPartData);

            let mdlSubmodelIdx = mdlBodyPartIdx + mdlModelindex;
            let vtxSubmodelIdx = vtxBodyPartIdx + vtxModelOffs;
            for (let j = 0; j < mdlNumModels; j++) {
                const mdlSubmodelName = readString(mdlBuffer, mdlSubmodelIdx + 0x00);
                // Never written to.
                // const mdlSubmodelType = mdlView.getUint32(mdlSubmodelIdx + 0x40, true);
                const mdlSubmodelBoundingRadius = mdlView.getFloat32(mdlSubmodelIdx + 0x44, true);
                const mdlSubmodelNumMeshes = mdlView.getUint32(mdlSubmodelIdx + 0x48, true);
                const mdlSubmodelMeshindex = mdlView.getUint32(mdlSubmodelIdx + 0x4C, true);
                const mdlSubmodelNumvertices = mdlView.getUint32(mdlSubmodelIdx + 0x50, true);
                const mdlSubmodelVertexindex = mdlView.getUint32(mdlSubmodelIdx + 0x54, true);
                const mdlSubmodelTangentsindex = mdlView.getUint32(mdlSubmodelIdx + 0x58, true);
                const mdlSubmodelNumattachments = mdlView.getUint32(mdlSubmodelIdx + 0x5C, true);
                const mdlSubmodelAttachmentindex = mdlView.getUint32(mdlSubmodelIdx + 0x60, true);
                const mdlSubmodelNumeyeballs = mdlView.getUint32(mdlSubmodelIdx + 0x64, true);
                const mdlSubmodelEyeballindex = mdlView.getUint32(mdlSubmodelIdx + 0x68, true);

                // mstudio_modelvertexdata_t
                // const mdlSubmodelVertexDataPtr = mdlView.getUint32(mdlSubmodelIdx + 0x6C, true); junk pointer
                // const mdlSubmodelTangentsDataPtr = mdlView.getUint32(mdlSubmodelIdx + 0x70, true); junk pointer
                const vvdSubmodelVertexDataOffs = vvdVertexDataStart + mdlSubmodelVertexindex;
                const vvdSubmodelTangentDataOffs = vvdTangentDataStart + mdlSubmodelTangentsindex;

                // int unused[8];

                const vtxSubmodelNumLODs = vtxView.getUint32(vtxSubmodelIdx + 0x00, true);
                assert(vtxSubmodelNumLODs === vtxNumLODs);
                const vtxSubmodelLODOffset = vtxSubmodelIdx + vtxView.getUint32(vtxSubmodelIdx + 0x04, true);

                const submodelData = new StudioModelSubmodelData(mdlSubmodelName);
                bodyPartData.submodelData.push(submodelData);

                let vtxLODIdx = vtxSubmodelLODOffset;
                for (let lod = 0; lod < vtxSubmodelNumLODs; lod++) {
                    const vtxNumMeshes = vtxView.getUint32(vtxLODIdx + 0x00, true);
                    assert(vtxNumMeshes === mdlSubmodelNumMeshes);
                    const vtxMeshOffset = vtxView.getUint32(vtxLODIdx + 0x04, true);
                    const vtxSwitchPoint = vtxView.getFloat32(vtxLODIdx + 0x08, true);

                    const lodData = new StudioModelLODData();
                    submodelData.lodData.push(lodData);

                    let mdlMeshIdx = mdlSubmodelIdx + mdlSubmodelMeshindex;
                    let vtxMeshIdx = vtxLODIdx + vtxMeshOffset;
                    for (let m = 0; m < mdlSubmodelNumMeshes; m++) {
                        // MDL data is not LOD-specific, we reparse this for each LOD.
                        const material = mdlView.getUint32(mdlMeshIdx + 0x00, true);
                        const modelindex = mdlView.getUint32(mdlMeshIdx + 0x04, true);
                        const materialName = lodMaterialNames[lod][material];

                        const mdlMeshNumvertices = mdlView.getUint32(mdlMeshIdx + 0x08, true);
                        const mdlMeshVertexoffset = mdlView.getUint32(mdlMeshIdx + 0x0C, true);

                        const numflexes = mdlView.getUint32(mdlMeshIdx + 0x10, true);
                        const flexindex = mdlView.getUint32(mdlMeshIdx + 0x14, true);

                        const materialtype = mdlView.getUint32(mdlMeshIdx + 0x18, true);
                        assert(materialtype === 0); // not eyeballs
                        const materialparam = mdlView.getUint32(mdlMeshIdx + 0x1C, true);

                        const meshid = mdlView.getUint32(mdlMeshIdx + 0x20, true);
                        const centerX = mdlView.getFloat32(mdlMeshIdx + 0x24, true);
                        const centerY = mdlView.getFloat32(mdlMeshIdx + 0x28, true);
                        const centerZ = mdlView.getFloat32(mdlMeshIdx + 0x2C, true);

                        // mstudio_meshvertexdata_t
                        // const modelvertexdata = mdlView.getUint32(mdlMeshIdx + 0x30, true); junk pointer
                        const numLODVertices = nArray(8, (i) => mdlView.getUint32(mdlMeshIdx + 0x34 + i * 0x04, true));

                        // On the VTX side, each mesh contains a number of "strip groups". In theory, there can be up to
                        // four different strip groups for the 2x2 combinatoric matrix of "hw skin" and "is flex".
                        // We load the DX90 VTX files, which always have hw skin enabled, so we should see at most two
                        // flex groups.
                        const vtxNumStripGroups = vtxView.getUint32(vtxMeshIdx + 0x00, true);
                        assert(vtxNumStripGroups === 1 || vtxNumStripGroups === 2);
                        const vtxStripGroupHeaderOffset = vtxView.getUint32(vtxMeshIdx + 0x04, true);
                        const vtxMeshFlags = vtxView.getUint8(vtxMeshIdx + 0x08);

                        const meshData = new StudioModelMeshData(materialName);
                        lodData.meshData.push(meshData);
    
                        let vtxStripGroupIdx = vtxMeshIdx + vtxStripGroupHeaderOffset;
                        for (let g = 0; g < vtxNumStripGroups; g++) {
                            const numVerts = vtxView.getUint32(vtxStripGroupIdx + 0x00, true);
                            const vertOffset = vtxView.getUint32(vtxStripGroupIdx + 0x04, true);

                            const numIndices = vtxView.getUint32(vtxStripGroupIdx + 0x08, true);
                            const indexOffset = vtxView.getUint32(vtxStripGroupIdx + 0x0C, true);

                            const numStrips = vtxView.getUint32(vtxStripGroupIdx + 0x10, true);
                            const stripOffset = vtxView.getUint32(vtxStripGroupIdx + 0x14, true);

                            const stripGroupFlags: OptimizeStripGroupFlags = vtxView.getUint8(vtxStripGroupIdx + 0x18);
                            // DX90 VTX models should always have hw skin enabled.
                            assert(!!(stripGroupFlags & OptimizeStripGroupFlags.IS_HWSKINNED));

                            // Allocate the vertex / index data for our strip group, before unpacking each strip.

                            // 3 pos, 4 normal, 4 tangent, 2 uv
                            const vertexSize = (3+4+4+2);
                            const vertexData = new Float32Array(vertexSize * numVerts);

                            // Build the vertex data for our strip group.
                            let dstOffs = 0;
                            let vertIdx = vtxStripGroupIdx + vertOffset;
                            for (let v = 0; v < numVerts; v++) {
                                // VTX Bone weight data.
                                const vtxBoneWeightIdx0 = vtxView.getUint8(vertIdx + 0x00);
                                const vtxBoneWeightIdx1 = vtxView.getUint8(vertIdx + 0x01);
                                const vtxBoneWeightIdx2 = vtxView.getUint8(vertIdx + 0x02);
                                const vtxNumBones = vtxView.getUint8(vertIdx + 0x03);
                                assert(vtxNumBones === 0);

                                const vtxOrigMeshVertID = vtxView.getUint16(vertIdx + 0x04, true);
                                const vtxBoneID0 = vtxView.getUint8(vertIdx + 0x06);
                                const vtxBoneID1 = vtxView.getUint8(vertIdx + 0x07);
                                const vtxBoneID2 = vtxView.getUint8(vertIdx + 0x08);

                                // Pull out VVD vertex data.
                                const modelVertIndex = (mdlMeshVertexoffset + vtxOrigMeshVertID);
                                const vvdVertIndex = fixupRemappingSearch(fixupRemappings, modelVertIndex);
                                const vvdVertexOffs = vvdSubmodelVertexDataOffs + 0x30 * vvdVertIndex;
                                const vvdTangentOffs = vvdSubmodelTangentDataOffs + 0x10 * vvdVertIndex;

                                const vvdBoneWeight0 = vvdView.getFloat32(vvdVertexOffs + 0x00, true);
                                const vvdBoneWeight1 = vvdView.getFloat32(vvdVertexOffs + 0x04, true);
                                const vvdBoneWeight2 = vvdView.getFloat32(vvdVertexOffs + 0x08, true);
                                const vvdBoneIdx0 = vvdView.getUint8(vvdVertexOffs + 0x0C);
                                const vvdBoneIdx1 = vvdView.getUint8(vvdVertexOffs + 0x0D);
                                const vvdBoneIdx2 = vvdView.getUint8(vvdVertexOffs + 0x0E);
                                const vvdNumBones = vvdView.getUint8(vvdVertexOffs + 0x0F);

                                const vvdPositionX = vvdView.getFloat32(vvdVertexOffs + 0x10, true);
                                const vvdPositionY = vvdView.getFloat32(vvdVertexOffs + 0x14, true);
                                const vvdPositionZ = vvdView.getFloat32(vvdVertexOffs + 0x18, true);

                                const vvdNormalX = vvdView.getFloat32(vvdVertexOffs + 0x1C, true);
                                const vvdNormalY = vvdView.getFloat32(vvdVertexOffs + 0x20, true);
                                const vvdNormalZ = vvdView.getFloat32(vvdVertexOffs + 0x24, true);

                                const vvdTexCoordS = vvdView.getFloat32(vvdVertexOffs + 0x28, true);
                                const vvdTexCoordT = vvdView.getFloat32(vvdVertexOffs + 0x2C, true);

                                const vvdTangentSX = vvdView.getFloat32(vvdTangentOffs + 0x00, true);
                                const vvdTangentSY = vvdView.getFloat32(vvdTangentOffs + 0x04, true);
                                const vvdTangentSZ = vvdView.getFloat32(vvdTangentOffs + 0x08, true);
                                const vvdTangentSW = vvdView.getFloat32(vvdTangentOffs + 0x0C, true);

                                // Sanity check our tangent sign data.
                                // TODO(jstpierre): Check the tangent data validity against our material.
                                assert(vvdTangentSW === 0.0 || vvdTangentSW === 1.0 || vvdTangentSW === -1.0);

                                // Position
                                vertexData[dstOffs++] = vvdPositionX;
                                vertexData[dstOffs++] = vvdPositionY;
                                vertexData[dstOffs++] = vvdPositionZ;

                                // Normal
                                vertexData[dstOffs++] = vvdNormalX;
                                vertexData[dstOffs++] = vvdNormalY;
                                vertexData[dstOffs++] = vvdNormalZ;
                                vertexData[dstOffs++] = 1.0; // vertex alpha

                                // Tangent
                                vertexData[dstOffs++] = vvdTangentSX;
                                vertexData[dstOffs++] = vvdTangentSY;
                                vertexData[dstOffs++] = vvdTangentSZ;
                                vertexData[dstOffs++] = vvdTangentSW;

                                // Texcoord
                                vertexData[dstOffs++] = vvdTexCoordS;
                                vertexData[dstOffs++] = vvdTexCoordT;

                                vertIdx += 0x09;
                            }

                            // Index data is directly from the strip
                            const indexIdx = vtxStripGroupIdx + indexOffset;
                            const indexData = vtxBuffer.subarray(indexIdx, numIndices * 2);

                            const device = renderContext.device, cache = renderContext.cache;

                            const stripGroupData = new StudioModelStripGroupData(device, cache, vertexData.buffer, indexData);
                            meshData.stripGroupData.push(stripGroupData);

                            // Note that as noted before, "tristrip" in modern models refers mostly to trilists, not tristrips.
                            // We can have multiple strips in a strip group if we have a bone change table between strips.
                            // For unskinned / static prop models without bones, we should always have one strip.
                            // TODO(jstpierre): Handle skinned models.
                            let vtxStripIdx = vtxStripGroupIdx + stripOffset;
                            assert(numStrips === 1);
                            for (let s = 0; s < numStrips; s++) {
                                const stripNumIndices = vtxView.getUint32(vtxStripIdx + 0x00, true);
                                const stripIndexOffset = vtxView.getUint32(vtxStripIdx + 0x04, true);
                                assert(stripNumIndices === numIndices);
                                assert(stripIndexOffset === 0);

                                const stripNumVerts = vtxView.getUint32(vtxStripIdx + 0x08, true);
                                const stripVertOffset = vtxView.getUint32(vtxStripIdx + 0x0C, true);
                                assert(stripNumVerts === numVerts);
                                assert(stripVertOffset === 0);

                                const numBones = vtxView.getUint16(vtxStripIdx + 0x10, true);
                                assert(numBones === 0);

                                const stripFlags: OptimizeStripFlags = vtxView.getUint8(vtxStripIdx + 0x12);
                                assert(stripFlags === OptimizeStripFlags.IS_TRILIST);

                                const numBoneStateChanges = vtxView.getUint32(vtxStripIdx + 0x13, true);
                                const boneStateChangeOffset = vtxView.getUint32(vtxStripIdx + 0x17, true);
                                assert(numBoneStateChanges === 0);

                                stripGroupData.stripData.push(new StudioModelStripData(stripIndexOffset, stripNumIndices));

                                vtxStripIdx += 0x1C;
                            }

                            vtxStripGroupIdx += 0x1C;
                        }

                        mdlMeshIdx += 0x74;
                        vtxMeshIdx += 0x09;
                    }

                    vtxLODIdx += 0x0C;

                    // TODO(jstpierre): Support multiple model LODs. For now, we only support the first LOD.
                    break;
                }

                mdlSubmodelIdx += 0x94;
                vtxSubmodelIdx += 0x08;
            }

            mdlBodyPartIdx += 0x10;
            vtxBodyPartIdx += 0x08;
        }
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.bodyPartData.length; i++)
            this.bodyPartData[i].destroy(device);
    }
}

export class StudioModelCache {
    private modelData = new Map<string, StudioModelData>();
    private modelDataPromiseCache = new Map<string, Promise<StudioModelData>>();

    constructor(private renderContext: SourceRenderContext, private filesystem: SourceFileSystem) {
    }

    private resolvePath(path: string, ext: string): string {
        if (path.endsWith('.mdl'))
            path = path.slice(0, -4);
        if (!path.endsWith(ext))
            path = `${path}${ext}`;
        return this.filesystem.resolvePath(path, ext);
    }

    private async fetchStudioModelDataInternal(name: string): Promise<StudioModelData> {
        const mdlPath = this.resolvePath(name, '.mdl');
        const vvdPath = this.resolvePath(name, '.vvd');
        const vtxPath = this.resolvePath(name, '.dx90.vtx');
        const [mdlBuffer, vvdBuffer, vtxBuffer] = await Promise.all([
            this.filesystem.fetchFileData(mdlPath),
            this.filesystem.fetchFileData(vvdPath),
            this.filesystem.fetchFileData(vtxPath),
        ]);
        return new StudioModelData(this.renderContext, mdlBuffer!, vvdBuffer!, vtxBuffer!);
    }

    public fetchStudioModelData(path: string): Promise<StudioModelData> {
        if (!this.modelDataPromiseCache.has(path))
            this.modelDataPromiseCache.set(path, this.fetchStudioModelDataInternal(path));
        return this.modelDataPromiseCache.get(path)!;
    }

    public destroy(device: GfxDevice): void {
        for (const vtf of this.modelData.values())
            vtf.destroy(device);
    }
}

class StudioModelMeshInstance {
    private visible = true;
    private materialInstance: BaseMaterial | null = null;

    constructor(renderContext: SourceRenderContext, private meshData: StudioModelMeshData) {
        this.bindMaterial(renderContext);
    }

    private async bindMaterial(renderContext: SourceRenderContext): Promise<void> {
        this.materialInstance = await renderContext.materialCache.createMaterialInstance(renderContext, this.meshData.materialName);
    }

    public movement(renderContext: SourceRenderContext): void {
        if (!this.visible || this.materialInstance === null)
            return;

        this.materialInstance.movement(renderContext);
    }

    public prepareToRender(renderContext: SourceRenderContext, renderInstManager: GfxRenderInstManager, modelMatrix: mat4) {
        if (!this.visible || this.materialInstance === null || !this.materialInstance.visible || !this.materialInstance.isMaterialLoaded())
            return;

        const template = renderInstManager.pushTemplateRenderInst();
        this.materialInstance.setOnRenderInst(renderContext, template, modelMatrix);

        for (let i = 0; i < this.meshData.stripGroupData.length; i++) {
            const stripGroupData = this.meshData.stripGroupData[i];
            stripGroupData.setOnRenderInst(template);

            for (let j = 0; j < stripGroupData.stripData.length; j++) {
                const stripData = stripGroupData.stripData[j];
                const renderInst = renderInstManager.newRenderInst();
                renderInst.drawIndexes(stripData.indexCount, stripData.firstIndex);
                renderInstManager.submitRenderInst(renderInst);
            }
        }

        renderInstManager.popTemplateRenderInst();
    }
}

class StudioModelLODInstance {
    public meshInstance: StudioModelMeshInstance[] = [];

    constructor(renderContext: SourceRenderContext, private lodData: StudioModelLODData) {
        for (let i = 0; i < this.lodData.meshData.length; i++)
            this.meshInstance.push(new StudioModelMeshInstance(renderContext, this.lodData.meshData[i]));
    }

    public movement(renderContext: SourceRenderContext): void {
        for (let i = 0; i < this.meshInstance.length; i++)
            this.meshInstance[i].movement(renderContext);
    }

    public prepareToRender(renderContext: SourceRenderContext, renderInstManager: GfxRenderInstManager, modelMatrix: mat4) {
        for (let i = 0; i < this.meshInstance.length; i++)
            this.meshInstance[i].prepareToRender(renderContext, renderInstManager, modelMatrix);
    }
}

export class StudioModelInstance {
    public visible: boolean = true;
    public modelMatrix = mat4.create();

    private lodInstance: StudioModelLODInstance[] = [];

    constructor(renderContext: SourceRenderContext, private modelData: StudioModelData) {
        for (let i = 0; i < this.modelData.bodyPartData.length; i++) {
            const bodyPartData = this.modelData.bodyPartData[i];
            for (let j = 0; j < bodyPartData.submodelData.length; j++) {
                const submodelData = bodyPartData.submodelData[j];
                for (let k = 0; k < submodelData.lodData.length; k++) {
                    const lodData = submodelData.lodData[k];
                    this.lodInstance.push(new StudioModelLODInstance(renderContext, lodData));
                }
            }
        }
    }

    private getLODModelIndex(renderContext: SourceRenderContext): number {
        // TODO(jstpierre): Pull out the proper LOD model.
        return 0;
    }

    public movement(renderContext: SourceRenderContext): void {
        const lodIndex = this.getLODModelIndex(renderContext);
        this.lodInstance[lodIndex].movement(renderContext);
    }

    public prepareToRender(renderContext: SourceRenderContext, renderInstManager: GfxRenderInstManager) {
        if (!this.visible)
            return;

        // TODO(jstpierre): Leaf visibility, frustum culling

        const lodIndex = this.getLODModelIndex(renderContext);
        this.lodInstance[lodIndex].prepareToRender(renderContext, renderInstManager, this.modelMatrix);
    }
}
